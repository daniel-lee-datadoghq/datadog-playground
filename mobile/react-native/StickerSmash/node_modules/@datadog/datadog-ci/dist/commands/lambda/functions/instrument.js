"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateUpdateRequest = exports.getInstrumentedFunctionConfigsFromRegEx = exports.getInstrumentedFunctionConfig = exports.getInstrumentedFunctionConfigs = void 0;
const constants_1 = require("../../../constants");
const validation_1 = require("../../../helpers/validation");
const constants_2 = require("../constants");
const loggroup_1 = require("../loggroup");
const tags_1 = require("../tags");
const commons_1 = require("./commons");
const versionChecker_1 = require("./versionChecker");
const getInstrumentedFunctionConfigs = (lambdaClient, cloudWatchLogsClient, region, functionARNs, settings) => __awaiter(void 0, void 0, void 0, function* () {
    const lambdaFunctionConfigs = yield (0, commons_1.getLambdaFunctionConfigs)(lambdaClient, functionARNs);
    const configs = [];
    for (const config of lambdaFunctionConfigs) {
        const functionConfig = yield (0, exports.getInstrumentedFunctionConfig)(lambdaClient, cloudWatchLogsClient, config, region, settings);
        configs.push(functionConfig);
    }
    return configs;
});
exports.getInstrumentedFunctionConfigs = getInstrumentedFunctionConfigs;
const getInstrumentedFunctionConfig = (lambdaClient, cloudWatchLogsClient, config, region, settings) => __awaiter(void 0, void 0, void 0, function* () {
    const functionARN = config.FunctionArn;
    const runtime = config.Runtime;
    if (!(0, commons_1.isSupportedRuntime)(runtime)) {
        throw Error(`Can't instrument ${functionARN}, runtime ${runtime} not supported`);
    }
    const updateRequest = yield (0, exports.calculateUpdateRequest)(config, settings, region, runtime);
    let logGroupConfiguration;
    if (settings.forwarderARN !== undefined) {
        const logGroupName = `/aws/lambda/${config.FunctionName}`;
        logGroupConfiguration = yield (0, loggroup_1.calculateLogGroupUpdateRequest)(cloudWatchLogsClient, logGroupName, settings.forwarderARN);
    }
    const tagConfiguration = yield (0, tags_1.calculateTagUpdateRequest)(lambdaClient, functionARN);
    return {
        functionARN,
        lambdaConfig: config,
        logGroupConfiguration,
        tagConfiguration,
        updateFunctionConfigurationCommandInput: updateRequest,
    };
});
exports.getInstrumentedFunctionConfig = getInstrumentedFunctionConfig;
const getInstrumentedFunctionConfigsFromRegEx = (lambdaClient, cloudWatchLogsClient, region, pattern, settings) => __awaiter(void 0, void 0, void 0, function* () {
    const matchedFunctions = yield (0, commons_1.getLambdaFunctionConfigsFromRegex)(lambdaClient, pattern);
    const functionsToUpdate = [];
    for (const config of matchedFunctions) {
        const functionConfig = yield (0, exports.getInstrumentedFunctionConfig)(lambdaClient, cloudWatchLogsClient, config, region, settings);
        functionsToUpdate.push(functionConfig);
    }
    return functionsToUpdate;
});
exports.getInstrumentedFunctionConfigsFromRegEx = getInstrumentedFunctionConfigsFromRegEx;
const calculateUpdateRequest = (config, settings, region, runtime) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f;
    const oldEnvVars = Object.assign({}, (_a = config.Environment) === null || _a === void 0 ? void 0 : _a.Variables);
    const changedEnvVars = {};
    const functionARN = config.FunctionArn;
    const apiKey = (_b = process.env[constants_1.CI_API_KEY_ENV_VAR]) !== null && _b !== void 0 ? _b : process.env[constants_1.API_KEY_ENV_VAR];
    const apiKeySecretArn = process.env[constants_2.CI_API_KEY_SECRET_ARN_ENV_VAR];
    const apiKmsKey = process.env[constants_2.CI_KMS_API_KEY_ENV_VAR];
    const site = process.env[constants_1.CI_SITE_ENV_VAR];
    if (functionARN === undefined) {
        return undefined;
    }
    const updateRequest = {
        FunctionName: functionARN,
    };
    let needsUpdate = false;
    const runtimeType = constants_2.RUNTIME_LOOKUP[runtime];
    if (runtimeType === constants_2.RuntimeType.CUSTOM) {
        if (settings.layerVersion !== undefined) {
            throw new Error(`Only the --extension-version argument should be set for the ${runtime} runtime. Please remove the --layer-version argument from the instrument command.`);
        }
    }
    // Update Python Handler
    if (runtimeType === constants_2.RuntimeType.PYTHON && (settings.layerVersion !== undefined || settings.interactive)) {
        const expectedHandler = constants_2.PYTHON_HANDLER_LOCATION;
        if (config.Handler !== expectedHandler) {
            needsUpdate = true;
            updateRequest.Handler = constants_2.PYTHON_HANDLER_LOCATION;
        }
    }
    // Update Node Handler
    if (runtimeType === constants_2.RuntimeType.NODE && (settings.layerVersion !== undefined || settings.interactive)) {
        const expectedHandler = constants_2.NODE_HANDLER_LOCATION;
        if (config.Handler !== expectedHandler) {
            needsUpdate = true;
            updateRequest.Handler = constants_2.NODE_HANDLER_LOCATION;
        }
    }
    // Update Env Vars
    if (runtimeType === constants_2.RuntimeType.PYTHON || runtimeType === constants_2.RuntimeType.NODE) {
        if (oldEnvVars[constants_2.LAMBDA_HANDLER_ENV_VAR] === undefined) {
            needsUpdate = true;
            changedEnvVars[constants_2.LAMBDA_HANDLER_ENV_VAR] = (_c = config.Handler) !== null && _c !== void 0 ? _c : '';
        }
    }
    // KMS > Secrets Manager > API Key
    if (apiKmsKey !== undefined && oldEnvVars[constants_2.KMS_API_KEY_ENV_VAR] !== apiKmsKey) {
        needsUpdate = true;
        changedEnvVars[constants_2.KMS_API_KEY_ENV_VAR] = apiKmsKey;
    }
    else if (apiKeySecretArn !== undefined && oldEnvVars[constants_2.API_KEY_SECRET_ARN_ENV_VAR] !== apiKeySecretArn) {
        const isNode = runtimeType === constants_2.RuntimeType.NODE;
        const isSendingSynchronousMetrics = settings.extensionVersion === undefined && !settings.flushMetricsToLogs;
        if (isSendingSynchronousMetrics && isNode) {
            throw new Error('`apiKeySecretArn` is not supported for Node runtimes when using Synchronous Metrics. Use either `apiKey` or `apiKmsKey`.');
        }
        needsUpdate = true;
        changedEnvVars[constants_2.API_KEY_SECRET_ARN_ENV_VAR] = apiKeySecretArn;
    }
    else if (apiKey !== undefined && oldEnvVars[constants_1.API_KEY_ENV_VAR] !== apiKey) {
        needsUpdate = true;
        changedEnvVars[constants_1.API_KEY_ENV_VAR] = apiKey;
    }
    if (site !== undefined && oldEnvVars[constants_1.SITE_ENV_VAR] !== site) {
        if ((0, validation_1.isValidDatadogSite)(site)) {
            needsUpdate = true;
            changedEnvVars[constants_1.SITE_ENV_VAR] = site;
        }
        else {
            throw new Error('Warning: Invalid site URL. Must be either datadoghq.com, datadoghq.eu, us3.datadoghq.com, us5.datadoghq.com, ap1.datadoghq.com, ap2.datadoghq.com, or ddog-gov.com.');
        }
    }
    if (site === undefined && oldEnvVars[constants_1.SITE_ENV_VAR] === undefined) {
        needsUpdate = true;
        changedEnvVars[constants_1.SITE_ENV_VAR] = 'datadoghq.com';
    }
    const environmentVarsTupleArray = [
        ['apmFlushDeadline', constants_2.APM_FLUSH_DEADLINE_MILLISECONDS_ENV_VAR],
        ['appsecEnabled', constants_2.APPSEC_ENABLED_ENV_VAR],
        ['captureLambdaPayload', constants_2.CAPTURE_LAMBDA_PAYLOAD_ENV_VAR],
        ['environment', constants_1.ENVIRONMENT_ENV_VAR],
        ['extraTags', constants_1.DD_TAGS_ENV_VAR],
        ['loggingEnabled', constants_2.LOG_ENABLED_ENV_VAR],
        ['mergeXrayTraces', constants_2.MERGE_XRAY_TRACES_ENV_VAR],
        ['service', constants_1.SERVICE_ENV_VAR],
        ['tracingEnabled', constants_1.DD_TRACE_ENABLED_ENV_VAR],
        ['version', constants_1.VERSION_ENV_VAR],
        ['llmobsMlApp', constants_1.DD_LLMOBS_ML_APP_ENV_VAR],
    ];
    for (const [key, environmentVar] of environmentVarsTupleArray) {
        if (settings[key] !== undefined && oldEnvVars[environmentVar] !== ((_d = settings[key]) === null || _d === void 0 ? void 0 : _d.toString())) {
            needsUpdate = true;
            changedEnvVars[environmentVar] = settings[key].toString();
        }
    }
    // Skip adding DD_FLUSH_TO_LOGS when using Extension
    const isUsingExtension = settings.extensionVersion !== undefined;
    if (!isUsingExtension &&
        settings.flushMetricsToLogs !== undefined &&
        oldEnvVars[constants_2.FLUSH_TO_LOG_ENV_VAR] !== ((_e = settings.flushMetricsToLogs) === null || _e === void 0 ? void 0 : _e.toString())) {
        needsUpdate = true;
        changedEnvVars[constants_2.FLUSH_TO_LOG_ENV_VAR] = settings.flushMetricsToLogs.toString();
    }
    const newEnvVars = Object.assign(Object.assign({}, oldEnvVars), changedEnvVars);
    if (newEnvVars[constants_1.DD_LOG_LEVEL_ENV_VAR] !== settings.logLevel) {
        needsUpdate = true;
        if (settings.logLevel) {
            newEnvVars[constants_1.DD_LOG_LEVEL_ENV_VAR] = settings.logLevel;
        }
        else {
            delete newEnvVars[constants_1.DD_LOG_LEVEL_ENV_VAR];
        }
    }
    // Enable ASM
    if (settings['appsecEnabled'] === true) {
        newEnvVars[constants_2.AWS_LAMBDA_EXEC_WRAPPER_VAR] = constants_2.AWS_LAMBDA_EXEC_WRAPPER;
    }
    // Enable LLMObs
    if (settings['llmobsMlApp'] !== undefined) {
        newEnvVars[constants_1.DD_LLMOBS_ENABLED_ENV_VAR] = 'true';
        newEnvVars[constants_1.DD_LLMOBS_ML_APP_ENV_VAR] = settings['llmobsMlApp'];
        // For LLM Observability to use the agent from the extension layer as a proxy.
        // LLM Observability setup documentation will point to the `-e` extension layer option to
        // always use the extension layer.
        newEnvVars[constants_1.DD_LLMOBS_AGENTLESS_ENABLED_ENV_VAR] = 'false';
    }
    let layerARNs = (0, commons_1.getLayers)(config);
    const originalLayerARNs = layerARNs;
    let needsLayerUpdate = false;
    let layerOrTraceVersion;
    if ((0, commons_1.isLayerRuntime)(runtime)) {
        const lambdaLibraryLayerArn = (0, commons_1.getLayerArn)(config, config.Runtime, region, settings);
        const lambdaLibraryLayerName = constants_2.LAYER_LOOKUP[runtime];
        let fullLambdaLibraryLayerARN;
        if (settings.layerVersion !== undefined || settings.interactive) {
            layerOrTraceVersion = settings.layerVersion;
            if (settings.interactive && !settings.layerVersion) {
                layerOrTraceVersion = yield (0, commons_1.findLatestLayerVersion)(config.Runtime, region);
            }
            fullLambdaLibraryLayerARN = `${lambdaLibraryLayerArn}:${layerOrTraceVersion}`;
        }
        layerARNs = (0, commons_1.addLayerArn)(fullLambdaLibraryLayerARN, lambdaLibraryLayerName, layerARNs);
    }
    const lambdaExtensionLayerArn = (0, commons_1.getLayerArn)(config, constants_2.EXTENSION_LAYER_KEY, region, settings);
    let fullExtensionLayerARN;
    let extensionVersion;
    if (settings.extensionVersion !== undefined || settings.interactive) {
        extensionVersion = settings.extensionVersion;
        if (settings.interactive && !settings.extensionVersion) {
            extensionVersion = yield (0, commons_1.findLatestLayerVersion)(constants_2.EXTENSION_LAYER_KEY, region);
        }
        if (settings.lambdaFips) {
            if (oldEnvVars[constants_2.DD_LAMBDA_FIPS_MODE_ENV_VAR] !== 'true') {
                needsUpdate = true;
                newEnvVars[constants_2.DD_LAMBDA_FIPS_MODE_ENV_VAR] = 'true';
            }
        }
        fullExtensionLayerARN = `${lambdaExtensionLayerArn}:${extensionVersion}`;
    }
    layerARNs = (0, commons_1.addLayerArn)(fullExtensionLayerARN, constants_2.DD_LAMBDA_EXTENSION_LAYER_NAME, layerARNs);
    // Special handling for .NET and Java to support universal instrumentation
    if (runtimeType === constants_2.RuntimeType.DOTNET || runtimeType === constants_2.RuntimeType.JAVA) {
        if (layerOrTraceVersion && (0, versionChecker_1.isExtensionCompatibleWithUniversalInstrumentation)(runtimeType, extensionVersion)) {
            // If the user configures the trace version and the extension support univeral instrumenation
            // Then check whether the trace and extension are compatible with each other
            if ((0, versionChecker_1.isTracerCompatibleWithExtension)(runtimeType, layerOrTraceVersion)) {
                needsUpdate = true;
                newEnvVars[constants_2.AWS_LAMBDA_EXEC_WRAPPER_VAR] = constants_2.AWS_LAMBDA_EXEC_WRAPPER;
            }
            else {
                throw new Error(`For the ${runtime} runtime, the dd-trace version ${layerOrTraceVersion} is not compatible with the dd-extension version ${extensionVersion}`);
            }
        }
        else if (runtimeType === constants_2.RuntimeType.DOTNET) {
            // If it is an old extension version or the trace version is null, leave it is as the old workflow
            if (!(0, versionChecker_1.isExtensionCompatibleWithUniversalInstrumentation)(runtimeType, extensionVersion) &&
                ((_f = config.Architectures) === null || _f === void 0 ? void 0 : _f.includes(constants_2.ARM64_ARCHITECTURE))) {
                throw new Error('Instrumenting arm64 architecture is not supported for the given dd-extension version. Please choose the latest dd-extension version or use x86_64 architecture.');
            }
            else {
                needsUpdate = true;
                newEnvVars[constants_2.ENABLE_PROFILING_ENV_VAR] = constants_2.CORECLR_ENABLE_PROFILING;
                newEnvVars[constants_2.PROFILER_ENV_VAR] = constants_2.CORECLR_PROFILER;
                newEnvVars[constants_2.PROFILER_PATH_ENV_VAR] = constants_2.CORECLR_PROFILER_PATH;
                newEnvVars[constants_2.DOTNET_TRACER_HOME_ENV_VAR] = constants_2.DD_DOTNET_TRACER_HOME;
            }
        }
    }
    updateRequest.Environment = {
        Variables: newEnvVars,
    };
    if (originalLayerARNs.sort().join(',') !== layerARNs.sort().join(',')) {
        needsLayerUpdate = true;
    }
    if (needsLayerUpdate) {
        needsUpdate = true;
        updateRequest.Layers = layerARNs;
    }
    layerARNs.forEach((layerARN) => {
        if (layerARN.includes(constants_2.DD_LAMBDA_EXTENSION_LAYER_NAME) &&
            newEnvVars[constants_1.API_KEY_ENV_VAR] === undefined &&
            newEnvVars[constants_2.API_KEY_SECRET_ARN_ENV_VAR] === undefined &&
            newEnvVars[constants_2.KMS_API_KEY_ENV_VAR] === undefined) {
            throw new Error(`When 'extensionLayer' is set, ${constants_1.CI_API_KEY_ENV_VAR}, ${constants_2.CI_KMS_API_KEY_ENV_VAR}, or ${constants_2.CI_API_KEY_SECRET_ARN_ENV_VAR} must also be set`);
        }
    });
    return needsUpdate ? updateRequest : undefined;
});
exports.calculateUpdateRequest = calculateUpdateRequest;
//# sourceMappingURL=instrument.js.map