"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasVersionTag = exports.calculateTagRemoveRequest = exports.calculateTagUpdateRequest = exports.untagResource = exports.tagResource = exports.applyTagConfig = void 0;
const client_lambda_1 = require("@aws-sdk/client-lambda");
const version_1 = require("../../helpers/version");
const constants_1 = require("./constants");
const applyTagConfig = (lambdaClient, config) => __awaiter(void 0, void 0, void 0, function* () {
    const { tagResourceCommandInput, untagResourceCommandInput } = config;
    if (tagResourceCommandInput !== undefined) {
        yield (0, exports.tagResource)(lambdaClient, tagResourceCommandInput);
    }
    if (untagResourceCommandInput !== undefined) {
        yield (0, exports.untagResource)(lambdaClient, untagResourceCommandInput);
    }
});
exports.applyTagConfig = applyTagConfig;
const tagResource = (client, input) => __awaiter(void 0, void 0, void 0, function* () {
    const command = new client_lambda_1.TagResourceCommand(input);
    yield client.send(command);
});
exports.tagResource = tagResource;
const untagResource = (client, input) => __awaiter(void 0, void 0, void 0, function* () {
    const command = new client_lambda_1.UntagResourceCommand(input);
    yield client.send(command);
});
exports.untagResource = untagResource;
const calculateTagUpdateRequest = (lambdaClient, functionARN) => __awaiter(void 0, void 0, void 0, function* () {
    const config = {};
    const versionTagPresent = yield (0, exports.hasVersionTag)(lambdaClient, functionARN);
    if (!versionTagPresent) {
        config.tagResourceCommandInput = {
            Resource: functionARN,
            Tags: {
                [constants_1.TAG_VERSION_NAME]: `v${version_1.version}`,
            },
        };
        return config;
    }
    return;
});
exports.calculateTagUpdateRequest = calculateTagUpdateRequest;
const calculateTagRemoveRequest = (lambdaClient, functionARN) => __awaiter(void 0, void 0, void 0, function* () {
    const config = {};
    const versionTagPresent = yield (0, exports.hasVersionTag)(lambdaClient, functionARN);
    if (versionTagPresent) {
        config.untagResourceCommandInput = {
            Resource: functionARN,
            TagKeys: [constants_1.TAG_VERSION_NAME],
        };
        return config;
    }
    return;
});
exports.calculateTagRemoveRequest = calculateTagRemoveRequest;
const hasVersionTag = (client, functionARN) => __awaiter(void 0, void 0, void 0, function* () {
    const input = {
        Resource: functionARN,
    };
    const command = new client_lambda_1.ListTagsCommand(input);
    const response = yield client.send(command);
    const { Tags } = response;
    return Tags !== undefined && Tags[constants_1.TAG_VERSION_NAME] === `v${version_1.version}`;
});
exports.hasVersionTag = hasVersionTag;
//# sourceMappingURL=tags.js.map