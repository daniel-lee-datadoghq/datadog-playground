"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateInsightsFile = exports.getFramework = exports.sleep = exports.convertToCSV = exports.getUniqueFileNames = exports.getTags = exports.getAllLogs = exports.getLogEvents = exports.getLogStreamNames = exports.summarizeConfig = exports.LambdaFlareCommand = void 0;
const fs = __importStar(require("fs"));
const util_1 = __importDefault(require("util"));
const client_cloudwatch_logs_1 = require("@aws-sdk/client-cloudwatch-logs");
const client_lambda_1 = require("@aws-sdk/client-lambda");
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const upath_1 = __importDefault(require("upath"));
const constants_1 = require("../../constants");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const flare_1 = require("../../helpers/flare");
const fs_1 = require("../../helpers/fs");
const prompt_1 = require("../../helpers/prompt");
const helpersRenderer = __importStar(require("../../helpers/renderer"));
const renderer_1 = require("../../helpers/renderer");
const utils_1 = require("../../helpers/utils");
const version_1 = require("../../helpers/version");
const constants_2 = require("./constants");
const commons_1 = require("./functions/commons");
const prompt_2 = require("./prompt");
const commonRenderer = __importStar(require("./renderers/common-renderer"));
const FUNCTION_CONFIG_FILE_NAME = 'function_config.json';
const TAGS_FILE_NAME = 'tags.json';
const FLARE_ZIP_FILE_NAME = 'lambda-flare-output.zip';
const MAX_LOG_STREAMS = 50;
const DEFAULT_LOG_STREAMS = 3;
const MAX_LOG_EVENTS_PER_STREAM = 1000;
const SUMMARIZED_FIELDS = new Set(['FunctionName', 'Runtime', 'FunctionArn', 'Handler', 'Environment']);
class LambdaFlareCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.isDryRun = clipanion_1.Option.Boolean('-d,--dry,--dry-run', false);
        this.withLogs = clipanion_1.Option.Boolean('--with-logs', false);
        this.functionName = clipanion_1.Option.String('-f,--function');
        this.region = clipanion_1.Option.String('-r,--region');
        this.caseId = clipanion_1.Option.String('-c,--case-id');
        this.email = clipanion_1.Option.String('-e,--email');
        this.start = clipanion_1.Option.String('--start');
        this.end = clipanion_1.Option.String('--end');
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.config = {
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
    }
    /**
     * Entry point for the `lambda flare` command.
     * Gathers config, logs, tags, project files, and more from a
     * Lambda function and sends them to Datadog support.
     * @returns 0 if the command ran successfully, 1 otherwise.
     */
    execute() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.config.fips, this.fipsIgnoreError || this.config.fipsIgnoreError);
            yield (0, flare_1.validateCliVersion)(this.context.stdout);
            this.context.stdout.write(helpersRenderer.renderFlareHeader('Lambda', this.isDryRun));
            // Validate function name
            if (this.functionName === undefined) {
                this.context.stderr.write(helpersRenderer.renderError('No function name specified. [-f,--function]'));
                return 1;
            }
            const errorMessages = [];
            // Validate region
            const region = (_b = (_a = (0, commons_1.getRegion)(this.functionName)) !== null && _a !== void 0 ? _a : this.region) !== null && _b !== void 0 ? _b : process.env[constants_2.AWS_DEFAULT_REGION_ENV_VAR];
            if (region === undefined) {
                errorMessages.push(commonRenderer.renderNoDefaultRegionSpecifiedError());
            }
            // Validate Datadog API key
            this.apiKey = (_c = process.env[constants_1.CI_API_KEY_ENV_VAR]) !== null && _c !== void 0 ? _c : process.env[constants_1.API_KEY_ENV_VAR];
            if (this.apiKey === undefined) {
                errorMessages.push(helpersRenderer.renderError('No Datadog API key specified. Set an API key with the DD_API_KEY environment variable.'));
            }
            // Validate case ID
            if (this.caseId === undefined) {
                errorMessages.push(helpersRenderer.renderError('No case ID specified. [-c,--case-id]'));
            }
            // Validate email
            if (this.email === undefined) {
                errorMessages.push(helpersRenderer.renderError('No email specified. [-e,--email]'));
            }
            // Validate start/end flags if both are specified
            let startMillis;
            let endMillis;
            try {
                ;
                [startMillis, endMillis] = (0, flare_1.validateStartEndFlags)(this.start, this.end);
            }
            catch (err) {
                if (err instanceof Error) {
                    errorMessages.push(helpersRenderer.renderError(err.message));
                }
            }
            if (errorMessages.length > 0) {
                for (const message of errorMessages) {
                    this.context.stderr.write(message);
                }
                return 1;
            }
            // Get AWS credentials
            this.context.stdout.write(chalk_1.default.bold('\nüîë Getting AWS credentials...\n'));
            try {
                this.credentials = yield (0, commons_1.getAWSCredentials)();
            }
            catch (err) {
                if (err instanceof Error) {
                    this.context.stderr.write(helpersRenderer.renderError(err.message));
                }
                return 1;
            }
            if (this.credentials === undefined) {
                this.context.stdout.write('\n' + commonRenderer.renderNoAWSCredentialsFound());
                try {
                    yield (0, prompt_2.requestAWSCredentials)();
                }
                catch (err) {
                    if (err instanceof Error) {
                        this.context.stderr.write(helpersRenderer.renderError(err.message));
                    }
                    return 1;
                }
            }
            // Get and print Lambda function configuration
            this.context.stdout.write(chalk_1.default.bold('\nüîç Fetching Lambda function configuration...\n'));
            const lambdaClientConfig = {
                region,
                credentials: this.credentials,
                retryStrategy: constants_2.EXPONENTIAL_BACKOFF_RETRY_STRATEGY,
            };
            const lambdaClient = new client_lambda_1.LambdaClient(lambdaClientConfig);
            let config;
            try {
                config = yield (0, commons_1.getLambdaFunctionConfig)(lambdaClient, this.functionName);
            }
            catch (err) {
                if (err instanceof Error) {
                    this.context.stderr.write(helpersRenderer.renderError(`Unable to get Lambda function configuration: ${err.message}`));
                }
                return 1;
            }
            config = (0, commons_1.maskConfig)(config);
            const summarizedConfig = (0, exports.summarizeConfig)(config);
            const summarizedConfigStr = util_1.default.inspect(summarizedConfig, false, undefined, true);
            this.context.stdout.write(`\n${summarizedConfigStr}\n`);
            this.context.stdout.write(chalk_1.default.italic(`(This is a summary of the configuration. The full configuration will be saved in "${FUNCTION_CONFIG_FILE_NAME}".)\n`));
            // Get project files
            this.context.stdout.write(chalk_1.default.bold('\nüìÅ Searching for project files in current directory...\n'));
            const projectFilePaths = yield (0, flare_1.getProjectFiles)(constants_2.LAMBDA_PROJECT_FILES);
            this.context.stdout.write((0, renderer_1.renderProjectFiles)(projectFilePaths));
            // Additional files
            this.context.stdout.write('\n');
            const additionalFilePaths = new Set();
            let confirmAdditionalFiles;
            try {
                confirmAdditionalFiles = yield (0, prompt_1.requestConfirmation)('Do you want to specify any additional files to flare?', false);
            }
            catch (err) {
                if (err instanceof Error) {
                    this.context.stderr.write(helpersRenderer.renderError(err.message));
                }
                return 1;
            }
            while (confirmAdditionalFiles) {
                this.context.stdout.write('\n');
                let filePath;
                try {
                    filePath = yield (0, prompt_1.requestFilePath)();
                }
                catch (err) {
                    if (err instanceof Error) {
                        this.context.stderr.write(helpersRenderer.renderError(err.message));
                    }
                    return 1;
                }
                if (filePath === '') {
                    this.context.stdout.write((0, renderer_1.renderAdditionalFiles)(additionalFilePaths));
                    break;
                }
                try {
                    filePath = (0, flare_1.validateFilePath)(filePath, projectFilePaths, additionalFilePaths);
                    additionalFilePaths.add(filePath);
                    const fileName = upath_1.default.basename(filePath);
                    this.context.stdout.write(`‚Ä¢ Added file '${fileName}'\n`);
                }
                catch (err) {
                    if (err instanceof Error) {
                        this.context.stderr.write(err.message);
                    }
                }
            }
            // Get tags
            this.context.stdout.write(chalk_1.default.bold('\nüè∑ Getting Resource Tags...\n'));
            let tags;
            try {
                tags = yield (0, exports.getTags)(lambdaClient, region, config.FunctionArn);
            }
            catch (err) {
                if (err instanceof Error) {
                    this.context.stderr.write(helpersRenderer.renderError(err.message));
                }
                return 1;
            }
            const tagsLength = Object.keys(tags).length;
            if (tagsLength === 0) {
                this.context.stdout.write(helpersRenderer.renderSoftWarning(`No resource tags were found.`));
            }
            else {
                this.context.stdout.write(`Found ${tagsLength} resource tag(s).\n`);
            }
            // Get CloudWatch logs
            let logs = new Map();
            if (this.withLogs) {
                this.context.stdout.write(chalk_1.default.bold('\nüåß Getting CloudWatch logs...\n'));
                try {
                    logs = yield (0, exports.getAllLogs)(region, this.functionName, startMillis, endMillis);
                }
                catch (err) {
                    if (err instanceof Error) {
                        this.context.stderr.write(helpersRenderer.renderError(err.message));
                    }
                    return 1;
                }
            }
            try {
                // CloudWatch messages
                if (this.withLogs) {
                    let message = chalk_1.default.bold('\n‚úÖ Found log streams:\n');
                    if (logs.size === 0) {
                        message = helpersRenderer.renderSoftWarning('No CloudWatch log streams were found. Logs will not be retrieved or sent.');
                    }
                    this.context.stdout.write(message);
                    for (const [logStreamName, logEvents] of logs) {
                        let warningMessage = '\n';
                        if (logEvents.length === 0) {
                            warningMessage = ` - ${helpersRenderer.renderSoftWarning('No log events found in this stream')}`;
                        }
                        this.context.stdout.write(`‚Ä¢ ${logStreamName}${warningMessage}`);
                    }
                }
                // Create folders
                const rootFolderPath = upath_1.default.join(process.cwd(), constants_1.FLARE_OUTPUT_DIRECTORY);
                const logsFolderPath = upath_1.default.join(rootFolderPath, constants_1.LOGS_DIRECTORY);
                const projectFilesFolderPath = upath_1.default.join(rootFolderPath, constants_1.PROJECT_FILES_DIRECTORY);
                const additionalFilesFolderPath = upath_1.default.join(rootFolderPath, constants_1.ADDITIONAL_FILES_DIRECTORY);
                this.context.stdout.write(chalk_1.default.bold(`\nüíæ Saving files to ${rootFolderPath}...\n`));
                if (fs.existsSync(rootFolderPath)) {
                    (0, fs_1.deleteFolder)(rootFolderPath);
                }
                const subFolders = [];
                if (logs.size > 0) {
                    subFolders.push(logsFolderPath);
                }
                if (projectFilePaths.size > 0) {
                    subFolders.push(projectFilesFolderPath);
                }
                if (additionalFilePaths.size > 0) {
                    subFolders.push(additionalFilesFolderPath);
                }
                (0, fs_1.createDirectories)(rootFolderPath, subFolders);
                // Write config file
                const configFilePath = upath_1.default.join(rootFolderPath, FUNCTION_CONFIG_FILE_NAME);
                (0, fs_1.writeFile)(configFilePath, JSON.stringify(config, undefined, 2));
                this.context.stdout.write(`‚Ä¢ Saved function config to ./${FUNCTION_CONFIG_FILE_NAME}\n`);
                // Write tags file
                if (tagsLength > 0) {
                    const tagsFilePath = upath_1.default.join(rootFolderPath, TAGS_FILE_NAME);
                    (0, fs_1.writeFile)(tagsFilePath, JSON.stringify(tags, undefined, 2));
                    this.context.stdout.write(`‚Ä¢ Saved tags to ./${TAGS_FILE_NAME}\n`);
                }
                // Write log files
                for (const [logStreamName, logEvents] of logs) {
                    if (logEvents.length === 0) {
                        continue;
                    }
                    const logFilePath = upath_1.default.join(logsFolderPath, `${logStreamName.split('/').join('-')}.csv`);
                    const data = (0, exports.convertToCSV)(logEvents);
                    (0, fs_1.writeFile)(logFilePath, data);
                    this.context.stdout.write(`‚Ä¢ Saved logs to ./${constants_1.LOGS_DIRECTORY}/${logStreamName}\n`);
                    // Sleep for 1 millisecond so creation times are different
                    // This allows the logs to be sorted by creation time by the support team
                    yield (0, exports.sleep)(1);
                }
                // Write project files
                for (const filePath of projectFilePaths) {
                    const fileName = upath_1.default.basename(filePath);
                    const newFilePath = upath_1.default.join(projectFilesFolderPath, fileName);
                    fs.copyFileSync(filePath, newFilePath);
                    this.context.stdout.write(`‚Ä¢ Copied ${fileName} to ./${constants_1.PROJECT_FILES_DIRECTORY}/${fileName}\n`);
                }
                // Write additional files
                const additionalFilesMap = (0, exports.getUniqueFileNames)(additionalFilePaths);
                for (const [originalFilePath, newFileName] of additionalFilesMap) {
                    const originalFileName = upath_1.default.basename(originalFilePath);
                    const newFilePath = upath_1.default.join(additionalFilesFolderPath, newFileName);
                    fs.copyFileSync(originalFilePath, newFilePath);
                    this.context.stdout.write(`‚Ä¢ Copied ${originalFileName} to ./${constants_1.ADDITIONAL_FILES_DIRECTORY}/${newFileName}\n`);
                }
                // Write insights file
                try {
                    const insightsFilePath = upath_1.default.join(rootFolderPath, constants_1.INSIGHTS_FILE_NAME);
                    (0, exports.generateInsightsFile)(insightsFilePath, this.isDryRun, config);
                    this.context.stdout.write(`‚Ä¢ Saved the insights file to ./${constants_1.INSIGHTS_FILE_NAME}\n`);
                }
                catch (err) {
                    const errorDetails = err instanceof Error ? err.message : '';
                    this.context.stdout.write(helpersRenderer.renderSoftWarning(`Unable to create INSIGHTS.md file. ${errorDetails}`));
                }
                // Exit if dry run
                const outputMsg = `\n‚ÑπÔ∏è Your output files are located at: ${rootFolderPath}\n\n`;
                if (this.isDryRun) {
                    this.context.stdout.write('\nüö´ The flare files were not sent because the command was executed in dry run mode.');
                    this.context.stdout.write(outputMsg);
                    return 0;
                }
                // Confirm before sending
                this.context.stdout.write('\n');
                const confirmSendFiles = yield (0, prompt_1.requestConfirmation)('Are you sure you want to send the flare file to Datadog Support?', false);
                if (!confirmSendFiles) {
                    this.context.stdout.write('\nüö´ The flare files were not sent based on your selection.');
                    this.context.stdout.write(outputMsg);
                    return 0;
                }
                // Zip folder
                const zipPath = upath_1.default.join(rootFolderPath, FLARE_ZIP_FILE_NAME);
                yield (0, fs_1.zipContents)(rootFolderPath, zipPath);
                // Send to Datadog
                this.context.stdout.write(chalk_1.default.bold('\nüöÄ Sending to Datadog Support...\n'));
                yield (0, flare_1.sendToDatadog)(zipPath, this.caseId, this.email, this.apiKey, rootFolderPath);
                this.context.stdout.write(chalk_1.default.bold('\n‚úÖ Successfully sent flare file to Datadog Support!\n'));
                // Delete contents
                (0, fs_1.deleteFolder)(rootFolderPath);
            }
            catch (err) {
                if (err instanceof Error) {
                    this.context.stderr.write(helpersRenderer.renderError(err.message));
                }
                return 1;
            }
            return 0;
        });
    }
}
exports.LambdaFlareCommand = LambdaFlareCommand;
LambdaFlareCommand.paths = [['lambda', 'flare']];
LambdaFlareCommand.usage = clipanion_1.Command.Usage({
    category: 'Serverless',
    description: 'Gather config, logs, tags, project files, and more from a Lambda function and sends them to Datadog support.',
});
/**
 * Summarizes the Lambda config as to not flood the terminal
 * @param config
 * @returns a summarized config
 */
const summarizeConfig = (config) => {
    const summarizedConfig = {};
    for (const key in config) {
        if (SUMMARIZED_FIELDS.has(key)) {
            summarizedConfig[key] = config[key];
        }
    }
    return summarizedConfig;
};
exports.summarizeConfig = summarizeConfig;
/**
 * Gets the LOG_STREAM_COUNT latest log stream names, sorted by last event time
 * @param cwlClient CloudWatch Logs client
 * @param logGroupName name of the log group
 * @param startMillis start time in milliseconds or undefined if no start time is specified
 * @param endMillis end time in milliseconds or undefined if no end time is specified
 * @returns an array of the last LOG_STREAM_COUNT log stream names or an empty array if no log streams are found
 * @throws Error if the log streams cannot be retrieved
 */
const getLogStreamNames = (cwlClient, logGroupName, startMillis, endMillis) => __awaiter(void 0, void 0, void 0, function* () {
    const config = {
        logGroupName,
        descending: true,
        orderBy: client_cloudwatch_logs_1.OrderBy.LastEventTime,
        limit: DEFAULT_LOG_STREAMS,
    };
    const rangeSpecified = startMillis !== undefined && endMillis !== undefined;
    if (rangeSpecified) {
        config.limit = MAX_LOG_STREAMS;
    }
    const command = new client_cloudwatch_logs_1.DescribeLogStreamsCommand(config);
    const response = yield cwlClient.send(command);
    const logStreams = response.logStreams;
    if (logStreams === undefined || logStreams.length === 0) {
        return [];
    }
    const output = [];
    for (const logStream of logStreams) {
        const logStreamName = logStream.logStreamName;
        if (!logStreamName) {
            continue;
        }
        if (rangeSpecified) {
            const firstEventTime = logStream.firstEventTimestamp;
            const lastEventTime = logStream.lastEventTimestamp;
            if (lastEventTime && lastEventTime < startMillis) {
                continue;
            }
            if (firstEventTime && firstEventTime > endMillis) {
                continue;
            }
        }
        output.push(logStreamName);
    }
    // Reverse array so the oldest log is created first, so Support Staff can sort by creation time
    return output.reverse();
});
exports.getLogStreamNames = getLogStreamNames;
/**
 * Gets the log events for a log stream
 * @param cwlClient
 * @param logGroupName
 * @param logStreamName
 * @param startMillis
 * @param endMillis
 * @returns the log events or an empty array if no log events are found
 * @throws Error if the log events cannot be retrieved
 */
const getLogEvents = (cwlClient, logGroupName, logStreamName, startMillis, endMillis) => __awaiter(void 0, void 0, void 0, function* () {
    const config = {
        logGroupName,
        logStreamName,
        limit: MAX_LOG_EVENTS_PER_STREAM,
    };
    if (startMillis !== undefined && endMillis !== undefined) {
        config.startTime = startMillis;
        config.endTime = endMillis;
    }
    const command = new client_cloudwatch_logs_1.GetLogEventsCommand(config);
    const response = yield cwlClient.send(command);
    const logEvents = response.events;
    if (logEvents === undefined) {
        return [];
    }
    return logEvents;
});
exports.getLogEvents = getLogEvents;
/**
 * Gets all CloudWatch logs for a function
 * @param region
 * @param functionName
 * @param startMillis start time in milliseconds or undefined if no end time is specified
 * @param endMillis end time in milliseconds or undefined if no end time is specified
 * @returns a map of log stream names to log events or an empty map if no logs are found
 */
const getAllLogs = (region, functionName, startMillis, endMillis) => __awaiter(void 0, void 0, void 0, function* () {
    const logs = new Map();
    const cwlClient = new client_cloudwatch_logs_1.CloudWatchLogsClient({ region, retryStrategy: constants_2.EXPONENTIAL_BACKOFF_RETRY_STRATEGY });
    if (functionName.startsWith('arn:aws')) {
        functionName = functionName.split(':')[6];
    }
    const logGroupName = `/aws/lambda/${functionName}`;
    let logStreamNames;
    try {
        logStreamNames = yield (0, exports.getLogStreamNames)(cwlClient, logGroupName, startMillis, endMillis);
    }
    catch (err) {
        const msg = err instanceof Error ? err.message : '';
        throw new Error(`Unable to get log streams: ${msg}`);
    }
    for (const logStreamName of logStreamNames) {
        let logEvents;
        try {
            logEvents = yield (0, exports.getLogEvents)(cwlClient, logGroupName, logStreamName, startMillis, endMillis);
        }
        catch (err) {
            const msg = err instanceof Error ? err.message : '';
            throw new Error(`Unable to get log events for stream ${logStreamName}: ${msg}`);
        }
        logs.set(logStreamName, logEvents);
    }
    return logs;
});
exports.getAllLogs = getAllLogs;
/**
 * Gets the tags for a function
 * @param lambdaClient
 * @param region
 * @param arn
 * @returns the tags or an empty object if no tags are found
 * @throws Error if the tags cannot be retrieved
 */
const getTags = (lambdaClient, region, arn) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    if (!arn.startsWith('arn:aws')) {
        throw Error(`Invalid function ARN: ${arn}`);
    }
    const command = new client_lambda_1.ListTagsCommand({
        Resource: arn,
    });
    try {
        const response = yield lambdaClient.send(command);
        return (_a = response.Tags) !== null && _a !== void 0 ? _a : {};
    }
    catch (err) {
        let message = '';
        if (err instanceof Error) {
            message = err.message;
        }
        throw Error(`Unable to get resource tags: ${message}`);
    }
});
exports.getTags = getTags;
/**
 * Generate unique file names
 * If the original file name is unique, keep it as is
 * Otherwise, replace separators in the file path with dashes
 * @param filePaths the list of file paths
 * @returns a mapping of file paths to new file names
 */
const getUniqueFileNames = (filePaths) => {
    // Count occurrences of each filename
    const fileNameCount = {};
    filePaths.forEach((filePath) => {
        const fileName = upath_1.default.basename(filePath);
        const count = fileNameCount[fileName] || 0;
        fileNameCount[fileName] = count + 1;
    });
    // Create new filenames
    const filePathsToNewFileNames = new Map();
    filePaths.forEach((filePath) => {
        const fileName = upath_1.default.basename(filePath);
        if (fileNameCount[fileName] > 1) {
            // Trim leading and trailing '/'s and '\'s
            const trimRegex = /^\/+|\/+$/g;
            const filePathTrimmed = filePath.replace(trimRegex, '');
            // Replace '/'s and '\'s with '-'s
            const newFileName = filePathTrimmed.split('/').join('-');
            filePathsToNewFileNames.set(filePath, newFileName);
        }
        else {
            filePathsToNewFileNames.set(filePath, fileName);
        }
    });
    return filePathsToNewFileNames;
};
exports.getUniqueFileNames = getUniqueFileNames;
/**
 * Convert the log events to a CSV string
 * @param logEvents array of log events
 * @returns the CSV string
 */
const convertToCSV = (logEvents) => {
    var _a, _b;
    const rows = [['timestamp', 'datetime', 'message']];
    for (const logEvent of logEvents) {
        const timestamp = `"${(_a = logEvent.timestamp) !== null && _a !== void 0 ? _a : ''}"`;
        let datetime = '';
        if (logEvent.timestamp) {
            const date = new Date(logEvent.timestamp);
            datetime = date.toISOString().replace('T', ' ').replace('Z', '');
        }
        const message = `"${(_b = logEvent.message) !== null && _b !== void 0 ? _b : ''}"`;
        rows.push([timestamp, datetime, message]);
    }
    return rows.join('\n');
};
exports.convertToCSV = convertToCSV;
/**
 * @param ms number of milliseconds to sleep
 */
const sleep = (ms) => __awaiter(void 0, void 0, void 0, function* () {
    yield new Promise((resolve) => setTimeout(resolve, ms));
});
exports.sleep = sleep;
/**
 * Get the framework used based on the files in the directory
 * @returns the framework used or undefined if no framework is found
 */
const getFramework = () => {
    const frameworks = new Set();
    const files = fs.readdirSync(process.cwd());
    files.forEach((file) => {
        if (constants_2.FRAMEWORK_FILES_MAPPING.has(file)) {
            frameworks.add(constants_2.FRAMEWORK_FILES_MAPPING.get(file));
        }
    });
    if (frameworks.size > 0) {
        return Array.from(frameworks).join(', ');
    }
    return constants_2.DeploymentFrameworks.Unknown;
};
exports.getFramework = getFramework;
/**
 * Generate the insights file
 * @param insightsFilePath path to the insights file
 * @param isDryRun whether or not this is a dry run
 * @param config Lambda function configuration
 */
const generateInsightsFile = (insightsFilePath, isDryRun, config) => {
    var _a, _b, _c, _d, _e;
    const lines = [];
    // Header
    lines.push('# Flare Insights');
    lines.push('\n_Autogenerated file from `lambda flare`_  ');
    if (isDryRun) {
        lines.push('_This command was run in dry mode._');
    }
    // AWS Lambda Configuration
    lines.push('\n## AWS Lambda Configuration');
    lines.push(`**Function Name**: \`${config.FunctionName}\`  `);
    lines.push(`**Function ARN**: \`${config.FunctionArn}\`  `);
    lines.push(`**Runtime**: \`${config.Runtime}\`  `);
    lines.push(`**Handler**: \`${config.Handler}\`  `);
    lines.push(`**Timeout**: \`${config.Timeout}\`  `);
    lines.push(`**Memory Size**: \`${config.MemorySize}\`  `);
    const architectures = (_a = config.Architectures) !== null && _a !== void 0 ? _a : ['Unknown'];
    lines.push(`**Architecture**: \`${architectures.join(', ')}\`  `);
    lines.push('**Environment Variables**:');
    const envVars = Object.entries((_c = (_b = config.Environment) === null || _b === void 0 ? void 0 : _b.Variables) !== null && _c !== void 0 ? _c : {});
    if (envVars.length === 0) {
        lines.push('- No environment variables found.');
    }
    for (const [key, value] of envVars) {
        lines.push(`- \`${key}\`: \`${value}\``);
    }
    lines.push('\n**Layers**:');
    const layers = (_d = config.Layers) !== null && _d !== void 0 ? _d : [];
    if (layers.length === 0) {
        lines.push(' - No layers found.');
    }
    let codeSize = (_e = config.CodeSize) !== null && _e !== void 0 ? _e : 0;
    layers.forEach((layer) => {
        var _a, _b;
        const nameAndVersion = (0, commons_1.getLayerNameWithVersion)((_a = layer.Arn) !== null && _a !== void 0 ? _a : '');
        if (nameAndVersion) {
            lines.push(`- \`${nameAndVersion}\``);
        }
        codeSize += (_b = layer.CodeSize) !== null && _b !== void 0 ? _b : 0;
    });
    lines.push(`\n**Package Size**: \`${(0, utils_1.formatBytes)(codeSize)}\``);
    // CLI Insights
    lines.push('\n ## CLI');
    lines.push(`**Run Location**: \`${process.cwd()}\`  `);
    lines.push(`**CLI Version**: \`${version_1.version}\`  `);
    const timeString = new Date().toISOString().replace('T', ' ').replace('Z', '') + ' UTC';
    lines.push(`**Timestamp**: \`${timeString}\`  `);
    lines.push(`**Framework**: \`${(0, exports.getFramework)()}\``);
    (0, fs_1.writeFile)(insightsFilePath, lines.join('\n'));
};
exports.generateInsightsFile = generateInsightsFile;
//# sourceMappingURL=flare.js.map