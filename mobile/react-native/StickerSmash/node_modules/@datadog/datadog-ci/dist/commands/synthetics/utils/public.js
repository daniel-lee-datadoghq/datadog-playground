"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportCiError = exports.pluralize = exports.getDatadogHost = exports.toExitCode = exports.getExitReason = exports.reportExitLogs = exports.renderResults = exports.sortResultsByOutcome = exports.getResultUrl = exports.getBatchUrl = exports.getAppBaseURL = exports.retry = exports.fetchTest = exports.isDeviceIdSet = exports.getReporter = exports.createInitialSummary = exports.isResultSkippedBySelectiveRerun = exports.getOrgSettings = exports.normalizePublicId = exports.getFilePathRelativeToRepo = exports.getSuites = exports.getResultOutcome = exports.PASSED_RESULT_OUTCOMES = exports.isTestSupportedByTunnel = exports.getStrictestExecutionRule = exports.getExecutionRule = exports.setCiTriggerApp = exports.getTestOverridesCount = exports.makeTestPayload = exports.ciTriggerApp = exports.readableOperation = exports.PUBLIC_ID_REGEX = void 0;
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const process_1 = __importDefault(require("process"));
const util_1 = require("util");
const chalk_1 = __importDefault(require("chalk"));
const upath_1 = __importDefault(require("upath"));
const app_1 = require("../../../helpers/app");
const glob_1 = require("../../../helpers/glob");
const api_1 = require("../api");
const errors_1 = require("../errors");
const interfaces_1 = require("../interfaces");
const internal_1 = require("./internal");
exports.PUBLIC_ID_REGEX = /\b[a-z0-9]{3}-[a-z0-9]{3}-[a-z0-9]{3}\b/;
exports.readableOperation = {
    [interfaces_1.Operator.contains]: 'should contain',
    [interfaces_1.Operator.doesNotContain]: 'should not contain',
    [interfaces_1.Operator.is]: 'should be',
    [interfaces_1.Operator.isNot]: 'should not be',
    [interfaces_1.Operator.lessThan]: 'should be less than',
    [interfaces_1.Operator.matches]: 'should match',
    [interfaces_1.Operator.doesNotMatch]: 'should not match',
    [interfaces_1.Operator.isInLessThan]: 'will expire in less than',
    [interfaces_1.Operator.isInMoreThan]: 'will expire in more than',
    [interfaces_1.Operator.lessThanOrEqual]: 'should be less than or equal to',
    [interfaces_1.Operator.moreThan]: 'should be more than',
    [interfaces_1.Operator.moreThanOrEqual]: 'should be less than or equal to',
    [interfaces_1.Operator.validatesJSONPath]: 'assert on JSONPath extracted value',
    [interfaces_1.Operator.validatesXPath]: 'assert on XPath extracted value',
};
exports.ciTriggerApp = process_1.default.env.DATADOG_SYNTHETICS_CI_TRIGGER_APP || 'npm_package';
const makeTestPayload = (test, triggerConfig, publicId) => {
    if ((0, internal_1.isLocalTriggerConfig)(triggerConfig)) {
        return Object.assign(Object.assign({}, (0, internal_1.getBasePayload)(test, triggerConfig.testOverrides)), { local_test_definition: triggerConfig.localTestDefinition });
    }
    return Object.assign(Object.assign({}, (0, internal_1.getBasePayload)(test, triggerConfig.testOverrides)), { public_id: publicId });
};
exports.makeTestPayload = makeTestPayload;
const getTestOverridesCount = (testOverrides) => {
    return Object.keys(testOverrides).reduce((count) => count + 1, 0);
};
exports.getTestOverridesCount = getTestOverridesCount;
const setCiTriggerApp = (source) => {
    exports.ciTriggerApp = source;
};
exports.setCiTriggerApp = setCiTriggerApp;
const getExecutionRule = (test, configOverride) => {
    var _a, _b, _c, _d;
    if (configOverride && configOverride.executionRule) {
        return (0, exports.getStrictestExecutionRule)(configOverride.executionRule, (_b = (_a = test === null || test === void 0 ? void 0 : test.options) === null || _a === void 0 ? void 0 : _a.ci) === null || _b === void 0 ? void 0 : _b.executionRule);
    }
    return ((_d = (_c = test === null || test === void 0 ? void 0 : test.options) === null || _c === void 0 ? void 0 : _c.ci) === null || _d === void 0 ? void 0 : _d.executionRule) || interfaces_1.ExecutionRule.BLOCKING;
};
exports.getExecutionRule = getExecutionRule;
const getStrictestExecutionRule = (configRule, testRule) => {
    if (configRule === interfaces_1.ExecutionRule.SKIPPED || testRule === interfaces_1.ExecutionRule.SKIPPED) {
        return interfaces_1.ExecutionRule.SKIPPED;
    }
    if (configRule === interfaces_1.ExecutionRule.NON_BLOCKING || testRule === interfaces_1.ExecutionRule.NON_BLOCKING) {
        return interfaces_1.ExecutionRule.NON_BLOCKING;
    }
    if (configRule === interfaces_1.ExecutionRule.BLOCKING || testRule === interfaces_1.ExecutionRule.BLOCKING) {
        return interfaces_1.ExecutionRule.BLOCKING;
    }
    return interfaces_1.ExecutionRule.BLOCKING;
};
exports.getStrictestExecutionRule = getStrictestExecutionRule;
const isTestSupportedByTunnel = (test) => {
    var _a;
    // Test public IDs are required by the tunnel.
    if (!test.public_id) {
        return false;
    }
    return (test.type === 'browser' ||
        test.subtype === 'http' ||
        (test.subtype === 'multi' && ((_a = test.config.steps) === null || _a === void 0 ? void 0 : _a.every((step) => step.subtype === 'http'))));
};
exports.isTestSupportedByTunnel = isTestSupportedByTunnel;
exports.PASSED_RESULT_OUTCOMES = [
    "passed" /* ResultOutcome.Passed */,
    "passed-non-blocking" /* ResultOutcome.PassedNonBlocking */,
    "previously-passed" /* ResultOutcome.PreviouslyPassed */,
];
const getResultOutcome = (result) => {
    if ((0, exports.isResultSkippedBySelectiveRerun)(result)) {
        return "previously-passed" /* ResultOutcome.PreviouslyPassed */;
    }
    const executionRule = result.executionRule;
    if (result.passed) {
        if (executionRule === interfaces_1.ExecutionRule.NON_BLOCKING) {
            return "passed-non-blocking" /* ResultOutcome.PassedNonBlocking */;
        }
        return "passed" /* ResultOutcome.Passed */;
    }
    if (executionRule === interfaces_1.ExecutionRule.NON_BLOCKING) {
        return "failed-non-blocking" /* ResultOutcome.FailedNonBlocking */;
    }
    return "failed" /* ResultOutcome.Failed */;
};
exports.getResultOutcome = getResultOutcome;
const getSuites = (pattern, reporter) => __awaiter(void 0, void 0, void 0, function* () {
    reporter.log(`Finding files matching ${upath_1.default.resolve(process_1.default.cwd(), pattern)}\n`);
    const files = (0, glob_1.globSync)(pattern);
    if (files.length) {
        reporter.log(`\nGot test files:\n${files.map((file) => `  - ${file}\n`).join('')}\n`);
    }
    else {
        reporter.log('\nNo test files found.\n\n');
    }
    return Promise.all(files.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const content = yield (0, util_1.promisify)(fs.readFile)(file, 'utf8');
            const suiteName = yield (0, exports.getFilePathRelativeToRepo)(file);
            return { name: suiteName, content: JSON.parse(content) };
        }
        catch (e) {
            throw new Error(`Unable to read and parse the test file ${file}`);
        }
    })));
});
exports.getSuites = getSuites;
const getFilePathRelativeToRepo = (filePath) => __awaiter(void 0, void 0, void 0, function* () {
    const parentDirectory = upath_1.default.dirname(filePath);
    const filename = upath_1.default.basename(filePath);
    let relativeDirectory;
    try {
        const { stdout } = yield (0, util_1.promisify)(child_process_1.exec)('git rev-parse --show-toplevel');
        const repoTopLevel = stdout.trim();
        relativeDirectory = upath_1.default.relative(repoTopLevel, parentDirectory);
    }
    catch (_a) {
        // We aren't in a git repository: fall back to the given path, relative to the process working directory.
        relativeDirectory = upath_1.default.relative(process_1.default.cwd(), parentDirectory);
    }
    return upath_1.default.join(relativeDirectory, filename);
});
exports.getFilePathRelativeToRepo = getFilePathRelativeToRepo;
const normalizePublicId = (id) => { var _a; return id === internal_1.LOCAL_TEST_DEFINITION_PUBLIC_ID_PLACEHOLDER ? id : (_a = id.match(exports.PUBLIC_ID_REGEX)) === null || _a === void 0 ? void 0 : _a[0]; };
exports.normalizePublicId = normalizePublicId;
const getOrgSettings = (reporter, config) => __awaiter(void 0, void 0, void 0, function* () {
    const api = (0, api_1.getApiHelper)(config);
    try {
        return yield api.getSyntheticsOrgSettings();
    }
    catch (e) {
        reporter.error(`Failed to get settings: ${(0, api_1.formatBackendErrors)(e, 'synthetics_default_settings_read')}`);
    }
});
exports.getOrgSettings = getOrgSettings;
const isResultSkippedBySelectiveRerun = (result) => {
    var _a;
    return ((_a = result.selectiveRerun) === null || _a === void 0 ? void 0 : _a.decision) === 'skip';
};
exports.isResultSkippedBySelectiveRerun = isResultSkippedBySelectiveRerun;
const createInitialSummary = () => ({
    criticalErrors: 0,
    expected: 0,
    failed: 0,
    failedNonBlocking: 0,
    passed: 0,
    previouslyPassed: 0,
    skipped: 0,
    testsNotFound: new Set(),
    testsNotAuthorized: new Set(),
    timedOut: 0,
});
exports.createInitialSummary = createInitialSummary;
const getReporter = (reporters) => ({
    error: (error) => {
        for (const reporter of reporters) {
            if (typeof reporter.error === 'function') {
                reporter.error(error);
            }
        }
    },
    initErrors: (errors) => {
        for (const reporter of reporters) {
            if (typeof reporter.initErrors === 'function') {
                reporter.initErrors(errors);
            }
        }
    },
    log: (log) => {
        for (const reporter of reporters) {
            if (typeof reporter.log === 'function') {
                reporter.log(log);
            }
        }
    },
    reportStart: (timings) => {
        for (const reporter of reporters) {
            if (typeof reporter.reportStart === 'function') {
                reporter.reportStart(timings);
            }
        }
    },
    resultEnd: (result, baseUrl, batchId) => {
        for (const reporter of reporters) {
            if (typeof reporter.resultEnd === 'function') {
                reporter.resultEnd(result, baseUrl, batchId);
            }
        }
    },
    resultReceived: (result) => {
        for (const reporter of reporters) {
            if (typeof reporter.resultReceived === 'function') {
                reporter.resultReceived(result);
            }
        }
    },
    runEnd: (summary, baseUrl, orgSettings) => {
        for (const reporter of reporters) {
            if (typeof reporter.runEnd === 'function') {
                reporter.runEnd(summary, baseUrl, orgSettings);
            }
        }
    },
    testTrigger: (test, testId, executionRule, testOverrides) => {
        for (const reporter of reporters) {
            if (typeof reporter.testTrigger === 'function') {
                reporter.testTrigger(test, testId, executionRule, testOverrides);
            }
        }
    },
    testWait: (test) => {
        for (const reporter of reporters) {
            if (typeof reporter.testWait === 'function') {
                reporter.testWait(test);
            }
        }
    },
    testsWait: (tests, baseUrl, batchId, skippedCount) => {
        for (const reporter of reporters) {
            if (typeof reporter.testsWait === 'function') {
                reporter.testsWait(tests, baseUrl, batchId, skippedCount);
            }
        }
    },
});
exports.getReporter = getReporter;
const isDeviceIdSet = (result) => 'device' in result && result.device !== undefined;
exports.isDeviceIdSet = isDeviceIdSet;
const fetchTest = (publicId, config) => __awaiter(void 0, void 0, void 0, function* () {
    const api = (0, api_1.getApiHelper)(config);
    return api.getTest(publicId);
});
exports.fetchTest = fetchTest;
const retry = (func, shouldRetryAfterWait) => __awaiter(void 0, void 0, void 0, function* () {
    const trier = (retries = 0) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            return yield func();
        }
        catch (e) {
            const waiter = shouldRetryAfterWait(retries, e);
            if (waiter) {
                yield (0, internal_1.wait)(waiter);
                return trier(retries + 1);
            }
            throw e;
        }
    });
    return trier();
});
exports.retry = retry;
const getAppBaseURL = ({ datadogSite, subdomain }) => {
    return (0, app_1.getCommonAppBaseURL)(datadogSite, subdomain);
};
exports.getAppBaseURL = getAppBaseURL;
const getBatchUrl = (baseUrl, batchId) => `${baseUrl}synthetics/explorer/ci?batchResultId=${batchId}`;
exports.getBatchUrl = getBatchUrl;
const getResultUrl = (baseUrl, test, resultId, batchId) => {
    const ciQueryParam = `batch_id=${batchId}&from_ci=true`;
    const testDetailUrl = `${baseUrl}synthetics/details/${test.public_id}`;
    if (test.type === 'browser') {
        return `${testDetailUrl}/result/${resultId}?${ciQueryParam}`;
    }
    return `${testDetailUrl}?resultId=${resultId}&${ciQueryParam}`;
};
exports.getResultUrl = getResultUrl;
/**
 * Sort results with the following rules:
 * - Passed results come first
 * - Then non-blocking failed results
 * - And finally failed results
 */
const sortResultsByOutcome = () => {
    const outcomeWeight = {
        ["previously-passed" /* ResultOutcome.PreviouslyPassed */]: 1,
        ["passed-non-blocking" /* ResultOutcome.PassedNonBlocking */]: 2,
        ["passed" /* ResultOutcome.Passed */]: 3,
        ["failed-non-blocking" /* ResultOutcome.FailedNonBlocking */]: 4,
        ["failed" /* ResultOutcome.Failed */]: 5,
    };
    return (r1, r2) => outcomeWeight[(0, exports.getResultOutcome)(r1)] - outcomeWeight[(0, exports.getResultOutcome)(r2)];
};
exports.sortResultsByOutcome = sortResultsByOutcome;
const renderResults = ({ config, orgSettings, reporter, results, startTime, summary, }) => {
    reporter.reportStart({ startTime });
    if (!config.failOnTimeout) {
        if (!summary.timedOut) {
            summary.timedOut = 0;
        }
    }
    if (!config.failOnCriticalErrors) {
        if (!summary.criticalErrors) {
            summary.criticalErrors = 0;
        }
    }
    for (const result of results) {
        if (!config.failOnTimeout && result.timedOut) {
            summary.timedOut++;
        }
        if ((0, internal_1.hasDefinedResult)(result) && result.result.unhealthy && !config.failOnCriticalErrors) {
            summary.criticalErrors++;
        }
        const resultOutcome = (0, exports.getResultOutcome)(result);
        if (result.executionRule !== interfaces_1.ExecutionRule.SKIPPED || resultOutcome === "previously-passed" /* ResultOutcome.PreviouslyPassed */) {
            summary.expected++;
        }
        if (["passed" /* ResultOutcome.Passed */, "passed-non-blocking" /* ResultOutcome.PassedNonBlocking */].includes(resultOutcome)) {
            summary.passed++;
        }
        else if (resultOutcome === "previously-passed" /* ResultOutcome.PreviouslyPassed */) {
            summary.passed++;
            summary.previouslyPassed++;
        }
        else if (resultOutcome === "failed-non-blocking" /* ResultOutcome.FailedNonBlocking */) {
            summary.failedNonBlocking++;
        }
        else {
            summary.failed++;
        }
    }
    reporter.runEnd(summary, (0, exports.getAppBaseURL)(config), orgSettings);
};
exports.renderResults = renderResults;
const reportExitLogs = (reporter, config, { results, error }) => {
    if (!config.failOnTimeout && (results === null || results === void 0 ? void 0 : results.some((result) => result.timedOut))) {
        reporter.error(chalk_1.default.yellow('Because `failOnTimeout` is disabled, the command will succeed. ' +
            'Use `failOnTimeout: true` to make it fail instead.\n'));
    }
    if (!config.failOnCriticalErrors && error instanceof errors_1.CriticalError) {
        reporter.error(chalk_1.default.yellow('Because `failOnCriticalErrors` is not set or disabled, the command will succeed. ' +
            'Use `failOnCriticalErrors: true` to make it fail instead.\n'));
    }
    if (error instanceof errors_1.CiError) {
        (0, exports.reportCiError)(error, reporter);
    }
};
exports.reportExitLogs = reportExitLogs;
const getExitReason = (config, { results, error }) => {
    if (results === null || results === void 0 ? void 0 : results.some((result) => (0, exports.getResultOutcome)(result) === "failed" /* ResultOutcome.Failed */)) {
        return 'failing-tests';
    }
    if (error instanceof errors_1.CiError) {
        // Make the CI fail if something outside was changed, leading to missing tests. For example:
        // - a search query starts returning no results because somebody changed some tags
        // - an explicitly listed test was deleted
        // - some tests can't be read or written to because of permissions
        if (config.failOnMissingTests && ['NO_TESTS_TO_RUN', 'MISSING_TESTS', 'UNAUTHORIZED_TESTS'].includes(error.code)) {
            return 'missing-tests';
        }
        if (error instanceof errors_1.CriticalError) {
            if (config.failOnCriticalErrors) {
                return 'critical-error';
            }
        }
    }
    return 'passed';
};
exports.getExitReason = getExitReason;
const toExitCode = (reason) => {
    return reason === 'passed' ? 0 : 1;
};
exports.toExitCode = toExitCode;
const getDatadogHost = (hostConfig) => {
    const { useIntake, apiVersion, config } = hostConfig;
    const apiPath = (() => {
        switch (apiVersion) {
            case 'v1':
                return 'api/v1';
            case 'v2':
                return 'api/v2';
            case 'unstable':
                return 'api/unstable';
            default:
                return 'api/unstable';
        }
    })();
    let host = `https://api.${config.datadogSite}`;
    const hostOverride = process_1.default.env.DD_API_HOST_OVERRIDE;
    if (hostOverride) {
        host = hostOverride;
    }
    else if (useIntake && (config.datadogSite === 'datadoghq.com' || config.datadogSite === 'datad0g.com')) {
        host = `https://intake.synthetics.${config.datadogSite}`;
    }
    return `${host}/${apiPath}`;
};
exports.getDatadogHost = getDatadogHost;
const pluralize = (word, count) => (count === 1 ? word : `${word}s`);
exports.pluralize = pluralize;
const reportCiError = (error, reporter) => {
    switch (error.code) {
        case 'NO_TESTS_TO_RUN':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: No tests to run ')}\n${error.message}\n\n`);
            break;
        case 'MISSING_TESTS':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: some tests are missing ')}\n${error.message}\n\n`);
            break;
        case 'UNAUTHORIZED_TESTS':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: missing read or write access to some tests ')}\n${error.message}\n\n`);
            break;
        // Critical command errors
        case 'AUTHORIZATION_ERROR':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: authorization error ')}\n${error.message}\n\n`);
            reporter.log('Credentials refused, make sure `apiKey`, `appKey` and `datadogSite` are correct.\n');
            break;
        case 'INVALID_CONFIG':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: invalid config ')}\n${error.message}\n\n`);
            break;
        case 'MISSING_APP_KEY':
            reporter.error(`Missing ${chalk_1.default.red.bold('DATADOG_APP_KEY')} or ${chalk_1.default.red.bold('DD_APP_KEY')} in your environment.\n`);
            break;
        case 'MISSING_API_KEY':
            reporter.error(`Missing ${chalk_1.default.red.bold('DATADOG_API_KEY')} or ${chalk_1.default.red.bold('DD_API_KEY')} in your environment.\n`);
            break;
        case 'POLL_RESULTS_FAILED':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to poll test results ')}\n${error.message}\n\n`);
            break;
        case 'BATCH_TIMEOUT_RUNAWAY':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: batch timeout runaway ')}\n${error.message}\n\n`);
            break;
        case 'TUNNEL_START_FAILED':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to start tunnel ')}\n${error.message}\n\n`);
            break;
        case 'TOO_MANY_TESTS_TO_TRIGGER':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: too many tests to trigger ')}\n${error.message}\n\n`);
            break;
        case 'TRIGGER_TESTS_FAILED':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to trigger tests ')}\n${error.message}\n\n`);
            break;
        case 'UNAVAILABLE_TEST_CONFIG':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to obtain test configurations with search query ')}\n${error.message}\n\n`);
            break;
        case 'UNAVAILABLE_TUNNEL_CONFIG':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to get tunnel configuration ')}\n${error.message}\n\n`);
            break;
        case 'LTD_MULTILOCATORS_UPDATE_FAILED':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to update multilocators in local test definition')}\n${error.message}\n\n`);
            break;
        default:
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR ')}\n${error.message}\n\n`);
    }
};
exports.reportCiError = reportCiError;
//# sourceMappingURL=public.js.map