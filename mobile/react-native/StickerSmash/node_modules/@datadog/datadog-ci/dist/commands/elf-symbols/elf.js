"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBuildIdWithArch = exports.getOutputFilenameFromBuildId = exports.copyElfDebugInfo = exports.computeFileHash = exports.getElfFileMetadata = exports.getSectionInfo = exports.hasNonEmptySection = exports.isSupportedElfType = exports.isSupportedArch = exports.getBuildIds = exports.readElfProgramHeaderTable = exports.readElfProgramHeader = exports.readElfSectionHeaderTable = exports.readElfSectionHeader = exports.readElfHeader = void 0;
const crypto_1 = require("crypto");
const fs_1 = __importDefault(require("fs"));
const filereader_1 = require("../../helpers/filereader");
const utils_1 = require("../../helpers/utils");
const elf_constants_1 = require("./elf-constants");
const SUPPORTED_ARCHS = [
    elf_constants_1.MACHINE_TYPES_DESCRIPTION[elf_constants_1.MachineType.EM_AARCH64],
    elf_constants_1.MACHINE_TYPES_DESCRIPTION[elf_constants_1.MachineType.EM_X86_64],
    elf_constants_1.MACHINE_TYPES_DESCRIPTION[elf_constants_1.MachineType.EM_ARM],
];
const SUPPORTED_ELF_TYPES = [elf_constants_1.ELF_TYPES_DESCRIPTION[elf_constants_1.ElfFileType.ET_DYN], elf_constants_1.ELF_TYPES_DESCRIPTION[elf_constants_1.ElfFileType.ET_EXEC]];
const getBFDTargetForArch = (arch, littleEndian, elfClass) => {
    if (arch === elf_constants_1.MACHINE_TYPES_DESCRIPTION[elf_constants_1.MachineType.EM_X86_64]) {
        return `elf${elfClass}-x86-64`;
    }
    return `elf${elfClass}-${littleEndian ? 'little' : 'big'}${arch}`;
};
const getGenericBFDTargetForArch = (_arch, littleEndian, elfClass) => {
    return `elf${elfClass}-${littleEndian ? 'little' : 'big'}`;
};
// Read the first 24 bytes of the file to get the ELF header (up to and including e_version field)
const getElfHeaderStart = (filename) => __awaiter(void 0, void 0, void 0, function* () {
    const fd = yield fs_1.default.promises.open(filename, 'r');
    const buffer = Buffer.alloc(24);
    yield fd.read(buffer, 0, 24, 0);
    yield fd.close();
    return buffer;
});
const readElfHeader = (reader) => __awaiter(void 0, void 0, void 0, function* () {
    const result = { isElf: false };
    try {
        const IDENT_SIZE = 16;
        const identBuffer = yield reader.read(IDENT_SIZE);
        // check magic number:  0x7F followed by 'ELF' in ASCII
        if (identBuffer.toString('hex', 0, 4) !== '7f454c46') {
            return result;
        }
        result.isElf = true;
        const elfClass = identBuffer.readUint8(4);
        const data = identBuffer.readUint8(5);
        const elfVersion = identBuffer.readUint8(6);
        const abi = identBuffer.readUint8(7);
        const abiVersion = identBuffer.readUint8(8);
        if (elfClass !== elf_constants_1.ElfClass.ELFCLASS32 && elfClass !== elf_constants_1.ElfClass.ELFCLASS64) {
            throw new Error(`Not a valid ELF file. Class '${elfClass}' is invalid.`);
        }
        if (data < 1 || data > 2) {
            throw new Error(`Not a valid ELF file. Endianness '${data}' is invalid`);
        }
        const littleEndian = data === 1;
        if (elfVersion !== 1) {
            throw new Error(`Not a valid ELF file. Version '${elfVersion}' is invalid`);
        }
        const headerSize = elfClass === 1 ? 52 : 64;
        const headerSizeLeft = headerSize - IDENT_SIZE;
        const headerBuffer = yield reader.read(headerSizeLeft, IDENT_SIZE);
        const { readUInt32, readUInt16, readBigUInt32Or64 } = (0, filereader_1.createReadFunctions)(headerBuffer, littleEndian, elfClass === elf_constants_1.ElfClass.ELFCLASS32);
        const type = readUInt16();
        const machine = readUInt16();
        const version = readUInt32();
        if (version !== 1) {
            throw new Error(`Not a valid ELF file. Version '${version}' is invalid`);
        }
        const entry = readBigUInt32Or64();
        const phoff = readBigUInt32Or64();
        const shoff = readBigUInt32Or64();
        const flags = readUInt32();
        const ehsize = readUInt16();
        const phentsize = readUInt16();
        const phnum = readUInt16();
        const shentsize = readUInt16();
        const shnum = readUInt16();
        const shstrndx = readUInt16();
        if ((elfClass === 1 && ehsize !== 0x34) || (elfClass === 2 && ehsize !== 0x40)) {
            throw Error(`Invalid ELF file. Unexpected header size '${ehsize}'`);
        }
        result.elfHeader = {
            // e_indent content
            elfClass,
            data,
            elfVersion,
            abi,
            abiVersion,
            littleEndian,
            e_type: type,
            e_machine: machine,
            e_version: version,
            e_entry: entry,
            e_phoff: phoff,
            e_shoff: shoff,
            e_flags: flags,
            e_ehsize: ehsize,
            e_phentsize: phentsize,
            e_phnum: phnum,
            e_shentsize: shentsize,
            e_shnum: shnum,
            e_shstrndx: shstrndx,
        };
    }
    catch (error) {
        result.error = error;
    }
    return result;
});
exports.readElfHeader = readElfHeader;
const readElfSectionHeader = (reader, elfHeader, index) => __awaiter(void 0, void 0, void 0, function* () {
    const buf = yield reader.read(elfHeader.e_shentsize, Number(elfHeader.e_shoff) + index * elfHeader.e_shentsize);
    const { readUInt32, readBigUInt32Or64 } = (0, filereader_1.createReadFunctions)(buf, elfHeader.littleEndian, elfHeader.elfClass === elf_constants_1.ElfClass.ELFCLASS32);
    return {
        name: '',
        sh_name: readUInt32(),
        sh_type: readUInt32(),
        sh_flags: readBigUInt32Or64(),
        sh_addr: readBigUInt32Or64(),
        sh_offset: readBigUInt32Or64(),
        sh_size: readBigUInt32Or64(),
        sh_link: readUInt32(),
        sh_info: readUInt32(),
        sh_addralign: readBigUInt32Or64(),
        sh_entsize: readBigUInt32Or64(),
    };
});
exports.readElfSectionHeader = readElfSectionHeader;
const readElfSectionHeaderTable = (reader, elfHeader) => __awaiter(void 0, void 0, void 0, function* () {
    if (elfHeader.e_shnum === 0) {
        return [];
    }
    const sectionHeaders = new Array(elfHeader.e_shnum);
    for (let i = 0; i < elfHeader.e_shnum; i++) {
        sectionHeaders[i] = yield (0, exports.readElfSectionHeader)(reader, elfHeader, i);
    }
    // add section names
    if (elfHeader.e_shstrndx < sectionHeaders.length &&
        sectionHeaders[elfHeader.e_shstrndx].sh_type === elf_constants_1.SectionHeaderType.SHT_STRTAB) {
        const shstrtab = sectionHeaders[elfHeader.e_shstrndx];
        const buf = yield reader.read(Number(shstrtab.sh_size), Number(shstrtab.sh_offset));
        for (const sectionHeader of sectionHeaders) {
            const nameOffset = sectionHeader.sh_name;
            if (nameOffset < buf.length) {
                const nullByteOffset = buf.indexOf(0, nameOffset);
                sectionHeader.name = buf.toString('ascii', nameOffset, nullByteOffset);
            }
        }
    }
    return sectionHeaders;
});
exports.readElfSectionHeaderTable = readElfSectionHeaderTable;
const readElfProgramHeader = (reader, elfHeader, index) => __awaiter(void 0, void 0, void 0, function* () {
    const buf = yield reader.read(elfHeader.e_phentsize, Number(elfHeader.e_phoff) + index * elfHeader.e_phentsize);
    const { readUInt32, readBigUInt32Or64 } = (0, filereader_1.createReadFunctions)(buf, elfHeader.littleEndian, elfHeader.elfClass === elf_constants_1.ElfClass.ELFCLASS32);
    if (elfHeader.elfClass === elf_constants_1.ElfClass.ELFCLASS32) {
        return {
            p_type: readUInt32(),
            p_offset: readBigUInt32Or64(),
            p_vaddr: readBigUInt32Or64(),
            p_paddr: readBigUInt32Or64(),
            p_filesz: readBigUInt32Or64(),
            p_memsz: readBigUInt32Or64(),
            p_flags: readUInt32(),
            p_align: readBigUInt32Or64(),
        };
    }
    else {
        return {
            p_type: readUInt32(),
            p_flags: readUInt32(),
            p_offset: readBigUInt32Or64(),
            p_vaddr: readBigUInt32Or64(),
            p_paddr: readBigUInt32Or64(),
            p_filesz: readBigUInt32Or64(),
            p_memsz: readBigUInt32Or64(),
            p_align: readBigUInt32Or64(),
        };
    }
});
exports.readElfProgramHeader = readElfProgramHeader;
const readElfProgramHeaderTable = (reader, elfHeader) => __awaiter(void 0, void 0, void 0, function* () {
    if (elfHeader.e_phnum === 0) {
        return [];
    }
    const programHeaders = new Array(elfHeader.e_phnum);
    for (let i = 0; i < elfHeader.e_phnum; i++) {
        programHeaders[i] = yield (0, exports.readElfProgramHeader)(reader, elfHeader, i);
    }
    return programHeaders;
});
exports.readElfProgramHeaderTable = readElfProgramHeaderTable;
const readElfNote = (reader, sectionHeader, elfHeader) => __awaiter(void 0, void 0, void 0, function* () {
    const buf = yield reader.read(Number(sectionHeader.sh_size), Number(sectionHeader.sh_offset));
    // read elf note header
    const { readUInt32 } = (0, filereader_1.createReadFunctions)(buf, elfHeader.littleEndian, elfHeader.elfClass === elf_constants_1.ElfClass.ELFCLASS32);
    const namesz = readUInt32();
    const descsz = readUInt32();
    const type = readUInt32();
    const name = buf.toString('ascii', 12, 12 + namesz);
    const align = Number(sectionHeader.sh_addralign);
    const descOffset = 12 + namesz;
    // align to descOffset to `align` bytes without division
    const alignedDescOffset = descOffset + ((align - (descOffset % align)) % align);
    const desc = buf.subarray(alignedDescOffset, alignedDescOffset + descsz);
    return { type, name, desc };
});
const getBuildIds = (reader, sectionHeaders, elfHeader) => __awaiter(void 0, void 0, void 0, function* () {
    let gnuBuildId = '';
    let goBuildId = '';
    const gnuBuildIdSection = sectionHeaders.find((section) => section.sh_type === elf_constants_1.SectionHeaderType.SHT_NOTE && section.name === '.note.gnu.build-id');
    if (gnuBuildIdSection) {
        const { type, name, desc } = yield readElfNote(reader, gnuBuildIdSection, elfHeader);
        if (type === elf_constants_1.NoteType.NT_GNU_BUILD_ID || name === 'GNU') {
            gnuBuildId = desc.toString('hex');
        }
    }
    const goBuildIdSection = sectionHeaders.find((section) => section.sh_type === elf_constants_1.SectionHeaderType.SHT_NOTE && section.name === '.note.go.buildid');
    if (goBuildIdSection) {
        const { type, name, desc } = yield readElfNote(reader, goBuildIdSection, elfHeader);
        if (type === elf_constants_1.NoteType.NT_GO_BUILD_ID || name === 'Go') {
            goBuildId = desc.toString('ascii');
        }
    }
    return { gnuBuildId, goBuildId };
});
exports.getBuildIds = getBuildIds;
const isSupportedArch = (arch) => {
    return SUPPORTED_ARCHS.includes(arch);
};
exports.isSupportedArch = isSupportedArch;
const isSupportedElfType = (type) => {
    return SUPPORTED_ELF_TYPES.includes(type);
};
exports.isSupportedElfType = isSupportedElfType;
const hasNonEmptySection = (sectionHeaders, name) => {
    return sectionHeaders.some((section) => section.name === name && section.sh_type !== elf_constants_1.SectionHeaderType.SHT_NOBITS);
};
exports.hasNonEmptySection = hasNonEmptySection;
const getSectionInfo = (sections) => {
    const hasDebugInfo = (0, exports.hasNonEmptySection)(sections, '.debug_info') || (0, exports.hasNonEmptySection)(sections, '.zdebug_info');
    const hasSymbolTable = (0, exports.hasNonEmptySection)(sections, '.symtab');
    const hasDynamicSymbolTable = (0, exports.hasNonEmptySection)(sections, '.dynsym');
    const hasCode = sections.some((section) => section.name === '.text' && section.sh_type === elf_constants_1.SectionHeaderType.SHT_PROGBITS);
    return { hasDebugInfo, hasSymbolTable, hasDynamicSymbolTable, hasCode };
};
exports.getSectionInfo = getSectionInfo;
const getElfFileMetadata = (filename) => __awaiter(void 0, void 0, void 0, function* () {
    const metadata = {
        filename,
        isElf: false,
        littleEndian: false,
        elfClass: 0,
        arch: '',
        gnuBuildId: '',
        goBuildId: '',
        fileHash: '',
        elfType: '',
        hasDebugInfo: false,
        hasSymbolTable: false,
        hasDynamicSymbolTable: false,
        hasCode: false,
    };
    let fileHandle;
    try {
        fileHandle = yield fs_1.default.promises.open(filename, 'r');
        const reader = new filereader_1.FileReader(fileHandle);
        const { isElf, elfHeader, error } = yield (0, exports.readElfHeader)(reader);
        if (isElf) {
            metadata.littleEndian = elfHeader.littleEndian;
            metadata.elfClass = elfHeader.elfClass === elf_constants_1.ElfClass.ELFCLASS64 ? 64 : 32;
            metadata.arch = elf_constants_1.MACHINE_TYPES_DESCRIPTION[elfHeader.e_machine];
            metadata.elfType = elf_constants_1.ELF_TYPES_DESCRIPTION[elfHeader.e_type];
        }
        metadata.error = error;
        metadata.isElf = isElf;
        if (!isElf || error || !(0, exports.isSupportedArch)(metadata.arch) || !(0, exports.isSupportedElfType)(metadata.elfType)) {
            return metadata;
        }
        const sectionHeaders = yield (0, exports.readElfSectionHeaderTable)(reader, elfHeader);
        const { gnuBuildId, goBuildId } = yield (0, exports.getBuildIds)(reader, sectionHeaders, elfHeader);
        const { hasDebugInfo, hasSymbolTable, hasDynamicSymbolTable, hasCode } = (0, exports.getSectionInfo)(sectionHeaders);
        let fileHash = '';
        if (hasCode) {
            // Only compute file hash if the file has code:
            // if the file has no code, it is likely a debug info file and its hash is useless
            fileHash = yield (0, exports.computeFileHash)(filename);
        }
        Object.assign(metadata, {
            fileHash,
            gnuBuildId,
            goBuildId,
            hasDebugInfo,
            hasSymbolTable,
            hasDynamicSymbolTable,
            hasCode,
        });
    }
    catch (error) {
        metadata.error = error;
    }
    finally {
        if (fileHandle) {
            yield fileHandle.close();
        }
    }
    return metadata;
});
exports.getElfFileMetadata = getElfFileMetadata;
// Compute a file hash as SHA256 checksum of the first and last 4096 bytes of the file
// and the file size represented as a big endian uint64. Only the first 16 bytes (128 bits)
// of the hash are used.
const computeFileHash = (filename) => __awaiter(void 0, void 0, void 0, function* () {
    const fd = yield fs_1.default.promises.open(filename, 'r');
    try {
        const stats = yield fd.stat();
        const fileSize = stats.size;
        const hash = (0, crypto_1.createHash)('sha256');
        const buffer = Buffer.alloc(4096);
        let { bytesRead } = yield fd.read(buffer, 0, 4096);
        hash.update(buffer.slice(0, bytesRead));
        ({ bytesRead } = yield fd.read(buffer, 0, 4096, Math.max(0, fileSize - 4096)));
        hash.update(buffer.slice(0, bytesRead));
        buffer.writeBigUInt64BE(BigInt(fileSize), 0);
        hash.update(buffer.slice(0, 8));
        return hash.digest('hex').slice(0, 32);
    }
    finally {
        yield fd.close();
    }
});
exports.computeFileHash = computeFileHash;
const hasZstdSupport = () => __awaiter(void 0, void 0, void 0, function* () {
    const { stdout } = yield (0, utils_1.execute)('objcopy --help');
    return /--compress-debug-sections.*zstd/.test(stdout.toString());
});
const memoize = (fn) => {
    let promise;
    return () => (promise = promise || fn());
};
const hasZstdSupportCached = memoize(hasZstdSupport);
const getSupportedBfdTargets = () => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { stdout } = yield (0, utils_1.execute)('objcopy --help');
    const groups = (_a = /supported targets: (?<targets>.*)$/m.exec(stdout.toString())) === null || _a === void 0 ? void 0 : _a.groups;
    if (groups) {
        return groups.targets.split(/\s+/);
    }
    return [];
});
const getSupportedBfdTargetsCached = memoize(getSupportedBfdTargets);
const replaceElfHeader = (targetFilename, sourceFilename) => __awaiter(void 0, void 0, void 0, function* () {
    const sourceElfHeader = yield getElfHeaderStart(sourceFilename);
    const fd2 = yield fs_1.default.promises.open(targetFilename, 'r+');
    yield fd2.write(sourceElfHeader, 0, sourceElfHeader.length, 0);
    yield fd2.close();
});
const copyElfDebugInfo = (filename, outputFile, elfFileMetadata, compressDebugSections) => __awaiter(void 0, void 0, void 0, function* () {
    const supportedTargets = yield getSupportedBfdTargetsCached();
    let bfdTargetOption = '';
    const bfdTarget = getBFDTargetForArch(elfFileMetadata.arch, elfFileMetadata.littleEndian, elfFileMetadata.elfClass);
    if (!supportedTargets.includes(bfdTarget)) {
        // To be able to use `objcopy` on a file with a different architecture than the host, we need to give the BFD target
        const genericBfdTarget = getGenericBFDTargetForArch(elfFileMetadata.arch, elfFileMetadata.littleEndian, elfFileMetadata.elfClass);
        bfdTargetOption = `-I ${genericBfdTarget}`;
    }
    let compressDebugSectionsOption = '';
    if (compressDebugSections) {
        compressDebugSectionsOption = '--compress-debug-sections';
        if (yield hasZstdSupportCached()) {
            compressDebugSectionsOption += '=zstd';
        }
    }
    const keepDynamicSymbolTable = elfFileMetadata.hasDynamicSymbolTable && !elfFileMetadata.hasSymbolTable && !elfFileMetadata.hasDebugInfo;
    // Remove .gdb_index section as it is not needed and can be quite big
    let options = `${bfdTargetOption} --only-keep-debug ${compressDebugSectionsOption} --remove-section=.gdb_index`;
    if (keepDynamicSymbolTable) {
        // If the file has only a dynamic symbol table, preserve the sections needed by symbolic to create a symcache
        const sectionsToKeep = ['.dynsym', '.dynstr', '.dynamic', '.hash', '.gnu.hash', '.gnu.version*', '.rel*'];
        options += ' ' + sectionsToKeep.map((section) => `--set-section-flags ${section}=alloc,readonly,contents`).join(' ');
    }
    yield (0, utils_1.execute)(`objcopy ${options} ${filename} ${outputFile}`);
    if (bfdTargetOption) {
        // Replace the ELF header in the extracted debug info file with the one from the initial file to keep the original architecture
        yield replaceElfHeader(outputFile, filename);
    }
});
exports.copyElfDebugInfo = copyElfDebugInfo;
const getOutputFilenameFromBuildId = (buildId) => {
    // Go build id may contain slashes, replace them with dashes so it can be used as a filename
    return buildId.replace(/\//g, '-');
};
exports.getOutputFilenameFromBuildId = getOutputFilenameFromBuildId;
const getBuildIdWithArch = (fileMetadata) => {
    return (fileMetadata.gnuBuildId || fileMetadata.goBuildId || fileMetadata.fileHash) + '-' + fileMetadata.arch;
};
exports.getBuildIdWithArch = getBuildIdWithArch;
//# sourceMappingURL=elf.js.map