"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstrumentCommand = void 0;
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const constants_1 = require("../../constants");
const apikey_1 = require("../../helpers/apikey");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const instrument_helpers_1 = require("../../helpers/git/instrument-helpers");
const renderer_1 = require("../../helpers/renderer");
const utils_1 = require("../../helpers/utils");
const validation_1 = require("../../helpers/validation");
const constants_2 = require("./constants");
const prompt_1 = require("./prompt");
const renderer_2 = require("./renderer");
const utils_2 = require("./utils");
// XXX temporary workaround for @google-cloud/run ESM/CJS module issues
const { ServicesClient } = require('@google-cloud/run');
// equivalent to google.cloud.run.v2.EmptyDirVolumeSource.Medium.MEMORY
const EMPTY_DIR_VOLUME_SOURCE_MEMORY = 1;
const DEFAULT_VOLUME_PATH = '/shared-volume';
const DEFAULT_LOGS_PATH = '/shared-volume/logs/*.log';
const DEFAULT_HEALTH_CHECK_PORT = 5555;
const DEFAULT_SIDECAR_IMAGE = 'gcr.io/datadoghq/serverless-init:latest';
const DEFAULT_ENV_VARS = [
    { name: constants_1.SITE_ENV_VAR, value: constants_1.DATADOG_SITE_US1 },
    { name: constants_1.LOGS_INJECTION_ENV_VAR, value: 'true' },
    { name: constants_1.DD_TRACE_ENABLED_ENV_VAR, value: 'true' },
    { name: constants_1.HEALTH_PORT_ENV_VAR, value: DEFAULT_HEALTH_CHECK_PORT.toString() },
];
class InstrumentCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        // private configPath = Option.String('--config') implement if requested by customers
        this.dryRun = clipanion_1.Option.Boolean('-d,--dry,--dry-run', false);
        this.environment = clipanion_1.Option.String('--env');
        this.extraTags = clipanion_1.Option.String('--extra-tags,--extraTags');
        this.project = clipanion_1.Option.String('-p,--project', {
            description: 'GCP project ID',
        });
        this.services = clipanion_1.Option.Array('-s,--service,--services', [], {
            description: 'Cloud Run service(s) to instrument',
        });
        this.interactive = clipanion_1.Option.Boolean('-i,--interactive', false, {
            description: 'Prompt for flags one at a time',
        });
        this.region = clipanion_1.Option.String('-r,--region', {
            description: 'GCP region your service(s) are deployed in',
        });
        this.logLevel = clipanion_1.Option.String('--log-level,--logLevel');
        this.sourceCodeIntegration = clipanion_1.Option.Boolean('--source-code-integration,--sourceCodeIntegration', true, {
            description: 'Enable source code integration to add git metadata as tags. Defaults to enabled. Specify `--no-source-code-integration` to disable.',
        });
        this.uploadGitMetadata = clipanion_1.Option.Boolean('--upload-git-metadata,--uploadGitMetadata', true, {
            description: 'Upload git metadata to Datadog. Defaults to enabled. Specify `--no-upload-git-metadata` to disable.',
        });
        this.tracing = clipanion_1.Option.String('--tracing');
        this.version = clipanion_1.Option.String('--version');
        this.llmobs = clipanion_1.Option.String('--llmobs');
        this.healthCheckPort = clipanion_1.Option.String('--port,--health-check-port,--healthCheckPort');
        this.sidecarImage = clipanion_1.Option.String('--image,--sidecar-image', DEFAULT_SIDECAR_IMAGE, {
            description: `The image to use for the sidecar container. Defaults to '${DEFAULT_SIDECAR_IMAGE}'`,
        });
        this.sidecarName = clipanion_1.Option.String('--sidecar-name', constants_2.DEFAULT_SIDECAR_NAME, {
            description: `(Not recommended) The name to use for the sidecar container. Defaults to '${constants_2.DEFAULT_SIDECAR_NAME}'`,
        });
        this.sharedVolumeName = clipanion_1.Option.String('--shared-volume-name', constants_2.DEFAULT_VOLUME_NAME, {
            description: `(Not recommended) The name to use for the shared volume. Defaults to '${constants_2.DEFAULT_VOLUME_NAME}'`,
        });
        this.sharedVolumePath = clipanion_1.Option.String('--shared-volume-path', DEFAULT_VOLUME_PATH, {
            description: `(Not recommended) The path to use for the shared volume. Defaults to '${DEFAULT_VOLUME_PATH}'`,
        });
        this.logsPath = clipanion_1.Option.String('--logs-path', DEFAULT_LOGS_PATH, {
            description: `(Not recommended) The path to use for the logs. Defaults to '${DEFAULT_LOGS_PATH}'. Must begin with the shared volume path.`,
        });
        this.sidecarCpus = clipanion_1.Option.String('--sidecar-cpus', '1', {
            description: `The number of CPUs to allocate to the sidecar container. Defaults to 1.`,
        });
        this.sidecarMemory = clipanion_1.Option.String('--sidecar-memory', '512Mi', {
            description: `The amount of memory to allocate to the sidecar container. Defaults to '512Mi'.`,
        });
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.fipsConfig = {
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
    }
    execute() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.fipsConfig.fips, this.fipsIgnoreError || this.fipsConfig.fipsIgnoreError);
            this.context.stdout.write(`\n${(0, renderer_2.dryRunPrefix)(this.dryRun)}üê∂ ${chalk_1.default.bold('Instrumenting Cloud Run service(s)')}\n\n`);
            // Verify DD API Key
            const site = (_a = process.env.DD_SITE) !== null && _a !== void 0 ? _a : constants_1.DATADOG_SITE_US1;
            try {
                const isApiKeyValid = yield (0, apikey_1.newApiKeyValidator)({
                    apiKey: process.env.DD_API_KEY,
                    datadogSite: site,
                }).validateApiKey();
                if (!isApiKeyValid) {
                    throw Error();
                }
            }
            catch (e) {
                this.context.stdout.write((0, renderer_1.renderSoftWarning)(`Invalid API Key stored in the environment variable ${chalk_1.default.bold('DD_API_KEY')}: ${(0, utils_1.maskString)((_b = process.env.DD_API_KEY) !== null && _b !== void 0 ? _b : '')} and ${chalk_1.default.bold('DD_SITE')}: ${site}\nEnsure you've set both DD_API_KEY and DD_SITE.`));
                return 1;
            }
            if (this.interactive) {
                if (!this.project) {
                    this.project = yield (0, prompt_1.requestGCPProject)();
                }
                if (!this.region) {
                    this.region = yield (0, prompt_1.requestGCPRegion)();
                }
                if (this.services.length === 0) {
                    const serviceName = yield (0, prompt_1.requestServiceName)();
                    this.services = [serviceName];
                }
                const envSite = process.env[constants_1.CI_SITE_ENV_VAR];
                if (!(0, validation_1.isValidDatadogSite)(envSite)) {
                    process.env[constants_1.CI_SITE_ENV_VAR] = yield (0, prompt_1.requestSite)();
                }
            }
            // Validate required variables
            if (!this.project) {
                this.context.stdout.write(chalk_1.default.yellow('Invalid or missing project. Please use the --project flag.\n'));
            }
            if (this.services.length === 0) {
                this.context.stdout.write(chalk_1.default.yellow('Invalid or missing service(s). Please use the --service flag.\n'));
            }
            if (!this.region) {
                this.context.stdout.write(chalk_1.default.yellow('Invalid or missing region. Please use the --region flag.\n'));
            }
            const ddService = process.env[constants_1.SERVICE_ENV_VAR];
            if (!ddService) {
                this.context.stdout.write((0, renderer_1.renderSoftWarning)('No DD_SERVICE env var found. Will default to the service name.'));
            }
            if (this.extraTags && !this.extraTags.match(constants_1.EXTRA_TAGS_REG_EXP)) {
                this.context.stderr.write((0, renderer_1.renderError)('Extra tags do not comply with the <key>:<value> array.\n'));
                return 1;
            }
            if (!this.project || !this.services || !this.services.length || !this.region) {
                return 1;
            }
            this.context.stdout.write(chalk_1.default.green('‚úî Required flags verified\n'));
            // Verify GCP credentials
            this.context.stdout.write(chalk_1.default.bold('\nüîë Verifying GCP credentials...\n'));
            const authenticated = yield (0, utils_2.checkAuthentication)();
            if (!authenticated) {
                this.context.stderr.write((0, renderer_2.renderAuthenticationInstructions)());
                return 1;
            }
            this.context.stdout.write(chalk_1.default.green('‚úî GCP credentials verified!\n\n'));
            if (this.sourceCodeIntegration) {
                this.extraTags = yield (0, instrument_helpers_1.handleSourceCodeIntegration)(this.context, this.uploadGitMetadata, this.extraTags);
            }
            // Instrument services with sidecar
            try {
                yield this.instrumentSidecar(this.project, this.services, this.region, ddService);
            }
            catch (error) {
                this.context.stderr.write((0, renderer_2.dryRunPrefix)(this.dryRun) + (0, renderer_1.renderError)(`Uninstrumentation failed: ${error}\n`));
                return 1;
            }
            if (!this.dryRun) {
                this.context.stdout.write('\n‚úÖ Cloud Run instrumentation completed successfully!\n');
            }
            return 0;
        });
    }
    instrumentSidecar(project, services, region, ddService) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = new ServicesClient();
            this.context.stdout.write(chalk_1.default.bold(`\n${(0, renderer_2.dryRunPrefix)(this.dryRun)}‚¨áÔ∏è Fetching existing service configurations from Cloud Run...\n`));
            const existingServiceConfigs = yield (0, utils_2.fetchServiceConfigs)(client, project, region, services);
            this.context.stdout.write(chalk_1.default.bold(`\n${(0, renderer_2.dryRunPrefix)(this.dryRun)}üöÄ Instrumenting Cloud Run services with sidecar...\n`));
            for (let i = 0; i < existingServiceConfigs.length; i++) {
                const serviceConfig = existingServiceConfigs[i];
                const serviceName = services[i];
                try {
                    const actualDDService = ddService !== null && ddService !== void 0 ? ddService : serviceName;
                    yield this.instrumentService(client, serviceConfig, serviceName, actualDDService);
                }
                catch (error) {
                    this.context.stderr.write((0, renderer_2.dryRunPrefix)(this.dryRun) + (0, renderer_1.renderError)(`Failed to instrument service ${serviceName}: ${error}\n`));
                    throw error;
                }
            }
        });
    }
    instrumentService(client, existingService, serviceName, ddService) {
        return __awaiter(this, void 0, void 0, function* () {
            const updatedService = this.createInstrumentedServiceConfig(existingService, ddService);
            this.context.stdout.write((0, utils_2.generateConfigDiff)(existingService, updatedService));
            if (this.dryRun) {
                this.context.stdout.write(`\n\n${(0, renderer_2.dryRunPrefix)(this.dryRun)}Would have updated service ${chalk_1.default.bold(serviceName)} with the above changes.\n`);
                return;
            }
            else if (this.interactive) {
                const confirmed = yield (0, prompt_1.requestConfirmation)('\nDo you want to apply the changes?');
                if (!confirmed) {
                    throw new Error('Instrumentation cancelled by user.');
                }
            }
            yield (0, renderer_2.withSpinner)(`Instrumenting service ${chalk_1.default.bold(serviceName)}...`, () => __awaiter(this, void 0, void 0, function* () {
                const [operation] = yield client.updateService({
                    service: updatedService,
                });
                yield operation.promise();
            }), `Instrumented service ${chalk_1.default.bold(serviceName)}`);
        });
    }
    createInstrumentedServiceConfig(service, ddService) {
        const template = service.template || {};
        const containers = template.containers || [];
        const volumes = template.volumes || [];
        const existingSidecarContainer = containers.find((c) => c.name === this.sidecarName);
        const newSidecarContainer = this.buildSidecarContainer(existingSidecarContainer, ddService);
        // Update all app containers to add volume mounts and env vars if they don't have them
        const updatedContainers = containers.map((container) => {
            if (container.name === this.sidecarName) {
                return newSidecarContainer;
            }
            return this.updateAppContainer(container, ddService);
        });
        // Add sidecar if it doesn't exist
        if (!existingSidecarContainer) {
            updatedContainers.push(newSidecarContainer);
        }
        // Add shared volume if it doesn't exist
        const hasSharedVolume = volumes.some((volume) => volume.name === this.sharedVolumeName);
        const updatedVolumes = hasSharedVolume
            ? volumes
            : [
                ...volumes,
                {
                    name: this.sharedVolumeName,
                    emptyDir: {
                        medium: EMPTY_DIR_VOLUME_SOURCE_MEMORY,
                    },
                },
            ];
        return Object.assign(Object.assign({}, service), { template: Object.assign(Object.assign({}, template), { containers: updatedContainers, volumes: updatedVolumes, 
                // Let GCR generate the next revision name
                revision: undefined }) });
    }
    buildSidecarContainer(existingSidecarContainer, ddService) {
        var _a, _b, _c;
        const newEnvVars = {};
        for (const envVar of (_a = existingSidecarContainer === null || existingSidecarContainer === void 0 ? void 0 : existingSidecarContainer.env) !== null && _a !== void 0 ? _a : []) {
            newEnvVars[envVar.name] = envVar.value;
        }
        // Add these env vars to the container if they don't already exist,
        // but leave them unchanged if they already exist in the container.
        for (const { name, value } of DEFAULT_ENV_VARS) {
            if (!(name in newEnvVars)) {
                newEnvVars[name] = value;
            }
        }
        // Overwrite existing env vars with these if they already exist
        // and add them to the container if they don't exist yet.
        newEnvVars[constants_1.API_KEY_ENV_VAR] = (_b = process.env[constants_1.API_KEY_ENV_VAR]) !== null && _b !== void 0 ? _b : '';
        newEnvVars[constants_1.SERVICE_ENV_VAR] = ddService;
        if (process.env[constants_1.SITE_ENV_VAR]) {
            newEnvVars[constants_1.SITE_ENV_VAR] = process.env[constants_1.SITE_ENV_VAR];
        }
        if (this.tracing) {
            newEnvVars[constants_1.DD_TRACE_ENABLED_ENV_VAR] = this.tracing;
        }
        if (this.environment) {
            newEnvVars[constants_1.ENVIRONMENT_ENV_VAR] = this.environment;
        }
        if (this.version) {
            newEnvVars[constants_1.VERSION_ENV_VAR] = this.version;
        }
        if (this.logLevel) {
            newEnvVars[constants_1.DD_LOG_LEVEL_ENV_VAR] = this.logLevel;
        }
        if (this.extraTags) {
            newEnvVars[constants_1.DD_TAGS_ENV_VAR] = this.extraTags;
        }
        newEnvVars[constants_1.LOGS_PATH_ENV_VAR] = this.logsPath;
        // If port is specified, overwrite any existing value
        // If port is not specified but already exists, leave the existing value unchanged
        // If port is not specified and does not exist, default to 5555
        let healthCheckPort = (_c = newEnvVars[constants_1.HEALTH_PORT_ENV_VAR]) !== null && _c !== void 0 ? _c : DEFAULT_HEALTH_CHECK_PORT.toString();
        if (this.healthCheckPort) {
            const newHealthCheckPort = Number(this.healthCheckPort);
            if (!Number.isNaN(newHealthCheckPort)) {
                healthCheckPort = newHealthCheckPort.toString();
                newEnvVars[constants_1.HEALTH_PORT_ENV_VAR] = healthCheckPort;
            }
        }
        const newEnv = Object.entries(newEnvVars).map(([name, value]) => ({ name, value }));
        // Create sidecar container with volume mount and environment variables
        return {
            name: this.sidecarName,
            image: this.sidecarImage,
            volumeMounts: [
                {
                    name: this.sharedVolumeName,
                    mountPath: this.sharedVolumePath,
                },
            ],
            env: newEnv,
            startupProbe: {
                tcpSocket: {
                    port: healthCheckPort,
                },
                initialDelaySeconds: 0,
                periodSeconds: 10,
                failureThreshold: 3,
                timeoutSeconds: 1,
            },
            resources: {
                limits: {
                    memory: this.sidecarMemory,
                    cpu: this.sidecarCpus,
                },
            },
        };
    }
    // Add volume mount and update required env vars
    updateAppContainer(appContainer, ddService) {
        var _a;
        const existingVolumeMounts = appContainer.volumeMounts || [];
        const hasSharedVolumeMount = existingVolumeMounts.some((mount) => mount.name === this.sharedVolumeName);
        const existingEnvVars = appContainer.env || [];
        const updatedContainer = Object.assign({}, appContainer);
        if (!hasSharedVolumeMount) {
            updatedContainer.volumeMounts = [
                ...existingVolumeMounts,
                {
                    name: this.sharedVolumeName,
                    mountPath: this.sharedVolumePath,
                },
            ];
        }
        // Update environment variables
        const newEnvVars = {};
        for (const { name, value } of existingEnvVars) {
            newEnvVars[name] = value;
        }
        // Default to DD_LOGS_INJECTION=true, but don't overwrite existing value
        if (!(constants_1.LOGS_INJECTION_ENV_VAR in newEnvVars)) {
            newEnvVars[constants_1.LOGS_INJECTION_ENV_VAR] = 'true';
        }
        // Replace or add other env vars
        newEnvVars[constants_1.SERVICE_ENV_VAR] = ddService;
        newEnvVars[constants_1.API_KEY_ENV_VAR] = (_a = process.env[constants_1.API_KEY_ENV_VAR]) !== null && _a !== void 0 ? _a : '';
        newEnvVars[constants_1.LOGS_PATH_ENV_VAR] = this.logsPath;
        if (this.llmobs) {
            newEnvVars[constants_1.DD_LLMOBS_ENABLED_ENV_VAR] = 'true';
            newEnvVars[constants_1.DD_LLMOBS_ML_APP_ENV_VAR] = this.llmobs;
            // serverless-init is installed, so agentless mode should be false
            newEnvVars[constants_1.DD_LLMOBS_AGENTLESS_ENABLED_ENV_VAR] = 'false';
        }
        updatedContainer.env = Object.entries(newEnvVars).map(([name, value]) => ({ name, value }));
        return updatedContainer;
    }
}
exports.InstrumentCommand = InstrumentCommand;
InstrumentCommand.paths = [['cloud-run', 'instrument']];
InstrumentCommand.usage = clipanion_1.Command.Usage({
    category: 'Serverless',
    description: 'Apply Datadog instrumentation to a Cloud Run app.',
});
//# sourceMappingURL=instrument.js.map