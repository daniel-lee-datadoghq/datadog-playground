"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UploadCommand = void 0;
const fs_1 = __importDefault(require("fs"));
const clipanion_1 = require("clipanion");
const upath_1 = __importDefault(require("upath"));
const constants_1 = require("../../constants");
const apikey_1 = require("../../helpers/apikey");
const concurrency_1 = require("../../helpers/concurrency");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const format_git_sourcemaps_data_1 = require("../../helpers/git/format-git-sourcemaps-data");
const glob_1 = require("../../helpers/glob");
const metrics_1 = require("../../helpers/metrics");
const upload_1 = require("../../helpers/upload");
const utils_1 = require("../../helpers/utils");
const validation = __importStar(require("../../helpers/validation"));
const validation_1 = require("../../helpers/validation");
const version_1 = require("../../helpers/version");
const utils_2 = require("../dsyms/utils");
const elf_1 = require("./elf");
const helpers_1 = require("./helpers");
const interfaces_1 = require("./interfaces");
const renderer_1 = require("./renderer");
class UploadCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.disableGit = clipanion_1.Option.Boolean('--disable-git', false);
        this.dryRun = clipanion_1.Option.Boolean('--dry-run', false);
        this.configPath = clipanion_1.Option.String('--config');
        this.maxConcurrency = clipanion_1.Option.String('--max-concurrency', '20', { validator: validation.isInteger() });
        this.repositoryUrl = clipanion_1.Option.String('--repository-url');
        this.acceptDynamicSymbolTableAsSymbolSource = clipanion_1.Option.Boolean('--upload-dynamic-symbols', false);
        this.replaceExisting = clipanion_1.Option.Boolean('--replace-existing', false);
        this.symbolsLocations = clipanion_1.Option.Rest({ required: 1 });
        this.cliVersion = version_1.version;
        this.config = {
            datadogSite: 'datadoghq.com',
        };
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.fipsConfig = {
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.fipsConfig.fips, this.fipsIgnoreError || this.fipsConfig.fipsIgnoreError);
            if (!(yield this.verifyParameters())) {
                return 1;
            }
            const initialTime = Date.now();
            this.context.stdout.write((0, renderer_1.renderCommandInfo)(this.dryRun, this.symbolsLocations));
            this.config = yield (0, utils_1.resolveConfigFromFileAndEnvironment)(this.config, {
                apiKey: process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
                datadogSite: process.env.DATADOG_SITE || process.env.DD_SITE,
            }, {
                configPath: this.configPath,
                defaultConfigPaths: utils_1.DEFAULT_CONFIG_PATHS,
                configFromFileCallback: (configFromFile) => {
                    (0, validation_1.checkAPIKeyOverride)(process.env.DATADOG_API_KEY || process.env.DD_API_KEY, configFromFile.apiKey, this.context.stdout);
                },
            });
            if (!this.disableGit) {
                this.gitData = yield this.getGitMetadata();
            }
            const callResults = [];
            try {
                callResults.push(...(yield this.performElfSymbolsUpload()));
                const totalTime = (Date.now() - initialTime) / 1000;
                this.context.stdout.write((0, renderer_1.renderCommandSummary)(callResults, totalTime, this.dryRun));
            }
            catch (e) {
                this.context.stderr.write((0, renderer_1.renderGeneralizedError)(e));
                return 1;
            }
            return 0;
        });
    }
    getApiKeyValidator(metricsLogger) {
        return (0, apikey_1.newApiKeyValidator)({
            apiKey: this.config.apiKey,
            datadogSite: this.config.datadogSite,
            metricsLogger: metricsLogger.logger,
        });
    }
    getGitDataPayload(gitData) {
        const files = gitData.trackedFilesMatcher.rawTrackedFilesList();
        const repoPayload = {
            data: [
                {
                    files,
                    hash: gitData.hash,
                    repository_url: gitData.remote,
                },
            ],
            version: 1,
        };
        return {
            type: 'string',
            options: { filename: 'repository', contentType: 'application/json' },
            value: JSON.stringify(repoPayload),
        };
    }
    getGitMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield (0, format_git_sourcemaps_data_1.getRepositoryData)(yield (0, format_git_sourcemaps_data_1.newSimpleGit)(), this.repositoryUrl);
            }
            catch (e) {
                this.context.stdout.write((0, renderer_1.renderGitWarning)(e));
            }
            return undefined;
        });
    }
    getElfSymbolSource(elfFileMetadata) {
        if (elfFileMetadata.hasDebugInfo) {
            return 'debug_info';
        }
        if (elfFileMetadata.hasSymbolTable) {
            return 'symbol_table';
        }
        if (elfFileMetadata.hasDynamicSymbolTable) {
            return 'dynamic_symbol_table';
        }
        return 'none';
    }
    getMappingMetadata(elfFileMetadata) {
        var _a, _b;
        return {
            cli_version: this.cliVersion,
            origin_version: this.cliVersion,
            origin: 'datadog-ci',
            arch: elfFileMetadata.arch,
            gnu_build_id: elfFileMetadata.gnuBuildId,
            go_build_id: elfFileMetadata.goBuildId,
            file_hash: elfFileMetadata.fileHash,
            git_commit_sha: (_a = this.gitData) === null || _a === void 0 ? void 0 : _a.hash,
            git_repository_url: (_b = this.gitData) === null || _b === void 0 ? void 0 : _b.remote,
            symbol_source: this.getElfSymbolSource(elfFileMetadata),
            filename: upath_1.default.basename(elfFileMetadata.filename),
            overwrite: this.replaceExisting,
            type: interfaces_1.TYPE_ELF_DEBUG_INFOS,
        };
    }
    getMetricsLogger() {
        const metricsLogger = (0, metrics_1.getMetricsLogger)({
            apiKey: this.config.apiKey,
            datadogSite: this.config.datadogSite,
            defaultTags: [`cli_version:${this.cliVersion}`, 'platform:elf'],
            prefix: 'datadog.ci.elf_symbols.',
        });
        return metricsLogger;
    }
    getElfSymbolFiles(symbolsLocation) {
        return __awaiter(this, void 0, void 0, function* () {
            let paths = [];
            let reportFailure;
            const stat = yield fs_1.default.promises.stat(symbolsLocation);
            if (stat.isDirectory()) {
                paths = yield (0, glob_1.globAsync)((0, utils_1.buildPath)(symbolsLocation, '**'), { dot: true, dotRelative: true });
                reportFailure = (message) => this.context.stdout.write((0, renderer_1.renderWarning)(message));
                // throw an error if top-level directory is not readable
                // eslint-disable-next-line no-bitwise
                yield fs_1.default.promises.access(symbolsLocation, fs_1.default.constants.R_OK | fs_1.default.constants.X_OK).catch(() => {
                    throw Error(`Directory ${symbolsLocation} is not readable`);
                });
            }
            else {
                paths = [symbolsLocation];
                // in single file mode, we want to report failures as errors
                reportFailure = (message) => {
                    throw Error(message);
                };
            }
            const filesMetadata = [];
            for (const p of paths) {
                const pathStat = yield fs_1.default.promises.lstat(p);
                if (pathStat.isDirectory()) {
                    // check if directory is readable and if not emit a warning
                    // eslint-disable-next-line no-bitwise
                    yield fs_1.default.promises.access(p, fs_1.default.constants.R_OK | fs_1.default.constants.X_OK).catch(() => {
                        reportFailure(`Skipped directory ${p} because it is not readable`);
                    });
                }
                else if (pathStat.isFile()) {
                    // check that path is a file and is an ELF file
                    const metadata = yield (0, elf_1.getElfFileMetadata)(p);
                    // handle all possible failures
                    if (!metadata.isElf) {
                        reportFailure(`Input location ${p} is not an ELF file`);
                        continue;
                    }
                    if (metadata.error) {
                        reportFailure(`Error reading ELF file ${p}: ${metadata.error.message}`);
                        continue;
                    }
                    if (!(0, elf_1.isSupportedElfType)(metadata.elfType)) {
                        reportFailure(`Skipped ${p} because its not an executable, nor a shared library`);
                        continue;
                    }
                    if (!(0, elf_1.isSupportedArch)(metadata.arch)) {
                        reportFailure(`Skipped ${p} because it has an unsupported architecture (${metadata.arch})`);
                        continue;
                    }
                    if (!(metadata.gnuBuildId || metadata.goBuildId || metadata.fileHash)) {
                        reportFailure(`Skipped ${p} because it has no build id`);
                        continue;
                    }
                    if (!metadata.hasDebugInfo &&
                        !metadata.hasSymbolTable &&
                        (!metadata.hasDynamicSymbolTable || !this.acceptDynamicSymbolTableAsSymbolSource)) {
                        reportFailure(`Skipped ${p} because it has no debug info, nor symbols`);
                        continue;
                    }
                    filesMetadata.push(metadata);
                }
            }
            // sort files to make output deterministic
            filesMetadata.sort((a, b) => a.filename.localeCompare(b.filename));
            return filesMetadata;
        });
    }
    removeBuildIdDuplicates(filesMetadata) {
        const buildIds = new Map();
        for (const metadata of filesMetadata) {
            const buildId = (0, elf_1.getBuildIdWithArch)(metadata);
            const existing = buildIds.get(buildId);
            if (existing) {
                if ((metadata.hasDebugInfo && !existing.hasDebugInfo) ||
                    (metadata.hasSymbolTable && !existing.hasSymbolTable) ||
                    (metadata.hasDynamicSymbolTable && !existing.hasDynamicSymbolTable) // this probably should never happen
                ) {
                    // if we have a duplicate build_id, we keep the one with debug info and symbols
                    this.context.stderr.write((0, renderer_1.renderWarning)(`Duplicate build_id found: ${buildId} in ${metadata.filename} and ${existing.filename} - skipping ${existing.filename} because it has no debug info or symbols`));
                    buildIds.set(buildId, metadata);
                }
                else {
                    // if both files have debug info and symbols, we keep the first one
                    this.context.stderr.write((0, renderer_1.renderWarning)(`Duplicate build_id found: ${buildId} in ${metadata.filename} and ${existing.filename} - skipping ${metadata.filename}`));
                }
            }
            else {
                buildIds.set(buildId, metadata);
            }
        }
        return Array.from(buildIds.values()).sort((a, b) => a.filename.localeCompare(b.filename));
    }
    performElfSymbolsUpload() {
        return __awaiter(this, void 0, void 0, function* () {
            const metricsLogger = this.getMetricsLogger();
            const apiKeyValidator = this.getApiKeyValidator(metricsLogger);
            let elfFilesMetadata = (yield Promise.all(this.symbolsLocations.map((location) => this.getElfSymbolFiles(location)))).flat();
            elfFilesMetadata = this.removeBuildIdDuplicates(elfFilesMetadata);
            const requestBuilder = (0, helpers_1.getElfRequestBuilder)(this.config.apiKey, this.cliVersion, this.config.datadogSite);
            const tmpDirectory = yield (0, utils_2.createUniqueTmpDirectory)();
            try {
                const results = yield (0, concurrency_1.doWithMaxConcurrency)(this.maxConcurrency, elfFilesMetadata, (fileMetadata) => __awaiter(this, void 0, void 0, function* () {
                    const metadata = this.getMappingMetadata(fileMetadata);
                    const outputFilename = (0, elf_1.getOutputFilenameFromBuildId)((0, elf_1.getBuildIdWithArch)(fileMetadata));
                    const outputFilePath = (0, utils_1.buildPath)(tmpDirectory, outputFilename);
                    yield (0, elf_1.copyElfDebugInfo)(fileMetadata.filename, outputFilePath, fileMetadata, true);
                    if (this.dryRun) {
                        this.context.stdout.write(`[DRYRUN] ${(0, renderer_1.renderUpload)(fileMetadata.filename, metadata)}`);
                        return upload_1.UploadStatus.Success;
                    }
                    const payload = {
                        content: new Map([
                            [
                                'event',
                                {
                                    type: 'string',
                                    value: JSON.stringify(metadata),
                                    options: { filename: 'event', contentType: 'application/json' },
                                },
                            ],
                            [
                                interfaces_1.VALUE_NAME_ELF_DEBUG_INFOS,
                                {
                                    type: 'file',
                                    path: outputFilePath,
                                    options: { filename: interfaces_1.ELF_DEBUG_INFOS_FILENAME },
                                },
                            ],
                        ]),
                    };
                    if (this.gitData !== undefined) {
                        payload.content.set('repository', this.getGitDataPayload(this.gitData));
                    }
                    return (0, helpers_1.uploadMultipartHelper)(requestBuilder, payload, {
                        apiKeyValidator,
                        onError: (e) => {
                            this.context.stdout.write((0, renderer_1.renderFailedUpload)(fileMetadata.filename, e.message));
                            metricsLogger.logger.increment('failed', 1);
                        },
                        onRetry: (e, attempts) => {
                            this.context.stdout.write((0, renderer_1.renderRetriedUpload)(fileMetadata.filename, e.message, attempts));
                            metricsLogger.logger.increment('retries', 1);
                        },
                        onUpload: () => {
                            this.context.stdout.write((0, renderer_1.renderUpload)(fileMetadata.filename, metadata));
                        },
                        retries: 5,
                        useGzip: true,
                    }).finally(() => {
                        // ignore errors when removing the file
                        fs_1.default.rm(outputFilePath, () => { });
                    });
                }));
                return results;
            }
            catch (error) {
                throw error;
            }
            finally {
                yield (0, utils_2.deleteDirectory)(tmpDirectory);
                try {
                    yield metricsLogger.flush();
                }
                catch (err) {
                    this.context.stdout.write(`WARN: ${err}\n`);
                }
            }
        });
    }
    checkBinUtils() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield (0, utils_1.execute)('objcopy --version');
                return true;
            }
            catch (e) {
                return false;
            }
        });
    }
    verifyParameters() {
        return __awaiter(this, void 0, void 0, function* () {
            let parametersOkay = true;
            if (!this.symbolsLocations || this.symbolsLocations.length === 0) {
                this.context.stderr.write((0, renderer_1.renderArgumentMissingError)('symbols locations'));
                parametersOkay = false;
            }
            else {
                for (const symbolsLocation of this.symbolsLocations) {
                    if (fs_1.default.existsSync(symbolsLocation)) {
                        const stats = fs_1.default.statSync(symbolsLocation);
                        if (!stats.isDirectory() && !stats.isFile()) {
                            this.context.stderr.write((0, renderer_1.renderInvalidSymbolsLocation)(symbolsLocation));
                            parametersOkay = false;
                        }
                    }
                    else {
                        this.context.stderr.write((0, renderer_1.renderInvalidSymbolsLocation)(symbolsLocation));
                        parametersOkay = false;
                    }
                }
            }
            if (!(yield this.checkBinUtils())) {
                this.context.stderr.write((0, renderer_1.renderMissingBinUtils)());
                parametersOkay = false;
            }
            return parametersOkay;
        });
    }
}
exports.UploadCommand = UploadCommand;
UploadCommand.paths = [['elf-symbols', 'upload']];
UploadCommand.usage = clipanion_1.Command.Usage({
    category: 'Profiling',
    description: 'Upload Elf debug info files to Datadog.',
    details: `
            This command will upload debug info from all Elf files found recursively in the given location in order to symbolicate profiles
        `,
    examples: [['Upload debug infos for all Elf files in the current directory', 'datadog-ci elf-symbols upload .']],
});
//# sourceMappingURL=upload.js.map