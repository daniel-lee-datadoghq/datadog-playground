"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tunnel = void 0;
const crypto_1 = require("crypto");
const net_1 = require("net");
const stream_1 = require("stream");
const ssh2_1 = require("ssh2");
const yamux_js_1 = require("yamux-js");
const crypto_2 = require("./crypto");
const websocket_1 = require("./websocket");
/**
 * Use `DEBUG=synthetics:tunnel` to enable debug logs.
 */
// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-var-requires, @typescript-eslint/no-unsafe-call
const debug = require('debug')('synthetics:tunnel');
// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-var-requires -- SW-1310
const SSH_CONSTANTS = require('ssh2/lib/protocol/constants');
// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-var-requires -- SW-1310
const { KexInit } = require('ssh2/lib/protocol/kex');
class Tunnel {
    constructor(url, testIDs, proxyAgent, reporter) {
        this.url = url;
        this.testIDs = testIDs;
        this.reporter = reporter;
        this.FORWARDING_TIMEOUT = 40000;
        /** Used to catch SIGINT only once. */
        this.started = false;
        /** Used to log "Successfully connected" only once. */
        this.connected = false;
        this.forwardedSockets = new Set();
        this.handleSIGINT = () => {
            var _a;
            if (this.started) {
                // The tunnel is connected, so we stop it gracefully – all tests will be aborted.
                (_a = this.reporter) === null || _a === void 0 ? void 0 : _a.log('Closing tunnel and waiting for results... (press Ctrl+C again to force quit)');
                void this.stop();
            }
            else {
                // The tunnel was already closed and we received a second Ctrl+C.
                // Removing the listener automatically stops the process.
                process.removeListener('SIGINT', this.handleSIGINT);
            }
        };
        // Setup SSH
        const { privateKey: hostPrivateKey } = (0, crypto_2.generateOpenSSHKeys)();
        const parsedHostPrivateKey = (0, crypto_2.parseSSHKey)(hostPrivateKey);
        const { publicKey, privateKey } = (0, crypto_2.generateOpenSSHKeys)();
        this.publicKey = (0, crypto_2.parseSSHKey)(publicKey);
        this.privateKey = privateKey;
        this.sshConfig = {
            algorithms: {
                serverHostKey: [parsedHostPrivateKey.type],
            },
            // Greatly increase highWaterMark (32kb -> 255kb) to avoid hanging with large requests
            highWaterMark: 255 * 1024,
            hostKeys: [hostPrivateKey],
        };
        this.ws = new websocket_1.WebSocket(this.url, proxyAgent);
    }
    /**
     * keepAlive will return a promise that tracks the state of the tunnel (and reject in case of error)
     */
    keepAlive() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.ws) {
                throw new Error('No WebSocket connection');
            }
            return this.ws.keepAlive();
        });
    }
    /**
     * start the tunnel:
     *   - get the pre-signed URL to connect to the tunnel service
     *   - Set up SSH
     *   - establish a WebSocket connection to the tunnel service
     */
    start() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            this.started = true;
            process.addListener('SIGINT', this.handleSIGINT);
            (_a = this.reporter) === null || _a === void 0 ? void 0 : _a.log(`Opening tunnel for ${this.testIDs.length} tests…`);
            (_b = this.reporter) === null || _b === void 0 ? void 0 : _b.log('Generating encryption key, setting up SSH and opening WebSocket connection…');
            try {
                // Establish a WebSocket connection to the tunnel service
                yield this.ws.connect();
                // @todo: in case of reconnect, add tunnel ID to WebSocket URL to re-use the same tunnel (in the tunnel service)
                const connectionInfo = yield this.forwardWebSocketToSSH();
                return connectionInfo;
            }
            catch (err) {
                (_c = this.reporter) === null || _c === void 0 ? void 0 : _c.error('Tunnel setup failed, cleaning up and exiting…');
                yield this.stop(); // Clean up
                throw err;
            }
        });
    }
    /**
     * stop the tunnel
     */
    stop() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.connected = false;
            this.forwardedSockets.forEach((socket) => {
                if (!!socket) {
                    socket.destroy();
                }
            });
            yield this.ws.close();
            if (this.started) {
                (_a = this.reporter) === null || _a === void 0 ? void 0 : _a.log('Tunnel closed.');
                this.started = false;
            }
        });
    }
    // Authenticate SSH with key authentication - username should be the test ID
    authenticateSSHConnection(ctx) {
        var _a;
        const allowedUsers = this.testIDs.map((testId) => Buffer.from(testId));
        // Ensure username is allowed
        const user = Buffer.from(ctx.username);
        if (!allowedUsers.some((allowedUser) => user.length === allowedUser.length && (0, crypto_1.timingSafeEqual)(user, allowedUser))) {
            return ctx.reject();
        }
        // Only allow key authentication
        if (ctx.method !== 'publickey') {
            return ctx.reject();
        }
        const allowedPubSSHKey = Buffer.from(this.publicKey.getPublicSSH());
        if (ctx.key.algo !== this.publicKey.type ||
            ctx.key.data.length !== allowedPubSSHKey.length ||
            !(0, crypto_1.timingSafeEqual)(ctx.key.data, allowedPubSSHKey) ||
            (ctx.signature && ctx.blob && !this.publicKey.verify(ctx.blob, ctx.signature))) {
            // Invalid key authentication
            return ctx.reject();
        }
        // A connection without a signature is only to check for public key validity
        if (!ctx.signature) {
            return ctx.accept();
        }
        // Username is allowed and key authentication was successful
        if (!this.connected) {
            // Limit to one log per tunnel
            this.connected = true;
            (_a = this.reporter) === null || _a === void 0 ? void 0 : _a.log('Successfully connected');
        }
        ctx.accept();
    }
    forwardProxiedPacketsFromSSH(client) {
        client
            .on('session', (accept) => {
            accept().on('close', () => {
                client.end();
            });
        })
            .on('tcpip', (accept, reject, { destIP, destPort }) => {
            // Forward packets
            // See https://github.com/mscdex/ssh2/issues/479#issuecomment-250416559
            let src;
            const dest = new net_1.Socket();
            dest.setTimeout(this.FORWARDING_TIMEOUT);
            this.forwardedSockets.add(dest);
            dest.on('timeout', () => {
                debug(`Connection timeout (${destIP})`);
                if (src) {
                    src.destroy();
                }
                else {
                    reject();
                }
                this.forwardedSockets.delete(dest);
                dest.end();
                dest.destroy();
            });
            dest.on('connect', () => {
                src = accept();
                if (!src) {
                    return dest.end();
                }
                (0, stream_1.pipeline)([dest, src], () => this.forwardedSockets.delete(dest));
                (0, stream_1.pipeline)([src, dest], () => this.forwardedSockets.delete(dest));
                src.on('close', () => {
                    dest.end();
                    dest.destroy();
                });
            });
            dest.on('error', (error) => {
                var _a, _b;
                if (src) {
                    if (error.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
                        debug(`Error on opened connection (${destIP}): ${error.code}`);
                    }
                    src.close();
                }
                else {
                    if ('code' in error && error.code === 'ENOTFOUND') {
                        (_a = this.reporter) === null || _a === void 0 ? void 0 : _a.warn(`Unable to resolve host (${destIP})`);
                    }
                    else {
                        (_b = this.reporter) === null || _b === void 0 ? void 0 : _b.warn(`Connection error (${destIP}): ${error.code}`);
                    }
                    reject();
                    this.forwardedSockets.delete(dest);
                    dest.end();
                    dest.destroy();
                }
            });
            dest.on('close', () => {
                if (src) {
                    src.close();
                }
                else {
                    reject();
                }
                this.forwardedSockets.delete(dest);
            });
            dest.connect(destPort, destIP);
        })
            .on('request', (accept, reject, name, info) => {
            if (accept) {
                accept();
            }
        });
    }
    forwardWebSocketToSSH() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const connectionInfo = yield this.getConnectionInfo();
            (_a = this.reporter) === null || _a === void 0 ? void 0 : _a.log(`Websocket connection to tunnel ${connectionInfo.id} opened, proxy is ready!`);
            // Stop any existing multiplexing
            if (this.multiplexer) {
                this.multiplexer.close();
            }
            // Set up multiplexing
            const multiplexerConfig = {
                // Increase maximum backlog size to more easily handle
                // running multiple large browser tests in parallel.
                acceptBacklog: 2048,
                enableKeepAlive: false,
            };
            this.multiplexer = new yamux_js_1.Server((stream) => {
                stream.on('error', (error) => {
                    debug(`Error in multiplexing: ${error}`);
                });
                void this.processSSHStream(stream);
            }, multiplexerConfig);
            // Pipe WebSocket to multiplexing
            const duplex = this.ws.duplex();
            this.multiplexer.on('error', (error) => {
                debug(`Multiplexer error: ${error.message}`);
            });
            duplex.on('error', (error) => {
                debug(`Websocket error: ${error.message}`);
            });
            (0, stream_1.pipeline)(duplex, this.multiplexer, (err) => {
                if (err) {
                    debug(`Error on duplex connection close: ${err}`);
                }
            });
            (0, stream_1.pipeline)(this.multiplexer, duplex, (err) => {
                if (err) {
                    debug(`Error on Multiplexer connection close: ${err}`);
                }
            });
            return connectionInfo;
        });
    }
    getConnectionInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const rawConnectionInfo = yield this.ws.waitForFirstMessage();
            try {
                const connectionInfo = Object.assign({ privateKey: this.privateKey }, JSON.parse(rawConnectionInfo.toString()));
                return connectionInfo;
            }
            catch (_a) {
                throw new Error(`Unexpected response from tunnel service: ${rawConnectionInfo.toString()}\n`);
            }
        });
    }
    processSSHStream(stream) {
        return __awaiter(this, void 0, void 0, function* () {
            // Process SSH stream - see https://github.com/mscdex/ssh2/blob/v0.8.x/lib/server.js#L24
            const serverConfig = Object.assign(Object.assign({}, this.sshConfig), { keepaliveInterval: 0 });
            ssh2_1.Server.KEEPALIVE_CLIENT_INTERVAL = 0;
            const server = new ssh2_1.Server(serverConfig, () => {
                // 'connection' event listener is required otherwise connection wont proceed.
            });
            const { ident } = this.sshConfig;
            const hostKeys = { 'ecdsa-sha2-nistp256': (0, crypto_2.parseSSHKey)(this.sshConfig.hostKeys[0]) };
            const encryptionConfig = {
                cipher: SSH_CONSTANTS.DEFAULT_CIPHER,
                compress: SSH_CONSTANTS.DEFAULT_COMPRESSION,
                lang: [],
                mac: SSH_CONSTANTS.DEFAULT_MAC,
            };
            const algorithms = {
                cs: encryptionConfig,
                kex: SSH_CONSTANTS.DEFAULT_KEX,
                sc: encryptionConfig,
                serverHostKey: ['ecdsa-sha2-nistp256'],
            };
            const offer = new KexInit(algorithms);
            const clientConfig = Object.assign(Object.assign({}, this.sshConfig), { keepaliveInterval: 0 });
            // SW-1310: Typing does not include IncomingClient
            const client = new ssh2_1.Server.IncomingClient(stream, hostKeys, ident, offer, undefined, server, clientConfig);
            client
                .on('authentication', (ctx) => this.authenticateSSHConnection(ctx))
                .on('ready', () => this.forwardProxiedPacketsFromSSH(client))
                .on('close', () => {
                server.close();
            })
                .on('error', (err) => {
                debug(`SSH error in proxy: ${err.message}`);
            });
        });
    }
}
exports.Tunnel = Tunnel;
//# sourceMappingURL=tunnel.js.map