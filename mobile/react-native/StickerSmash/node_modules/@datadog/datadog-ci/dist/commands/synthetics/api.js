"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApiHelper = exports.apiConstructor = exports.is5xxError = exports.isNodeError = exports.isTooManyRequestsError = exports.isNotFoundError = exports.isForbiddenError = exports.getErrorHttpStatus = exports.determineRetryDelay = exports.pollMobileApplicationUploadResponse = exports.completeMultipartMobileApplicationUpload = exports.formatBackendErrors = exports.extractUnauthorizedTestPublicIds = exports.EndpointError = void 0;
const querystring_1 = require("querystring");
const axios_1 = require("axios");
const utils_1 = require("../../helpers/utils");
const errors_1 = require("./errors");
const test_1 = require("./test");
const public_1 = require("./utils/public");
const MAX_RETRIES = 3;
const DELAY_BETWEEN_RETRIES = 500; // In ms
const LARGE_DELAY_BETWEEN_RETRIES = 1000; // In ms
// TODO SYNTH-13709: Use the `Retry-After` header.
const DELAY_BETWEEN_429_RETRIES = 5000; // In ms
class EndpointError extends Error {
    constructor(message, status) {
        super(message);
        this.message = message;
        this.status = status;
        Object.setPrototypeOf(this, EndpointError.prototype);
    }
}
exports.EndpointError = EndpointError;
const LOWER_UNAMBIGUOUS_CHARS = 'abcdefghijkmnpqrstuvwxyz23456789';
const PUBLIC_ID_REGEX = `[${LOWER_UNAMBIGUOUS_CHARS}]{3}-[${LOWER_UNAMBIGUOUS_CHARS}]{3}-[${LOWER_UNAMBIGUOUS_CHARS}]{3}`;
/**
 * Extracts the public IDs from an error message like `Cannot write tests or results (test ids: ['aaa-aaa-aaa', 'bbb-bbb-bbb'])`.
 */
const extractUnauthorizedTestPublicIds = (requestError) => {
    var _a, _b, _c;
    const unauthorizedMessage = (_c = (_b = (_a = requestError.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.errors) === null || _c === void 0 ? void 0 : _c.find((error) => error.includes('Cannot write tests or results (test ids:'));
    if (!unauthorizedMessage) {
        return;
    }
    const matchResult = unauthorizedMessage.match(new RegExp(PUBLIC_ID_REGEX, 'g'));
    if (!matchResult) {
        return;
    }
    return new Set(matchResult);
};
exports.extractUnauthorizedTestPublicIds = extractUnauthorizedTestPublicIds;
const formatBackendErrors = (requestError, scopeName) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if ((_b = (_a = requestError.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.errors) {
        const serverHead = `query on ${(_c = requestError.config) === null || _c === void 0 ? void 0 : _c.baseURL}${(_d = requestError.config) === null || _d === void 0 ? void 0 : _d.url} returned:`;
        const errors = requestError.response.data.errors;
        const reportMessage = [];
        if (errors.length > 1) {
            reportMessage.push(serverHead);
            reportMessage.push(...errors.map((message) => `  - ${message}`));
        }
        else if (errors.length) {
            reportMessage.push(`${serverHead} "${errors[0]}"`);
        }
        else {
            reportMessage.push(`error querying ${(_e = requestError.config) === null || _e === void 0 ? void 0 : _e.baseURL}${(_f = requestError.config) === null || _f === void 0 ? void 0 : _f.url}`);
        }
        if (requestError.response.status === 403 && scopeName) {
            reportMessage.push(`Is the App key granted the ${scopeName} scope?`);
        }
        return reportMessage.join('\n');
    }
    return `could not query ${(_g = requestError.config) === null || _g === void 0 ? void 0 : _g.baseURL}${(_h = requestError.config) === null || _h === void 0 ? void 0 : _h.url}\n${requestError.message}`;
};
exports.formatBackendErrors = formatBackendErrors;
const triggerTests = (request) => (data) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        data,
        headers: { 'X-Trigger-App': public_1.ciTriggerApp },
        method: 'POST',
        url: '/synthetics/tests/trigger/ci',
    }, request, { retryOn429: true });
    return resp.data;
});
const getTest = (request) => (testId, testType) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        url: !!testType ? `/synthetics/tests/${testType}/${testId}` : `/synthetics/tests/${testId}`,
    }, request, { retryOn429: true });
    return resp.data;
});
const getLocalTestDefinition = (request) => (testId, testType) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        params: {
            format: 'ltd',
        },
        url: !!testType ? `/synthetics/tests/${testType}/${testId}` : `/synthetics/tests/${testId}`,
    }, request, { retryOn429: true });
    return resp.data;
});
const editTest = (request) => (testId, data) => __awaiter(void 0, void 0, void 0, function* () {
    yield retryRequest({
        data,
        method: 'PUT',
        url: `/synthetics/tests/${testId}`,
    }, request, { retryOn429: true });
});
const searchTests = (request) => (query) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        params: {
            // Search for one more test than limit to detect if too many tests are returned
            count: test_1.MAX_TESTS_TO_TRIGGER + 1,
            text: query,
        },
        url: '/synthetics/tests/search',
    }, request);
    return resp.data;
});
const getSyntheticsOrgSettings = (request) => () => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        url: '/synthetics/settings',
    }, request);
    return resp.data;
});
const getBatch = (request) => (batchId) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({ url: `/synthetics/ci/batch/${batchId}` }, request, {
        retryOn404: true,
        retryOn429: true,
    });
    const serverBatch = resp.data.data;
    return {
        results: serverBatch.results.filter((r) => r.status !== 'skipped' || r.selective_rerun),
        status: serverBatch.status,
    };
});
const pollResults = (request) => (resultIds) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const resp = yield retryRequest({
        params: {
            result_ids: JSON.stringify(resultIds),
        },
        url: '/synthetics/tests/poll_results',
    }, request, { retryOn404: true, retryOn429: true });
    const includedTestsByID = new Map();
    (_a = resp.data.included) === null || _a === void 0 ? void 0 : _a.forEach((r) => {
        if (r.type === 'test') {
            const test = Object.assign({ id: r.id }, r.attributes);
            includedTestsByID.set(r.id, test);
        }
    });
    const rawPollResults = resp.data.data;
    const parsedPollResults = [];
    for (const r of rawPollResults) {
        const test = includedTestsByID.get(r.relationships.test.data.id);
        if (!test) {
            continue;
        }
        const pollResult = Object.assign(Object.assign({}, r.attributes), { test: parseIncludedTest(test), resultID: r.id });
        parsedPollResults.push(pollResult);
    }
    return parsedPollResults;
});
const parseIncludedTest = (test) => {
    var _a;
    return {
        public_id: test.id,
        type: test.type,
        subtype: test.subtype,
        config: Object.assign(Object.assign({}, test.config), { request: Object.assign(Object.assign({}, test.config.request), { dnsServer: (_a = test.config.request) === null || _a === void 0 ? void 0 : _a.dns_server }) }),
    };
};
const getTunnelPresignedURL = (request) => (testIds) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        params: {
            test_id: testIds,
        },
        paramsSerializer: (params) => (0, querystring_1.stringify)(params),
        url: '/synthetics/ci/tunnel',
    }, request);
    return resp.data;
});
const getMobileApplicationPresignedURLs = (request) => (applicationId, appSize, parts) => __awaiter(void 0, void 0, void 0, function* () {
    const partForRequest = (part) => ({
        md5: part.md5,
        partNumber: part.partNumber,
    });
    const resp = yield retryRequest({
        data: {
            appSize,
            parts: parts.map(partForRequest),
        },
        method: 'POST',
        url: `/synthetics/mobile/applications/${applicationId}/multipart-presigned-urls`,
    }, request);
    return resp.data;
});
const uploadMobileApplicationPart = (request) => (parts, multipartPresignedUrlsParams) => __awaiter(void 0, void 0, void 0, function* () {
    const promises = Object.entries(multipartPresignedUrlsParams.urls).map(([partNumber, presignedUrl]) => __awaiter(void 0, void 0, void 0, function* () {
        const resp = yield retryRequest({
            data: parts[Number(partNumber) - 1].blob,
            headers: {
                'Content-MD5': parts[Number(partNumber) - 1].md5,
                // Presigned URL *requires* unset content-type since it's used for signature
                // We can clear axios default by setting to null
                // https://github.com/axios/axios/pull/1845
                // eslint-disable-next-line no-null/no-null
                'Content-Type': null,
            },
            maxBodyLength: Infinity,
            maxContentLength: Infinity,
            method: 'PUT',
            url: presignedUrl,
        }, request);
        // Azure part-upload does not return ETag headers, so our backend ignores it for Azure
        const quotedEtag = isAzureUrl(presignedUrl) ? '' : resp.headers.etag;
        return {
            ETag: quotedEtag.replace(/"/g, ''),
            PartNumber: Number(partNumber),
        };
    }));
    return Promise.all(promises);
});
const completeMultipartMobileApplicationUpload = (request) => (applicationId, uploadId, key, uploadPartResponses, newVersionParams) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        data: {
            key,
            newVersionParams,
            parts: uploadPartResponses,
            uploadId,
            validateMode: newVersionParams ? 'validate-and-persist' : 'validate-only',
        },
        method: 'POST',
        url: `/synthetics/mobile/applications/${applicationId}/multipart-upload-complete`,
    }, request);
    return resp.data.job_id;
});
exports.completeMultipartMobileApplicationUpload = completeMultipartMobileApplicationUpload;
const pollMobileApplicationUploadResponse = (request) => (jobId) => __awaiter(void 0, void 0, void 0, function* () {
    const response = yield retryRequest({
        method: 'GET',
        url: `/synthetics/mobile/applications/validation-job-status/${jobId}`,
    }, request);
    return response.data;
});
exports.pollMobileApplicationUploadResponse = pollMobileApplicationUploadResponse;
const retryWithJitter = (delay = DELAY_BETWEEN_429_RETRIES) => delay + Math.floor(Math.random() * delay);
const determineRetryDelay = (retries, error, retryPolicy = { retryOn404: false, retryOn429: false }) => {
    // Always retry on Node.js errors
    if (retries < MAX_RETRIES && (0, exports.isNodeError)(error)) {
        return LARGE_DELAY_BETWEEN_RETRIES;
    }
    // Always retry on 5xx
    if (retries < MAX_RETRIES && (0, exports.is5xxError)(error)) {
        return DELAY_BETWEEN_RETRIES;
    }
    // Retry on 404
    if (retryPolicy.retryOn404 && retries < MAX_RETRIES && (0, exports.isNotFoundError)(error)) {
        return DELAY_BETWEEN_RETRIES;
    }
    // Retry on 429
    if (retryPolicy.retryOn429 && retries < MAX_RETRIES && (0, exports.isTooManyRequestsError)(error)) {
        return retryWithJitter(DELAY_BETWEEN_429_RETRIES);
    }
};
exports.determineRetryDelay = determineRetryDelay;
const isEndpointError = (error) => error instanceof EndpointError;
const getErrorHttpStatus = (error) => { var _a; return isEndpointError(error) ? error.status : (0, axios_1.isAxiosError)(error) ? (_a = error.response) === null || _a === void 0 ? void 0 : _a.status : undefined; };
exports.getErrorHttpStatus = getErrorHttpStatus;
const isForbiddenError = (error) => (0, exports.getErrorHttpStatus)(error) === 403;
exports.isForbiddenError = isForbiddenError;
const isNotFoundError = (error) => (0, exports.getErrorHttpStatus)(error) === 404;
exports.isNotFoundError = isNotFoundError;
const isTooManyRequestsError = (error) => (0, exports.getErrorHttpStatus)(error) === 429;
exports.isTooManyRequestsError = isTooManyRequestsError;
const isNodeError = (error) => !!error && 'code' in error;
exports.isNodeError = isNodeError;
const is5xxError = (error) => {
    const statusCode = (0, exports.getErrorHttpStatus)(error);
    return statusCode && statusCode >= 500 && statusCode <= 599 ? true : false;
};
exports.is5xxError = is5xxError;
const retryRequest = (args, request, statusCodesToRetryOn) => (0, public_1.retry)(() => request(args), (retries, e) => (0, exports.determineRetryDelay)(retries, e, statusCodesToRetryOn));
const apiConstructor = (configuration) => {
    const { baseV1Url, baseV2Url, baseIntakeUrl, baseUnstableUrl, apiKey, appKey, proxyOpts } = configuration;
    const baseOptions = { apiKey, appKey, proxyOpts };
    const requestV1 = (0, utils_1.getRequestBuilder)(Object.assign(Object.assign({}, baseOptions), { baseUrl: baseV1Url }));
    const requestV2 = (0, utils_1.getRequestBuilder)(Object.assign(Object.assign({}, baseOptions), { baseUrl: baseV2Url }));
    const requestUnstable = (0, utils_1.getRequestBuilder)(Object.assign(Object.assign({}, baseOptions), { baseUrl: baseUnstableUrl }));
    const requestIntake = (0, utils_1.getRequestBuilder)(Object.assign(Object.assign({}, baseOptions), { baseUrl: baseIntakeUrl }));
    return {
        getBatch: getBatch(requestV1),
        getMobileApplicationPresignedURLs: getMobileApplicationPresignedURLs(requestUnstable),
        getTest: getTest(requestV1),
        getLocalTestDefinition: getLocalTestDefinition(requestV1),
        editTest: editTest(requestV1),
        getSyntheticsOrgSettings: getSyntheticsOrgSettings(requestV1),
        getTunnelPresignedURL: getTunnelPresignedURL(requestIntake),
        pollResults: pollResults(requestV2),
        searchTests: searchTests(requestV1),
        triggerTests: triggerTests(requestIntake),
        uploadMobileApplicationPart: uploadMobileApplicationPart(requestV1),
        completeMultipartMobileApplicationUpload: (0, exports.completeMultipartMobileApplicationUpload)(requestUnstable),
        pollMobileApplicationUploadResponse: (0, exports.pollMobileApplicationUploadResponse)(requestUnstable),
    };
};
exports.apiConstructor = apiConstructor;
const getApiHelper = (config) => {
    if (!config.appKey) {
        throw new errors_1.CriticalError('MISSING_APP_KEY', 'App key is required');
    }
    if (!config.apiKey) {
        throw new errors_1.CriticalError('MISSING_API_KEY', 'API key is required');
    }
    return (0, exports.apiConstructor)({
        apiKey: config.apiKey,
        appKey: config.appKey,
        baseIntakeUrl: (0, public_1.getDatadogHost)({ useIntake: true, apiVersion: 'v1', config }),
        baseUnstableUrl: (0, public_1.getDatadogHost)({ useIntake: false, apiVersion: 'unstable', config }),
        baseV1Url: (0, public_1.getDatadogHost)({ useIntake: false, apiVersion: 'v1', config }),
        baseV2Url: (0, public_1.getDatadogHost)({ useIntake: false, apiVersion: 'v2', config }),
        proxyOpts: config.proxy,
    });
};
exports.getApiHelper = getApiHelper;
const isAzureUrl = (presignedUrl) => {
    // https://learn.microsoft.com/en-us/rest/api/storageservices/put-blob-from-url?tabs=microsoft-entra-id#request
    return presignedUrl.includes('.blob.core.windows.net');
};
//# sourceMappingURL=api.js.map