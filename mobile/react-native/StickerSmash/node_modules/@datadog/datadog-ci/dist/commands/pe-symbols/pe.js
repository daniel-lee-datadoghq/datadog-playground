"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBuildId = exports.getPEFileMetadata = void 0;
const fs_1 = __importDefault(require("fs"));
const filereader_1 = require("../../helpers/filereader");
const pe_constants_1 = require("./pe-constants");
const getArchitecture = (machine) => {
    let architecture = pe_constants_1.MachineArchitecture.unknown;
    if (machine === pe_constants_1.IMAGE_FILE_MACHINE_I386) {
        architecture = pe_constants_1.MachineArchitecture.x86;
    }
    else if (machine === pe_constants_1.IMAGE_FILE_MACHINE_AMD64) {
        architecture = pe_constants_1.MachineArchitecture.x64;
    }
    else if (machine === pe_constants_1.IMAGE_FILE_MACHINE_ARM32) {
        architecture = pe_constants_1.MachineArchitecture.Arm32;
    }
    else if (machine === pe_constants_1.IMAGE_FILE_MACHINE_ARM64) {
        architecture = pe_constants_1.MachineArchitecture.Arm64;
    }
    return architecture;
};
const readPEHeader = (reader) => __awaiter(void 0, void 0, void 0, function* () {
    const result = {
        isPE: false,
    };
    result.peHeader = {
        peHeaderOffset: 0,
        is64: false,
        architecture: pe_constants_1.MachineArchitecture.unknown,
        numberOfSections: 0,
        buildTime: '',
        sectionHeadersOffset: 0,
    };
    try {
        // read the DOS header to find the offset to the PE header
        const dosHeaderBuffer = yield reader.read(pe_constants_1.DOS_HEADER_SIZE);
        const dosMagic = dosHeaderBuffer.readInt16LE(0);
        if (dosMagic !== pe_constants_1.IMAGE_DOS_SIGNATURE) {
            result.isPE = false;
            result.error = Error('Invalid DOS header');
            return result;
        }
        const peHeaderOffset = dosHeaderBuffer.readUint32LE(pe_constants_1.DOS_HEADER_LFANEW_OFFSET);
        result.peHeader.peHeaderOffset = peHeaderOffset;
        // look at the PE header now
        const peCommonHeaderBuffer = yield reader.read(pe_constants_1.IMAGE_NT_HEADERS_GENERIC_SIZE, peHeaderOffset);
        // check the signature
        const peSignature = peCommonHeaderBuffer.toString('utf-8', 0, 4);
        if (peSignature !== 'PE\0\0') {
            result.isPE = false;
            result.error = Error('Invalid PE header');
            return result;
        }
        // read the Machine field
        const machine = peCommonHeaderBuffer.readUint16LE(pe_constants_1.IMAGE_NT_HEADERS_GENERIC_MACHINE_OFFSET);
        result.peHeader.architecture = getArchitecture(machine);
        // read the NumberOfSections field
        result.peHeader.numberOfSections = peCommonHeaderBuffer.readUint16LE(pe_constants_1.IMAGE_NT_HEADERS_GENERIC_NUMBEROFSECTIONS_OFFSET);
        // read the build time
        const timestamp = peCommonHeaderBuffer.readUint32LE(pe_constants_1.IMAGE_NT_HEADERS_GENERIC_TIMESTAMP_OFFSET);
        const buildDate = new Date(timestamp * 1000).toUTCString();
        result.peHeader.buildTime = `${buildDate}`;
        // read the Magic field
        const magic = peCommonHeaderBuffer.readUint16LE(pe_constants_1.IMAGE_NT_HEADERS_GENERIC_MAGIC_OFFSET);
        result.peHeader.is64 = magic === pe_constants_1.IMAGE_NT_OPTIONAL_HDR64_MAGIC;
        result.peHeader.sectionHeadersOffset = result.peHeader.is64 ? pe_constants_1.IMAGE_NT_HEADERS64_SIZE : pe_constants_1.IMAGE_NT_HEADERS32_SIZE;
        result.isPE = true;
    }
    catch (error) {
        // console.log(error)
        if (error instanceof Error) {
            result.error = error;
        }
        else {
            throw error;
        }
    }
    return result;
});
const getSectionHeaders = (reader, peHeader) => __awaiter(void 0, void 0, void 0, function* () {
    const sections = new Array(peHeader.numberOfSections);
    const sectionHeadersOffset = peHeader.peHeaderOffset + peHeader.sectionHeadersOffset;
    const sectionsBuffer = yield reader.read(peHeader.numberOfSections * pe_constants_1.IMAGE_SECTION_HEADER_SIZE, sectionHeadersOffset);
    let sectionOffset = 0;
    for (let i = 0; i < peHeader.numberOfSections; i++) {
        // the name is at the beginning of the section header
        let name = '';
        for (let j = 0; j < pe_constants_1.IMAGE_SHORT_NAME_SIZE; j++) {
            if (sectionsBuffer[sectionOffset + j] === 0) {
                break;
            }
            name += String.fromCharCode(sectionsBuffer[sectionOffset + j]);
        }
        const virtualSize = sectionsBuffer.readUInt32LE(sectionOffset + pe_constants_1.IMAGE_SECTION_HEADER_VIRTUALSIZE_OFFSET);
        const virtualAddress = sectionsBuffer.readUInt32LE(sectionOffset + pe_constants_1.IMAGE_SECTION_HEADER_VIRTUALADDRESS_OFFSET);
        const pointerToRawData = sectionsBuffer.readUInt32LE(sectionOffset + pe_constants_1.IMAGE_SECTION_HEADER_POINTERTORAWDATA_OFFSET);
        sections[i] = { name, virtualSize, virtualAddress, pointerToRawData };
        sectionOffset += pe_constants_1.IMAGE_SECTION_HEADER_SIZE;
    }
    return sections;
});
// from https://github.com/microsoft/clrmd/blob/main/src/Microsoft.Diagnostics.Runtime/Utilities/PEImage/PEImage.cs#L286C1-L303C10
const rvaToOffset = (virtualAddress, sections) => {
    if (virtualAddress < 4096) {
        return virtualAddress;
    }
    for (const section of sections) {
        if (section.virtualAddress <= virtualAddress && virtualAddress < section.virtualAddress + section.virtualSize) {
            const offset = section.pointerToRawData + (virtualAddress - section.virtualAddress);
            return offset;
        }
    }
    return 0;
};
const toHex = (value, length) => {
    return value.toString(16).padStart(length, '0').toUpperCase();
};
const getPEFileMetadata = (filename) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const metadata = {
        filename,
        isPE: false,
        arch: pe_constants_1.MachineArchitecture.unknown,
        hasPdbInfo: false,
        pdbAge: 0,
        pdbSig: undefined,
        pdbFilename: '',
    };
    let fileHandle;
    try {
        fileHandle = yield fs_1.default.promises.open(filename, 'r');
        const reader = new filereader_1.FileReader(fileHandle);
        const peHeaderResult = yield readPEHeader(reader);
        if (!peHeaderResult.isPE || peHeaderResult.peHeader === undefined) {
            throw peHeaderResult.error;
        }
        metadata.isPE = true;
        metadata.arch = (_a = peHeaderResult.peHeader) === null || _a === void 0 ? void 0 : _a.architecture;
        // get the DEBUG section
        let debugSectionOffset = 0;
        if (peHeaderResult.peHeader.is64) {
            debugSectionOffset = peHeaderResult.peHeader.peHeaderOffset + pe_constants_1.IMAGE_DATA_DIRECTORY64_OFFSET;
        }
        else {
            debugSectionOffset = peHeaderResult.peHeader.peHeaderOffset + pe_constants_1.IMAGE_DATA_DIRECTORY32_OFFSET;
        }
        debugSectionOffset += pe_constants_1.IMAGE_DIRECTORY_ENTRY_DEBUG * pe_constants_1.IMAGE_DATA_DIRECTORY_SIZE;
        const peCommonHeaderBuffer = yield reader.read(pe_constants_1.IMAGE_DATA_DIRECTORY_SIZE, debugSectionOffset);
        const debugSectionVirtualAddress = peCommonHeaderBuffer.readUInt32LE(pe_constants_1.IMAGE_DATA_DIRECTORY_VIRTUAL_ADDRESS_OFFSET);
        const debugSectionSize = peCommonHeaderBuffer.readUInt32LE(pe_constants_1.IMAGE_DATA_DIRECTORY_SIZE_OFFSET);
        if (debugSectionVirtualAddress === 0) {
            metadata.hasPdbInfo = false;
            return metadata;
        }
        // The "virtual address"  needs to be converted into an offset from the begining of the PE file (like peHeaderOffset).
        // To be able to do that, we need to load the array of IMAGE_SECTION_HEADER that follows the optional header;
        // their count is given by the IMAGE_SECTION_HEADER.NumberOfSections field
        const sectionHeaders = yield getSectionHeaders(reader, peHeaderResult.peHeader);
        const debugDirectoriesOffset = rvaToOffset(debugSectionVirtualAddress, sectionHeaders);
        // look inside the different IMAGE_DEBUG_DIRECTORY
        const debugSectionBuffer = yield reader.read(debugSectionSize, debugDirectoriesOffset);
        const entryCount = debugSectionSize / pe_constants_1.IMAGE_DEBUG_DIRECTORY_SIZE;
        let entryOffset = 0;
        for (let i = 0; i < entryCount; i++) {
            const type = debugSectionBuffer.readUInt32LE(entryOffset + pe_constants_1.IMAGE_DEBUG_DIRECTORY_TYPE_OFFSET);
            if (type === pe_constants_1.IMAGE_DEBUG_TYPE_CODEVIEW) {
                const pdbInfoSizeOfData = debugSectionBuffer.readUInt32LE(entryOffset + pe_constants_1.IMAGE_DEBUG_DIRECTORY_SIZEOFDATA_OFFSET);
                const pdbInfoAddress = debugSectionBuffer.readUInt32LE(entryOffset + pe_constants_1.IMAGE_DEBUG_DIRECTORY_ADDRESSOFRAWDATA_OFFSET);
                const pdbInfoOffset = rvaToOffset(pdbInfoAddress, sectionHeaders);
                // we are insterested in the .pdb filename that goes beyond the CV_INFO_PDB70 structure
                const pdbInfoBuffer = yield reader.read(pdbInfoSizeOfData, pdbInfoOffset);
                const pdbSignature = pdbInfoBuffer.readUInt32LE(pe_constants_1.CV_INFO_SIGNATURE_OFFSET);
                if (pdbSignature === pe_constants_1.PDB70_SIGNATURE) {
                    metadata.hasPdbInfo = true;
                    metadata.pdbAge = pdbInfoBuffer.readUInt32LE(pe_constants_1.CV_INFO_AGE_OFFSET);
                    // read the GUID that spans 16 bytes and save it as
                    //     xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
                    metadata.pdbSig =
                        toHex(pdbInfoBuffer.readUInt32LE(pe_constants_1.CV_INFO_GUID_OFFSET), 8) +
                            '-' +
                            toHex(pdbInfoBuffer.readUInt16LE(pe_constants_1.CV_INFO_GUID_OFFSET + 4), 4) +
                            '-' +
                            toHex(pdbInfoBuffer.readUInt16LE(pe_constants_1.CV_INFO_GUID_OFFSET + 6), 4) +
                            '-' +
                            toHex(pdbInfoBuffer.readUInt16BE(pe_constants_1.CV_INFO_GUID_OFFSET + 8), 4) +
                            '-' +
                            toHex(pdbInfoBuffer.readUInt16BE(pe_constants_1.CV_INFO_GUID_OFFSET + 10), 4) +
                            toHex(pdbInfoBuffer.readUInt16BE(pe_constants_1.CV_INFO_GUID_OFFSET + 12), 4) +
                            toHex(pdbInfoBuffer.readUInt16BE(pe_constants_1.CV_INFO_GUID_OFFSET + 14), 4);
                    // read .pdb filename that follows in the structure
                    // --> read the characters up to pdbInfoSizeOfData
                    // this is not working maybe due to the \ that are replaced by \\
                    // const pdbFilename = pdbInfoBuffer.toString('utf-8', CV_INFO_PDB_FILENAME_OFFSET, pdbInfoSizeOfData - CV_INFO_PDB_FILENAME_OFFSET + 1)
                    let pdbFilename = '';
                    for (let j = pe_constants_1.CV_INFO_PDB_FILENAME_OFFSET; j < pdbInfoSizeOfData; j++) {
                        if (pdbInfoBuffer[j] === 0) {
                            break;
                        }
                        pdbFilename += String.fromCharCode(pdbInfoBuffer[j]);
                    }
                    metadata.pdbFilename = pdbFilename;
                }
                else {
                    metadata.hasPdbInfo = false;
                }
                return metadata;
            }
            entryOffset += pe_constants_1.IMAGE_DEBUG_DIRECTORY_SIZE;
        }
    }
    catch (error) {
        // console.log(error)
        if (error instanceof Error) {
            metadata.error = error;
        }
        else {
            throw error;
        }
    }
    finally {
        if (fileHandle) {
            yield fileHandle.close();
        }
    }
    return metadata;
});
exports.getPEFileMetadata = getPEFileMetadata;
const getBuildId = (fileMetadata) => {
    if (fileMetadata.isPE && fileMetadata.hasPdbInfo) {
        return `${fileMetadata.pdbSig}_${fileMetadata.pdbAge}`;
    }
    return '?_?';
};
exports.getBuildId = getBuildId;
//# sourceMappingURL=pe.js.map