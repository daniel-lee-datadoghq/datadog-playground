"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderUpload = exports.renderCommandInfo = exports.renderSuccessfulCommand = exports.renderFailedSourcesContentRemovalError = exports.renderRemoveSourcesContentWarning = exports.renderRetriedUpload = exports.renderFailedUpload = exports.renderConfigurationError = exports.renderSourcesNotFoundWarning = exports.renderGitDataNotAttachedWarning = exports.renderGitWarning = void 0;
const chalk_1 = __importDefault(require("chalk"));
const formatting_1 = require("../../helpers/formatting");
const upload_1 = require("../../helpers/upload");
const utils_1 = require("../../helpers/utils");
const renderGitWarning = (errorMessage) => chalk_1.default.yellow(`${formatting_1.ICONS.WARNING} An error occured while invoking git: ${errorMessage}
Make sure the command is running within your git repository to fully leverage Datadog's git integration.
To ignore this warning use the --disable-git flag.\n`);
exports.renderGitWarning = renderGitWarning;
const renderGitDataNotAttachedWarning = (sourcemap, errorMessage) => chalk_1.default.yellow(`${formatting_1.ICONS.WARNING} Could not attach git data for sourcemap ${sourcemap}: ${errorMessage}\n`);
exports.renderGitDataNotAttachedWarning = renderGitDataNotAttachedWarning;
const renderSourcesNotFoundWarning = (sourcemap) => chalk_1.default.yellow(`${formatting_1.ICONS.WARNING} No tracked files found for sources contained in ${sourcemap}\n`);
exports.renderSourcesNotFoundWarning = renderSourcesNotFoundWarning;
const renderConfigurationError = (error) => chalk_1.default.red(`${formatting_1.ICONS.FAILED} Configuration error: ${error}.\n`);
exports.renderConfigurationError = renderConfigurationError;
const renderFailedUpload = (sourcemap, errorMessage) => {
    const sourcemapPathBold = `[${chalk_1.default.bold.dim(sourcemap.sourcemapPath)}]`;
    let message = chalk_1.default.red(`${formatting_1.ICONS.FAILED} Failed upload sourcemap for ${sourcemapPathBold}: ${errorMessage}\n`);
    if (errorMessage.includes('413 (Request Entity Too Large)')) {
        message = `${message}\n It looks like your sourcemap is too large. To make it lighter you can:
    - Pass an empty file as --bundle argument to the upload command (no impact on the error explorer as of now)
    - Pass the --remove-sources-content argument to the upload command (you will lose the code snippet next to the unminified error)
    - Try to split your bundle, by using a tool such as repack (https://github.com/callstack/repack)\n`;
    }
    return message;
};
exports.renderFailedUpload = renderFailedUpload;
const renderRetriedUpload = (payload, errorMessage, attempt) => {
    const sourcemapPathBold = `[${chalk_1.default.bold.dim(payload.sourcemapPath)}]`;
    return chalk_1.default.yellow(`[attempt ${attempt}] Retrying sourcemap upload ${sourcemapPathBold}: ${errorMessage}\n`);
};
exports.renderRetriedUpload = renderRetriedUpload;
const renderRemoveSourcesContentWarning = () => `Removing the "sourcesContent" part of the sourcemap file. ${chalk_1.default.yellow('Use the --remove-sources-content only if your sourcemap file is too heavy to upload to Datadog.\n')}`;
exports.renderRemoveSourcesContentWarning = renderRemoveSourcesContentWarning;
const renderFailedSourcesContentRemovalError = (payload, errorMessage) => `${chalk_1.default.red(`An error occured while removing the "sourcesContent" part of the sourcemap file ${payload.sourcemapPath}": ${errorMessage}`)}.
  Trying to upload the full sourcemap with the "sourcesContent".`;
exports.renderFailedSourcesContentRemovalError = renderFailedSourcesContentRemovalError;
/**
 * As of now, this command takes an array of one signe UploadStatus element since we only support upload
 * of a single sourcemap.
 * We considered it was preferable to leave it this way so it's ready for multiple sourcemaps uploads,
 * rather than investing into adapting it for this purpose.
 * This comment should be removed once the multiple file upload is available.
 */
const renderSuccessfulCommand = (statuses, duration, dryRun) => {
    const results = new Map();
    statuses.forEach((status) => {
        if (!results.has(status)) {
            results.set(status, 0);
        }
        results.set(status, results.get(status) + 1);
    });
    const output = ['', chalk_1.default.bold('Command summary:')];
    if (results.get(upload_1.UploadStatus.Failure)) {
        output.push(chalk_1.default.red(`${formatting_1.ICONS.FAILED} Some sourcemaps have not been uploaded correctly.`));
    }
    else if (results.get(upload_1.UploadStatus.Skipped)) {
        output.push(chalk_1.default.yellow(`${formatting_1.ICONS.WARNING}  Some sourcemaps have been skipped.`));
    }
    else if (results.get(upload_1.UploadStatus.Success)) {
        if (dryRun) {
            output.push(chalk_1.default.green(`${formatting_1.ICONS.SUCCESS} [DRYRUN] Handled ${(0, utils_1.pluralize)(results.get(upload_1.UploadStatus.Success), 'sourcemap', 'sourcemaps')} with success in ${duration} seconds.`));
        }
        else {
            output.push(chalk_1.default.green(`${formatting_1.ICONS.SUCCESS} Uploaded ${(0, utils_1.pluralize)(results.get(upload_1.UploadStatus.Success), 'sourcemap', 'sourcemaps')} in ${duration} seconds.`));
        }
    }
    else {
        output.push(chalk_1.default.yellow(`${formatting_1.ICONS.WARNING} No sourcemaps detected. Did you specify the correct path?`));
    }
    if (results.get(upload_1.UploadStatus.Failure) || results.get(upload_1.UploadStatus.Skipped)) {
        output.push(`Details about the ${(0, utils_1.pluralize)(statuses.length, 'found sourcemap', 'found sourcemaps')}:`);
        if (results.get(upload_1.UploadStatus.Success)) {
            output.push(`  * ${(0, utils_1.pluralize)(results.get(upload_1.UploadStatus.Success), 'sourcemap', 'sourcemaps')} successfully uploaded`);
        }
        if (results.get(upload_1.UploadStatus.Skipped)) {
            output.push(chalk_1.default.yellow(`  * ${(0, utils_1.pluralize)(results.get(upload_1.UploadStatus.Skipped), 'sourcemap was', 'sourcemaps were')} skipped`));
        }
        if (results.get(upload_1.UploadStatus.Failure)) {
            output.push(chalk_1.default.red(`  * ${(0, utils_1.pluralize)(results.get(upload_1.UploadStatus.Failure), 'sourcemap', 'sourcemaps')} failed to upload`));
        }
    }
    return output.join('\n') + '\n';
};
exports.renderSuccessfulCommand = renderSuccessfulCommand;
const renderCommandInfo = (bundlePath, sourcemapPath, platform, releaseVersion, service, poolLimit, dryRun, projectPath, buildVersion, bundleName) => {
    let fullStr = '';
    if (dryRun) {
        fullStr += chalk_1.default.yellow(`${formatting_1.ICONS.WARNING} DRY-RUN MODE ENABLED. WILL NOT UPLOAD SOURCEMAPS\n`);
    }
    const startStr = chalk_1.default.green('Starting upload. \n');
    fullStr += startStr;
    if (!bundlePath) {
        fullStr += chalk_1.default.red(`${formatting_1.ICONS.WARNING} --bundle option was not provided. A default bundle name will be used. Please update @datadog/mobile-react-native or pass a --bundle option.\n`);
    }
    fullStr += chalk_1.default.green(`Upload of ${sourcemapPath} for bundle ${bundleName} on platform ${platform} with project path ${projectPath}\n`);
    const serviceVersionProjectPathStr = chalk_1.default.green(`version: ${releaseVersion} build: ${buildVersion} service: ${service}\n`);
    fullStr += serviceVersionProjectPathStr;
    fullStr += chalk_1.default.green(`Please ensure you use the same values during SDK initialization to guarantee the success of the unminify process.\n`);
    fullStr += chalk_1.default.green(`After upload is successful sourcemap files will be processed and ready to use within the next 5 minutes. \n`);
    return fullStr;
};
exports.renderCommandInfo = renderCommandInfo;
const renderUpload = (sourcemap) => `Uploading sourcemap ${sourcemap.sourcemapPath} for JS file ${sourcemap.bundleName}\n`;
exports.renderUpload = renderUpload;
//# sourceMappingURL=renderer.js.map