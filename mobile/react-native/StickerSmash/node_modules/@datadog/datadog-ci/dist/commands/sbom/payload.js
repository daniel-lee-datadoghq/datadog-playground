"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatePayload = void 0;
const console = __importStar(require("console"));
const crypto_1 = __importDefault(require("crypto"));
const tags_1 = require("../../helpers/tags");
const constants_1 = require("./constants");
const language_1 = require("./language");
// Parse a location from the file generated by osv-scanner into a location that can be
// sent to our API.
const parseLocation = (location) => {
    if (!location) {
        return undefined;
    }
    if (!location.file_name ||
        !location.line_start ||
        !location.line_end ||
        !location.column_start ||
        !location.column_end) {
        return undefined;
    }
    if (location.line_end < location.line_start) {
        return undefined;
    }
    if (location.line_end === location.line_start && location.column_end <= location.column_start) {
        return undefined;
    }
    // check location values
    if (location.line_start <= 0 || location.line_end <= 0 || location.column_start <= 0 || location.column_end <= 0) {
        return undefined;
    }
    return {
        file_name: location.file_name,
        start: {
            line: location.line_start,
            col: location.column_start,
        },
        end: {
            line: location.line_end,
            col: location.column_end,
        },
    };
};
// Parse all locations from the OSV scanner. If one fails to be parse, it's set to undefined
const parseLocationsString = (locations) => {
    try {
        const parsed = JSON.parse(locations);
        const res = {
            block: parseLocation(parsed['block']),
            namespace: parseLocation(parsed['namespace']),
            name: parseLocation(parsed['name']),
            version: parseLocation(parsed['version']),
        };
        // if block is not defined, the API fails and we should rather ignore the payload
        if (!res.block) {
            return undefined;
        }
        return res;
    }
    catch (e) {
        console.error(`error when parsing locations: ${e}`);
    }
    return undefined;
};
// Generate the payload we send to the API
// jsonContent is the SBOM file content read from disk
// tags are the list of tags we retrieved
const generatePayload = (jsonContent, tags, service, env) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const dependencies = [];
    const files = [];
    const relations = [];
    const vulnerabilities = [];
    if (jsonContent) {
        // If the tool generator for SBOM creation is not already defined by the user,
        // attempt to determine it from the metadata attribute.
        if (!tags[tags_1.SBOM_TOOL_GENERATOR_NAME]) {
            const generationTool = getGenerationTool(jsonContent);
            if (generationTool) {
                tags[tags_1.SBOM_TOOL_GENERATOR_NAME] = generationTool.name;
                tags[tags_1.SBOM_TOOL_GENERATOR_VERSION] = generationTool.version;
            }
        }
        if (jsonContent['components']) {
            for (const component of jsonContent['components']) {
                if (!component['type'] || !component['name']) {
                    continue;
                }
                if (component['type'] === 'library' || component['type'] === 'framework') {
                    const dependency = extractingDependency(component);
                    if (dependency !== undefined) {
                        dependencies.push(dependency);
                    }
                }
                else if (component['type'] === 'file') {
                    files.push(extractingFile(component));
                }
            }
        }
        if (jsonContent['dependencies']) {
            for (const dependency of jsonContent['dependencies']) {
                if (!dependency['ref'] || !dependency['dependsOn']) {
                    continue;
                }
                relations.push(extractingRelations(dependency));
            }
        }
        if (jsonContent['vulnerabilities']) {
            for (const vulnerability of jsonContent['vulnerabilities']) {
                if (!vulnerability['id'] || !vulnerability['bom-ref']) {
                    continue;
                }
                const affects = [];
                // Iterate over the affects of the vulnerability when it exists
                if (vulnerability['affects']) {
                    for (const affected of vulnerability['affects']) {
                        if (!affected['ref']) {
                            continue;
                        }
                        affects.push({
                            ref: affected['ref'],
                        });
                    }
                }
                vulnerabilities.push({
                    id: vulnerability['id'],
                    bom_ref: vulnerability['bom-ref'],
                    affects,
                });
            }
        }
    }
    // The tags dictionary is validated prior to generatePayload being called
    //  see upload.ts missingGitFields
    return {
        id: crypto_1.default.randomUUID(),
        commit: {
            author_name: (_a = tags[tags_1.GIT_COMMIT_AUTHOR_NAME]) !== null && _a !== void 0 ? _a : '',
            author_email: (_b = tags[tags_1.GIT_COMMIT_AUTHOR_EMAIL]) !== null && _b !== void 0 ? _b : '',
            committer_name: (_c = tags[tags_1.GIT_COMMIT_COMMITTER_NAME]) !== null && _c !== void 0 ? _c : '',
            committer_email: (_d = tags[tags_1.GIT_COMMIT_COMMITTER_EMAIL]) !== null && _d !== void 0 ? _d : '',
            sha: (_e = tags[tags_1.GIT_SHA]) !== null && _e !== void 0 ? _e : '',
            branch: (_f = tags[tags_1.GIT_BRANCH]) !== null && _f !== void 0 ? _f : '',
        },
        repository: {
            url: (_g = tags[tags_1.GIT_REPOSITORY_URL]) !== null && _g !== void 0 ? _g : '',
        },
        tags,
        dependencies,
        files,
        relations,
        vulnerabilities,
        service,
        env,
    };
};
exports.generatePayload = generatePayload;
const extractingDependency = (component) => {
    var _a;
    const lang = (0, language_1.getLanguageFromComponent)(component);
    if (!lang) {
        return;
    }
    const purl = component['purl'];
    if (!purl) {
        console.error(`cannot find purl for component ${component['name']}`);
        return;
    }
    const locations = [];
    // Extract the unique location strings from the file.
    const locationsStrings = new Set();
    if (component['evidence'] && component['evidence']['occurrences']) {
        for (const occ of component['evidence']['occurrences']) {
            if (occ['location']) {
                const loc = occ['location'];
                if (!locationsStrings.has(loc)) {
                    locationsStrings.add(loc);
                }
            }
        }
    }
    for (const l of locationsStrings) {
        const loc = parseLocationsString(l);
        if (loc) {
            locations.push(loc);
        }
    }
    let packageManager = '';
    let isDirect;
    let isDev;
    const exclusions = [];
    const reachableSymbolProperties = [];
    for (const property of (_a = component['properties']) !== null && _a !== void 0 ? _a : []) {
        if (property['name'] === constants_1.PACKAGE_MANAGER_PROPERTY_KEY) {
            packageManager = property['value'];
        }
        else if (property['name'] === constants_1.IS_DEPENDENCY_DIRECT_PROPERTY_KEY) {
            isDirect = property['value'].toLowerCase() === 'true' ? true : undefined;
        }
        else if (property['name'] === constants_1.IS_DEPENDENCY_DEV_ENVIRONMENT_PROPERTY_KEY) {
            isDev = property['value'].toLowerCase() === 'true' ? true : undefined;
        }
        else if (property['name'] === constants_1.EXCLUSION_KEY) {
            exclusions.push(property['value']);
        }
        else if (property['name'].startsWith(constants_1.REACHABLE_SYMBOL_LOCATION_KEY_PREFIX)) {
            const missingKeys = validateReachableSymbolLocationValue(property['value']);
            if (missingKeys.length > 0) {
                console.error(`Error in reachable symbol locations for ${purl}:`);
                for (const key of missingKeys) {
                    console.error(`- ${key} is missing`);
                }
                continue;
            }
            reachableSymbolProperties.push({
                name: property['name'],
                value: property['value'],
            });
        }
    }
    const dependency = {
        name: component['name'],
        group: component['group'] || undefined,
        version: component['version'] || undefined,
        language: lang,
        licenses: [],
        purl,
        locations,
        is_direct: isDirect,
        is_dev: isDev,
        package_manager: packageManager,
        reachable_symbol_properties: reachableSymbolProperties,
        exclusions,
    };
    return dependency;
};
const extractingFile = (component) => {
    var _a;
    let purl;
    for (const property of (_a = component['properties']) !== null && _a !== void 0 ? _a : []) {
        if (property['name'] === constants_1.FILE_PACKAGE_PROPERTY_KEY) {
            purl = property['value'];
        }
    }
    return {
        name: component['name'],
        purl,
    };
};
const extractingRelations = (dependency) => {
    return {
        component_ref: dependency['ref'],
        depends_on: dependency['dependsOn'],
    };
};
const getGenerationTool = (jsonContent) => {
    var _a;
    const tools = (_a = jsonContent === null || jsonContent === void 0 ? void 0 : jsonContent.metadata) === null || _a === void 0 ? void 0 : _a.tools;
    // CycloneDX 1.4 defines tools as an array:
    // https://cyclonedx.org/docs/1.4/json/#metadata_tools
    if (Array.isArray(tools)) {
        return extractGenerationTool(tools[0]);
        // CycloneDX > 1.5 defines tools as an object
        // https://cyclonedx.org/docs/1.5/json/#metadata_tools
    }
    else if (typeof tools === 'object') {
        const preferredTool = findPreferredTool(tools);
        return extractGenerationTool(preferredTool);
    }
    return undefined;
};
const findPreferredTool = (tool) => {
    if (tool.components && Array.isArray(tool.components)) {
        // Prefer components of type 'application', as from experience,
        // that's where sbom generators report their name.
        const applicationComponent = tool.components.find((component) => component.type === 'application');
        if (applicationComponent) {
            return applicationComponent;
        }
        // If no application component, return the first component
        return tool.components[0];
    }
    return tool;
};
const extractGenerationTool = (tool) => {
    return {
        name: tool['name'],
        version: tool['version'],
    };
};
// validateReachableSymbolLocationValue checks if the JSON string value in
// the reachable symbol location is valid and returns any keys that were missing.
const validateReachableSymbolLocationValue = (value) => {
    const missingKeys = [];
    const parsedVals = JSON.parse(value);
    for (const parsedVal of parsedVals) {
        if (!parsedVal.file_name) {
            missingKeys.push('file_name');
        }
        if (!parsedVal.line_start) {
            missingKeys.push('line_start');
        }
        if (!parsedVal.line_end) {
            missingKeys.push('line_end');
        }
        if (!parsedVal.column_start) {
            missingKeys.push('column_start');
        }
        if (!parsedVal.column_end) {
            missingKeys.push('column_end');
        }
        if (!parsedVal.symbol) {
            missingKeys.push('symbol');
        }
    }
    return missingKeys;
};
//# sourceMappingURL=payload.js.map