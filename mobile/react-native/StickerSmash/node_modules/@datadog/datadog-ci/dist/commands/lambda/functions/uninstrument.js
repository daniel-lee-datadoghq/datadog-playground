"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateUpdateRequest = exports.getUninstrumentedFunctionConfigsFromRegEx = exports.getUninstrumentedFunctionConfig = exports.getUninstrumentedFunctionConfigs = void 0;
const constants_1 = require("../../../constants");
const constants_2 = require("../constants");
const loggroup_1 = require("../loggroup");
const tags_1 = require("../tags");
const commons_1 = require("./commons");
const getUninstrumentedFunctionConfigs = (lambdaClient, cloudWatchLogsClient, functionARNs, forwarderARN) => __awaiter(void 0, void 0, void 0, function* () {
    const lambdaFunctionConfigs = yield (0, commons_1.getLambdaFunctionConfigs)(lambdaClient, functionARNs);
    const configs = [];
    for (const config of lambdaFunctionConfigs) {
        const functionConfig = yield (0, exports.getUninstrumentedFunctionConfig)(lambdaClient, cloudWatchLogsClient, config, forwarderARN);
        configs.push(functionConfig);
    }
    return configs;
});
exports.getUninstrumentedFunctionConfigs = getUninstrumentedFunctionConfigs;
const getUninstrumentedFunctionConfig = (lambdaClient, cloudWatchLogsClient, config, forwarderARN) => __awaiter(void 0, void 0, void 0, function* () {
    const functionARN = config.FunctionArn;
    const runtime = config.Runtime;
    if (!(0, commons_1.isSupportedRuntime)(runtime)) {
        throw Error(`Can't un-instrument ${functionARN}, runtime ${runtime} not supported`);
    }
    const updateRequest = (0, exports.calculateUpdateRequest)(config, runtime);
    let logGroupConfiguration;
    if (forwarderARN) {
        const logGroupName = `/aws/lambda/${config.FunctionName}`;
        logGroupConfiguration = yield (0, loggroup_1.calculateLogGroupRemoveRequest)(cloudWatchLogsClient, logGroupName, forwarderARN);
    }
    const tagConfiguration = yield (0, tags_1.calculateTagRemoveRequest)(lambdaClient, functionARN);
    return {
        functionARN,
        lambdaConfig: config,
        logGroupConfiguration,
        tagConfiguration,
        updateFunctionConfigurationCommandInput: updateRequest,
    };
});
exports.getUninstrumentedFunctionConfig = getUninstrumentedFunctionConfig;
const getUninstrumentedFunctionConfigsFromRegEx = (lambdaClient, cloudWatchLogsClient, pattern, forwarderArn) => __awaiter(void 0, void 0, void 0, function* () {
    const matchedFunctions = yield (0, commons_1.getLambdaFunctionConfigsFromRegex)(lambdaClient, pattern);
    const functionsToUpdate = [];
    for (const config of matchedFunctions) {
        const functionConfig = yield (0, exports.getUninstrumentedFunctionConfig)(lambdaClient, cloudWatchLogsClient, config, forwarderArn);
        functionsToUpdate.push(functionConfig);
    }
    return functionsToUpdate;
});
exports.getUninstrumentedFunctionConfigsFromRegEx = getUninstrumentedFunctionConfigsFromRegEx;
const calculateUpdateRequest = (config, runtime) => {
    var _a, _b;
    const oldEnvVars = Object.assign({}, (_a = config.Environment) === null || _a === void 0 ? void 0 : _a.Variables);
    const functionARN = config.FunctionArn;
    if (functionARN === undefined) {
        return undefined;
    }
    const updateRequest = {
        FunctionName: functionARN,
    };
    let needsUpdate = false;
    const runtimeType = constants_2.RUNTIME_LOOKUP[runtime];
    // Remove Handler for Python
    if (runtimeType === constants_2.RuntimeType.PYTHON) {
        const expectedHandler = constants_2.PYTHON_HANDLER_LOCATION;
        if (config.Handler === expectedHandler) {
            needsUpdate = true;
            updateRequest.Handler = oldEnvVars[constants_2.LAMBDA_HANDLER_ENV_VAR];
            delete oldEnvVars[constants_2.LAMBDA_HANDLER_ENV_VAR];
        }
    }
    // Remove Handler for Node
    if (runtimeType === constants_2.RuntimeType.NODE) {
        const expectedHandler = constants_2.NODE_HANDLER_LOCATION;
        if (config.Handler === expectedHandler) {
            needsUpdate = true;
            updateRequest.Handler = oldEnvVars[constants_2.LAMBDA_HANDLER_ENV_VAR];
            delete oldEnvVars[constants_2.LAMBDA_HANDLER_ENV_VAR];
        }
    }
    // Remove AWS_LAMBDA_EXEC_WRAPPER for .NET and Java or if ASM is enabled
    if (runtimeType === constants_2.RuntimeType.DOTNET ||
        runtimeType === constants_2.RuntimeType.JAVA ||
        oldEnvVars[constants_2.APPSEC_ENABLED_ENV_VAR] === 'true') {
        if (oldEnvVars[constants_2.AWS_LAMBDA_EXEC_WRAPPER_VAR] === constants_2.AWS_LAMBDA_EXEC_WRAPPER) {
            needsUpdate = true;
            delete oldEnvVars[constants_2.AWS_LAMBDA_EXEC_WRAPPER_VAR];
        }
    }
    /**
     * Array used to remove environment vars used in
     * the Lambda environment.
     */
    const environmentVarsArray = [
        constants_1.API_KEY_ENV_VAR,
        constants_2.API_KEY_SECRET_ARN_ENV_VAR,
        constants_2.KMS_API_KEY_ENV_VAR,
        constants_1.SITE_ENV_VAR,
        constants_2.APM_FLUSH_DEADLINE_MILLISECONDS_ENV_VAR,
        constants_2.APPSEC_ENABLED_ENV_VAR,
        constants_2.CAPTURE_LAMBDA_PAYLOAD_ENV_VAR,
        constants_1.ENVIRONMENT_ENV_VAR,
        constants_1.DD_TAGS_ENV_VAR,
        constants_2.FLUSH_TO_LOG_ENV_VAR,
        constants_2.MERGE_XRAY_TRACES_ENV_VAR,
        constants_1.DD_LOG_LEVEL_ENV_VAR,
        constants_2.LOG_ENABLED_ENV_VAR,
        constants_1.SERVICE_ENV_VAR,
        constants_1.DD_TRACE_ENABLED_ENV_VAR,
        constants_1.VERSION_ENV_VAR,
        constants_2.ENABLE_PROFILING_ENV_VAR,
        constants_2.PROFILER_ENV_VAR,
        constants_2.PROFILER_PATH_ENV_VAR,
        constants_2.DOTNET_TRACER_HOME_ENV_VAR,
        constants_1.DD_LLMOBS_ENABLED_ENV_VAR,
        constants_1.DD_LLMOBS_ML_APP_ENV_VAR,
        constants_1.DD_LLMOBS_AGENTLESS_ENABLED_ENV_VAR,
        constants_2.DD_LAMBDA_FIPS_MODE_ENV_VAR,
    ];
    // Remove Environment Variables
    for (const environmentVar of environmentVarsArray) {
        if (oldEnvVars[environmentVar]) {
            needsUpdate = true;
            delete oldEnvVars[environmentVar];
        }
    }
    updateRequest.Environment = {
        Variables: oldEnvVars,
    };
    // Remove Layers
    let needsLayerRemoval = false;
    const lambdaLibraryLayerName = constants_2.LAYER_LOOKUP[runtime];
    const originalLayerARNs = (0, commons_1.getLayers)(config);
    const layerARNs = ((_b = config.Layers) !== null && _b !== void 0 ? _b : [])
        .filter((layer) => { var _a, _b; return !((_a = layer.Arn) === null || _a === void 0 ? void 0 : _a.includes(lambdaLibraryLayerName)) && !((_b = layer.Arn) === null || _b === void 0 ? void 0 : _b.includes(constants_2.DD_LAMBDA_EXTENSION_LAYER_NAME)); })
        .map((layer) => { var _a; return (_a = layer.Arn) !== null && _a !== void 0 ? _a : ''; });
    if (originalLayerARNs.sort().join(',') !== layerARNs.sort().join(',')) {
        needsLayerRemoval = true;
    }
    if (needsLayerRemoval) {
        needsUpdate = true;
        updateRequest.Layers = layerARNs;
    }
    return needsUpdate ? updateRequest : undefined;
};
exports.calculateUpdateRequest = calculateUpdateRequest;
//# sourceMappingURL=uninstrument.js.map