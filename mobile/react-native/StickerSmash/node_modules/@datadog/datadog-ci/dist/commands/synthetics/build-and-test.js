"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAssets = exports.MalformedBuildError = exports.UnconfiguredBuildPluginError = void 0;
const child_process_1 = require("child_process");
const events_1 = require("events");
const fs_1 = require("fs");
const http_1 = __importDefault(require("http"));
const upath_1 = __importDefault(require("upath"));
const REPORT_BUILD_PATHNAME = '/_datadog-ci_/build';
exports.UnconfiguredBuildPluginError = new Error(`
We couldn't detect the Datadog Build plugins within your build. Did you add it?
If not, you can learn more about it here: https://github.com/DataDog/build-plugins#readme
`);
exports.MalformedBuildError = new Error(`Invalid payload. Expected payload is {\"outputDirectory\": string, \"publicPath\": string}`);
const MIME_TYPES = {
    default: 'application/octet-stream',
    html: 'text/html; charset=UTF-8',
    js: 'application/javascript',
    css: 'text/css',
    png: 'image/png',
    jpg: 'image/jpg',
    gif: 'image/gif',
    ico: 'image/x-icon',
    svg: 'image/svg+xml',
};
const isMIMEType = (mime) => {
    return Object.keys(MIME_TYPES).includes(mime);
};
const routeVerbs = ['get', 'post', 'put', 'patch', 'delete'];
const isRouteVerb = (verb) => {
    return routeVerbs.includes(verb);
};
const fileExists = (filePath) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield fs_1.promises.access(filePath);
        return true;
    }
    catch (_a) {
        return false;
    }
});
const prepareFile = (root = process.cwd(), builds, requestUrl) => __awaiter(void 0, void 0, void 0, function* () {
    const staticPath = upath_1.default.isAbsolute(root) ? root : upath_1.default.resolve(process.cwd(), root);
    for (const build of builds) {
        if (requestUrl.startsWith(build.publicPath)) {
            const url = new URL(requestUrl, 'http://127.0.0.1');
            const filePath = upath_1.default.join(upath_1.default.resolve(staticPath, build.outputDirectory), // absolute path to the assets directory
            upath_1.default.relative(build.publicPath, url.pathname), // relative path to the file
            url.pathname.endsWith('/') ? 'index.html' : '' // add index.html if the path ends with a slash
            );
            // Verify path is within the intended directory
            const directDescendant = filePath.startsWith(upath_1.default.resolve(staticPath, build.outputDirectory));
            // Check if the file exists (only if it's withing the intended directory)
            const found = directDescendant && (yield fileExists(filePath));
            if (directDescendant && found) {
                return {
                    found: true,
                    ext: upath_1.default.extname(filePath).substring(1).toLowerCase(),
                    content: yield fs_1.promises.readFile(filePath, { encoding: 'utf-8' }),
                };
            }
        }
    }
    return {
        found: false,
    };
});
const getRequestHandler = ({ builds, root, routes }) => (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    var _b, _c;
    try {
        // Handle routes.
        const route = routes === null || routes === void 0 ? void 0 : routes[req.url || '/'];
        if (route) {
            const verb = (_c = (_b = req.method) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== null && _c !== void 0 ? _c : '';
            if (isRouteVerb(verb)) {
                const handler = route[verb];
                if (handler) {
                    yield handler(req, res);
                    return;
                }
            }
        }
        // Fallback to files.
        const file = yield prepareFile(root, builds, req.url || '/');
        if (file.found) {
            const mimeType = isMIMEType(file.ext) ? MIME_TYPES[file.ext] : MIME_TYPES.default;
            res.writeHead(200, { 'Content-Type': mimeType });
            res.end(file.content);
            return;
        }
        res.writeHead(404);
        res.end();
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        res.writeHead(500, { 'Content-Type': MIME_TYPES.html });
        res.end(`Internal Server Error: ${errorMessage}`);
    }
});
const getRequestBody = (req) => __awaiter(void 0, void 0, void 0, function* () {
    const chunks = [];
    req.on('data', (chunk) => chunks.push(chunk));
    yield (0, events_1.once)(req, 'end');
    return chunks.join('');
});
const getReportedBuild = (payload) => {
    const reportedBuild = JSON.parse(payload);
    if ('outputDirectory' in reportedBuild &&
        typeof reportedBuild.outputDirectory === 'string' &&
        'publicPath' in reportedBuild &&
        typeof reportedBuild.publicPath === 'string') {
        return reportedBuild;
    }
    throw exports.MalformedBuildError;
};
const spawnDevServer = () => __awaiter(void 0, void 0, void 0, function* () {
    const builds = [];
    const requestHandler = getRequestHandler({
        builds,
        root: process.cwd(),
        routes: {
            [REPORT_BUILD_PATHNAME]: {
                post: (req, res) => __awaiter(void 0, void 0, void 0, function* () {
                    const body = yield getRequestBody(req);
                    const reportedBuild = getReportedBuild(body);
                    builds.push(reportedBuild);
                    res.end();
                }),
            },
        },
    });
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    const server = http_1.default.createServer(requestHandler);
    server.listen();
    yield (0, events_1.once)(server, 'listening');
    return { builds, server, url: getBuildReportUrl(server) };
});
const buildAssets = (buildCommand, reporter) => __awaiter(void 0, void 0, void 0, function* () {
    var _d, _e, _f, _g;
    const { builds, server, url } = yield spawnDevServer();
    // Spawn the build command process with the BUILD_PLUGINS_S8S_PORT environment variable.
    const buildCommandProcess = (0, child_process_1.spawn)(buildCommand, [], {
        env: Object.assign({ DATADOG_SYNTHETICS_REPORT_BUILD_URL: url }, process.env),
        shell: (_e = (_d = process.env.SHELL) !== null && _d !== void 0 ? _d : process.env.ComSpec) !== null && _e !== void 0 ? _e : true,
    });
    (_f = buildCommandProcess.stdout) === null || _f === void 0 ? void 0 : _f.pipe(process.stdout);
    (_g = buildCommandProcess.stderr) === null || _g === void 0 ? void 0 : _g.pipe(process.stderr);
    // Wait for the build command to finish
    yield (0, events_1.once)(buildCommandProcess, 'close');
    if (builds.length === 0) {
        yield stopDevServer(server);
        throw exports.UnconfiguredBuildPluginError;
    }
    // Once the build server is ready, return its URL with the advertised public prefix to run the tests against it.
    return {
        builds,
        devServerUrl: url,
        stop: () => __awaiter(void 0, void 0, void 0, function* () { return stopDevServer(server); }),
    };
});
exports.buildAssets = buildAssets;
const getBuildReportUrl = (server) => {
    var _a;
    // net.Server can be listening on a named pipe, in which case the address is a string
    // or not listening yet, in which case the address is null, which we cast to the 'undefined' string
    // to meet the same condition as if it was a named pipe, and throw.
    const serverAddress = (_a = server.address()) !== null && _a !== void 0 ? _a : 'undefined';
    if (typeof serverAddress === 'string') {
        throw new Error('Server address is not valid');
    }
    const url = new URL(serverAddress.family === 'IPv6'
        ? `http://[${serverAddress.address}]:${serverAddress.port}`
        : `http://${serverAddress.address}:${serverAddress.port}`);
    url.pathname = REPORT_BUILD_PATHNAME;
    return url.href;
};
const stopDevServer = (server) => __awaiter(void 0, void 0, void 0, function* () {
    if (server.listening) {
        const serverClosed = (0, events_1.once)(server, 'close');
        server.close();
        yield serverClosed;
    }
});
//# sourceMappingURL=build-and-test.js.map