"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.executeWithDetails = exports.getTriggerConfigs = exports.executeTests = exports.getDefaultConfig = void 0;
const ci_1 = require("../../helpers/ci");
const tags_1 = require("../../helpers/tags");
const utils_1 = require("../../helpers/utils");
const api_1 = require("./api");
const base_command_1 = require("./base-command");
const batch_1 = require("./batch");
const errors_1 = require("./errors");
const multilocator_1 = require("./multilocator");
const default_1 = require("./reporters/default");
const junit_1 = require("./reporters/junit");
const test_1 = require("./test");
const tunnel_1 = require("./tunnel");
const internal_1 = require("./utils/internal");
const public_1 = require("./utils/public");
const getDefaultConfig = () => {
    return Object.assign(Object.assign({}, base_command_1.BaseCommand.getDefaultConfig()), { batchTimeout: batch_1.DEFAULT_BATCH_TIMEOUT, defaultTestOverrides: {}, failOnCriticalErrors: false, failOnMissingTests: false, failOnTimeout: true, files: [], jUnitReport: '', publicIds: [], subdomain: 'app', testSearchQuery: '', tunnel: false });
};
exports.getDefaultConfig = getDefaultConfig;
const executeTests = (reporter, config, suites) => __awaiter(void 0, void 0, void 0, function* () {
    const api = (0, api_1.getApiHelper)(config);
    let tunnel;
    let triggerConfigs = [];
    const stopTunnel = () => __awaiter(void 0, void 0, void 0, function* () {
        if (tunnel) {
            yield tunnel.stop();
        }
    });
    try {
        triggerConfigs = yield (0, exports.getTriggerConfigs)(api, config, reporter, suites);
    }
    catch (error) {
        throw new errors_1.CriticalError((0, api_1.isForbiddenError)(error) ? 'AUTHORIZATION_ERROR' : 'UNAVAILABLE_TEST_CONFIG', error.message);
    }
    let hasLTD = false;
    for (const triggerConfig of triggerConfigs) {
        if ((0, internal_1.isLocalTriggerConfig)(triggerConfig)) {
            hasLTD = true;
            break;
        }
    }
    if (triggerConfigs.length === 0) {
        throw new errors_1.CiError('NO_TESTS_TO_RUN');
    }
    let testsToTriggerResult;
    try {
        const triggerFromSearch = !!config.testSearchQuery;
        testsToTriggerResult = yield (0, test_1.getTestsToTrigger)(api, triggerConfigs, reporter, triggerFromSearch, config.failOnMissingTests, config.tunnel);
    }
    catch (error) {
        if (error instanceof errors_1.CiError) {
            throw error;
        }
        throw new errors_1.CriticalError((0, api_1.isForbiddenError)(error) ? 'AUTHORIZATION_ERROR' : 'UNAVAILABLE_TEST_CONFIG', error.message);
    }
    const { tests, overriddenTestsToTrigger, initialSummary } = testsToTriggerResult;
    // All tests have been skipped or are missing.
    if (!tests.length) {
        throw new errors_1.CiError('NO_TESTS_TO_RUN');
    }
    const publicIdsToTrigger = tests.flatMap(({ public_id }) => (public_id ? [public_id] : []));
    if (config.tunnel) {
        let presignedURL;
        try {
            // Get the pre-signed URL to connect to the tunnel service
            presignedURL = (yield api.getTunnelPresignedURL(publicIdsToTrigger)).url;
        }
        catch (error) {
            throw new errors_1.CriticalError('UNAVAILABLE_TUNNEL_CONFIG', error.message);
        }
        // Open a tunnel to Datadog
        try {
            const tunnelProxyAgent = (0, utils_1.getProxyAgent)(config.proxy);
            const tunnelReporter = (0, default_1.getTunnelReporter)(reporter);
            tunnel = new tunnel_1.Tunnel(presignedURL, publicIdsToTrigger, tunnelProxyAgent, tunnelReporter);
            const tunnelInfo = yield tunnel.start();
            overriddenTestsToTrigger.forEach((testToTrigger) => {
                testToTrigger.tunnel = tunnelInfo;
            });
        }
        catch (error) {
            yield stopTunnel();
            throw new errors_1.CriticalError('TUNNEL_START_FAILED', error.message);
        }
    }
    const metadata = (0, ci_1.getCIMetadata)({
        [tags_1.GIT_COMMIT_MESSAGE]: 500,
    });
    let trigger;
    try {
        trigger = yield (0, batch_1.runTests)(api, overriddenTestsToTrigger, reporter, metadata, config.failOnMissingTests, config.selectiveRerun, config.batchTimeout);
        // Update summary
        const cannotRead = initialSummary.testsNotAuthorized;
        const cannotWrite = trigger.testsNotAuthorized;
        initialSummary.testsNotAuthorized = new Set([...cannotRead, ...cannotWrite]);
        initialSummary.metadata = metadata;
    }
    catch (error) {
        yield stopTunnel();
        if (error instanceof errors_1.CiError) {
            throw error;
        }
        throw new errors_1.CriticalError('TRIGGER_TESTS_FAILED', error.message);
    }
    if (trigger.selectiveRerunRateLimited) {
        reporter.error('The selective rerun feature was rate-limited. All tests will be re-run.\n\n');
    }
    try {
        const { datadogSite, failOnCriticalErrors, failOnTimeout, subdomain } = config;
        const batchTimeout = config.batchTimeout || batch_1.DEFAULT_BATCH_TIMEOUT;
        const results = yield (0, batch_1.waitForResults)(api, trigger, tests, { datadogSite, failOnCriticalErrors, failOnTimeout, subdomain, batchTimeout }, reporter, tunnel);
        if (hasLTD) {
            try {
                yield (0, multilocator_1.updateLTDMultiLocators)(reporter, config, results);
            }
            catch (error) {
                throw new errors_1.CriticalError('LTD_MULTILOCATORS_UPDATE_FAILED', error.message);
            }
        }
        return {
            results,
            summary: Object.assign(Object.assign({}, initialSummary), { batchId: trigger.batchId }),
        };
    }
    catch (error) {
        if (error instanceof errors_1.BatchTimeoutRunawayError) {
            throw error;
        }
        if (error instanceof errors_1.CriticalError && error.code === 'LTD_MULTILOCATORS_UPDATE_FAILED') {
            throw error;
        }
        throw new errors_1.CriticalError('POLL_RESULTS_FAILED', error.message);
    }
    finally {
        yield stopTunnel();
    }
});
exports.executeTests = executeTests;
const getTriggerConfigs = (api, config, reporter, suites) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    // Grab the test config overrides from all the sources: default test config overrides, test files containing specific test config override, env variable, and CLI params
    const defaultTestConfigOverrides = config.defaultTestOverrides;
    const testsFromTestConfigs = yield (0, test_1.getTestConfigs)(config, reporter, suites);
    // Grab the tests returned by the search query (or `[]` if not given).
    const testsFromSearchQuery = yield (0, test_1.getTestsFromSearchQuery)(api, config);
    // Grab the list of publicIds of tests to trigger from config file/env variable/CLI params, search query or test config files
    const testIdsFromCli = config.publicIds;
    const testIdsFromSearchQuery = testsFromSearchQuery.map(({ id }) => id);
    const testIdsFromTestConfigs = testsFromTestConfigs.map(internal_1.getTriggerConfigPublicId).filter((p) => !!p);
    // Take the list of tests from the first source that defines it, by order of precedence
    const testIdsToTrigger = (_a = [testIdsFromCli, testIdsFromSearchQuery, testIdsFromTestConfigs].find((ids) => ids.length > 0)) !== null && _a !== void 0 ? _a : [];
    // Create the overrides required for the list of tests to trigger
    const triggerConfigsWithId = testIdsToTrigger.map((id) => {
        const testIndexFromSearchQuery = testsFromSearchQuery.findIndex((t) => t.id === id);
        let testFromSearchQuery;
        if (testIndexFromSearchQuery >= 0) {
            testFromSearchQuery = testsFromSearchQuery.splice(testIndexFromSearchQuery, 1)[0];
        }
        const testIndexFromTestConfigs = testsFromTestConfigs.findIndex((t) => (0, internal_1.getTriggerConfigPublicId)(t) === id);
        let testFromTestConfigs;
        if (testIndexFromTestConfigs >= 0) {
            testFromTestConfigs = testsFromTestConfigs.splice(testIndexFromTestConfigs, 1)[0];
        }
        return Object.assign(Object.assign(Object.assign(Object.assign({}, ((0, internal_1.isLocalTriggerConfig)(testFromTestConfigs) ? {} : { id })), testFromSearchQuery), testFromTestConfigs), { testOverrides: Object.assign(Object.assign({}, defaultTestConfigOverrides), testFromTestConfigs === null || testFromTestConfigs === void 0 ? void 0 : testFromTestConfigs.testOverrides) });
    });
    const localTriggerConfigsWithoutId = testsFromTestConfigs.flatMap((testConfig) => {
        if (!(0, internal_1.isLocalTriggerConfig)(testConfig)) {
            return [];
        }
        return [
            Object.assign(Object.assign({}, testConfig), { testOverrides: Object.assign(Object.assign({}, defaultTestConfigOverrides), testConfig.testOverrides) }),
        ];
    });
    return triggerConfigsWithId.concat(localTriggerConfigsWithoutId);
});
exports.getTriggerConfigs = getTriggerConfigs;
const executeWithDetails = (runConfig, { jUnitReport, reporters, runId, suites }) => __awaiter(void 0, void 0, void 0, function* () {
    const startTime = Date.now();
    const localConfig = Object.assign(Object.assign({}, (0, exports.getDefaultConfig)()), runConfig);
    // Handle reporters for the run.
    const localReporters = [];
    // If the config asks for specific reporters.
    if (reporters) {
        for (const reporter of reporters) {
            // Add our own reporters if required.
            if (reporter === 'junit') {
                localReporters.push(new junit_1.JUnitReporter({
                    context: process,
                    jUnitReport: jUnitReport || './junit.xml',
                    runName: `Run ${runId || 'undefined'}`,
                }));
            }
            if (reporter === 'default') {
                localReporters.push(new default_1.DefaultReporter({ context: process }));
            }
            // This is a custom reporter, so simply add it.
            if (typeof reporter !== 'string') {
                localReporters.push(reporter);
            }
        }
    }
    else {
        localReporters.push(new default_1.DefaultReporter({ context: process }));
    }
    const mainReporter = (0, public_1.getReporter)(localReporters);
    const { results, summary } = yield (0, exports.executeTests)(mainReporter, localConfig, suites);
    const orgSettings = yield (0, public_1.getOrgSettings)(mainReporter, localConfig);
    // XXX: Mutates the `summary` object.
    (0, public_1.renderResults)({
        config: localConfig,
        reporter: mainReporter,
        results,
        orgSettings,
        startTime,
        summary,
    });
    (0, public_1.reportExitLogs)(mainReporter, localConfig, { results });
    const exitCode = (0, public_1.toExitCode)((0, public_1.getExitReason)(localConfig, { results }));
    return {
        results,
        summary,
        exitCode,
    };
});
exports.executeWithDetails = executeWithDetails;
const execute = (runConfig, executeOptions) => __awaiter(void 0, void 0, void 0, function* () {
    const { exitCode } = yield (0, exports.executeWithDetails)(runConfig, executeOptions);
    return exitCode;
});
exports.execute = execute;
//# sourceMappingURL=run-tests-lib.js.map