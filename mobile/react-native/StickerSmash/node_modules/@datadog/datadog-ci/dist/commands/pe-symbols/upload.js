"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UploadCommand = void 0;
const fs_1 = __importDefault(require("fs"));
const clipanion_1 = require("clipanion");
const upath_1 = __importDefault(require("upath"));
const constants_1 = require("../../constants");
const apikey_1 = require("../../helpers/apikey");
const concurrency_1 = require("../../helpers/concurrency");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const format_git_sourcemaps_data_1 = require("../../helpers/git/format-git-sourcemaps-data");
const glob_1 = require("../../helpers/glob");
const metrics_1 = require("../../helpers/metrics");
const upload_1 = require("../../helpers/upload");
const utils_1 = require("../../helpers/utils");
const validation = __importStar(require("../../helpers/validation"));
const validation_1 = require("../../helpers/validation");
const version_1 = require("../../helpers/version");
const helpers_1 = require("./helpers");
const interfaces_1 = require("./interfaces");
const pe_1 = require("./pe");
const pe_constants_1 = require("./pe-constants");
const renderer_1 = require("./renderer");
class UploadCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.disableGit = clipanion_1.Option.Boolean('--disable-git', false);
        this.dryRun = clipanion_1.Option.Boolean('--dry-run', false);
        this.configPath = clipanion_1.Option.String('--config');
        this.maxConcurrency = clipanion_1.Option.String('--max-concurrency', '20', { validator: validation.isInteger() });
        this.repositoryUrl = clipanion_1.Option.String('--repository-url');
        this.replaceExisting = clipanion_1.Option.Boolean('--replace-existing', false);
        this.symbolsLocations = clipanion_1.Option.Rest({ required: 1 });
        this.cliVersion = version_1.version;
        this.config = {
            datadogSite: 'datadoghq.com',
        };
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.fipsConfig = {
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.fipsConfig.fips, this.fipsIgnoreError || this.fipsConfig.fipsIgnoreError);
            if (!(yield this.verifyParameters())) {
                return 1;
            }
            const initialTime = Date.now();
            this.context.stdout.write((0, renderer_1.renderCommandInfo)(this.dryRun, this.symbolsLocations));
            this.config = yield (0, utils_1.resolveConfigFromFileAndEnvironment)(this.config, {
                apiKey: process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
                datadogSite: process.env.DATADOG_SITE || process.env.DD_SITE,
            }, {
                configPath: this.configPath,
                defaultConfigPaths: utils_1.DEFAULT_CONFIG_PATHS,
                configFromFileCallback: (configFromFile) => {
                    (0, validation_1.checkAPIKeyOverride)(process.env.DATADOG_API_KEY || process.env.DD_API_KEY, configFromFile.apiKey, this.context.stdout);
                },
            });
            if (!this.disableGit) {
                this.gitData = yield this.getGitMetadata();
            }
            const callResults = [];
            try {
                callResults.push(...(yield this.performPESymbolsUpload()));
                const totalTime = (Date.now() - initialTime) / 1000;
                this.context.stdout.write((0, renderer_1.renderCommandSummary)(callResults, totalTime, this.dryRun));
            }
            catch (e) {
                this.context.stderr.write((0, renderer_1.renderGeneralizedError)(e));
                return 1;
            }
            return 0;
        });
    }
    getApiKeyValidator(metricsLogger) {
        return (0, apikey_1.newApiKeyValidator)({
            apiKey: this.config.apiKey,
            datadogSite: this.config.datadogSite,
            metricsLogger: metricsLogger.logger,
        });
    }
    getGitDataPayload(gitData) {
        const files = gitData.trackedFilesMatcher.rawTrackedFilesList();
        const repoPayload = {
            data: [
                {
                    files,
                    hash: gitData.hash,
                    repository_url: gitData.remote,
                },
            ],
            version: 1,
        };
        return {
            type: 'string',
            options: { filename: 'repository', contentType: 'application/json' },
            value: JSON.stringify(repoPayload),
        };
    }
    getGitMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield (0, format_git_sourcemaps_data_1.getRepositoryData)(yield (0, format_git_sourcemaps_data_1.newSimpleGit)(), this.repositoryUrl);
            }
            catch (e) {
                this.context.stdout.write((0, renderer_1.renderGitWarning)(e));
            }
            return undefined;
        });
    }
    getPESymbolSource(peFileMetadata) {
        if (peFileMetadata.hasPdbInfo) {
            return 'debug_info';
        }
        return 'none';
    }
    getArchitecture(architecture) {
        if (architecture === pe_constants_1.MachineArchitecture.x86) {
            return 'x86';
        }
        else if (architecture === pe_constants_1.MachineArchitecture.x64) {
            return 'x64';
        }
        else if (architecture === pe_constants_1.MachineArchitecture.Arm32) {
            return 'arm32';
        }
        else if (architecture === pe_constants_1.MachineArchitecture.Arm64) {
            return 'arm64';
        }
        else {
            return 'unknown';
        }
    }
    getMappingMetadata(peFileMetadata) {
        var _a, _b;
        return {
            cli_version: this.cliVersion,
            origin_version: this.cliVersion,
            origin: 'datadog-ci',
            arch: this.getArchitecture(peFileMetadata.arch),
            pdb_age: peFileMetadata.pdbAge,
            pdb_sig: peFileMetadata === null || peFileMetadata === void 0 ? void 0 : peFileMetadata.pdbSig,
            git_commit_sha: (_a = this.gitData) === null || _a === void 0 ? void 0 : _a.hash,
            git_repository_url: (_b = this.gitData) === null || _b === void 0 ? void 0 : _b.remote,
            symbol_source: this.getPESymbolSource(peFileMetadata),
            filename: upath_1.default.basename(peFileMetadata.pdbFilename),
            overwrite: this.replaceExisting,
            type: interfaces_1.TYPE_PE_DEBUG_INFOS,
        };
    }
    getMetricsLogger() {
        const metricsLogger = (0, metrics_1.getMetricsLogger)({
            apiKey: this.config.apiKey,
            datadogSite: this.config.datadogSite,
            defaultTags: [`cli_version:${this.cliVersion}`, 'platform:pe'],
            prefix: 'datadog.ci.pe_symbols.',
        });
        return metricsLogger;
    }
    getPESymbolFiles(symbolsLocation) {
        return __awaiter(this, void 0, void 0, function* () {
            let paths = [];
            let reportFailure;
            const stat = yield fs_1.default.promises.stat(symbolsLocation);
            if (stat.isDirectory()) {
                // strict: false is needed to avoid throwing an error if a directory is not readable
                paths = (0, glob_1.globSync)((0, utils_1.buildPath)(symbolsLocation, '**'), { dot: true, dotRelative: true });
                reportFailure = (message) => this.context.stdout.write((0, renderer_1.renderWarning)(message));
                // throw an error if top-level directory is not readable
                // eslint-disable-next-line no-bitwise
                yield fs_1.default.promises.access(symbolsLocation, fs_1.default.constants.R_OK | fs_1.default.constants.X_OK).catch(() => {
                    throw Error(`Directory ${symbolsLocation} is not readable`);
                });
            }
            else {
                paths = [symbolsLocation];
                // in single file mode, we want to report failures as errors
                reportFailure = (message) => {
                    throw Error(message);
                };
            }
            const filesMetadata = [];
            for (const p of paths) {
                const pathStat = yield fs_1.default.promises.lstat(p);
                if (pathStat.isDirectory()) {
                    // check if directory is readable and if not emit a warning
                    // eslint-disable-next-line no-bitwise
                    yield fs_1.default.promises.access(p, fs_1.default.constants.R_OK | fs_1.default.constants.X_OK).catch(() => {
                        reportFailure(`Skipped directory ${p} because it is not readable`);
                    });
                }
                else if (pathStat.isFile()) {
                    // check that path is a file and is a PE file
                    const metadata = yield (0, pe_1.getPEFileMetadata)(p);
                    // handle all possible failures
                    if (!metadata.isPE) {
                        reportFailure(`Input location ${p} is not a PE file`);
                        continue;
                    }
                    if (metadata.error) {
                        reportFailure(`Error reading PE file ${p}: ${metadata.error.message}`);
                        continue;
                    }
                    if (!metadata.hasPdbInfo) {
                        reportFailure(`Skipped ${p} because it has no debug info, nor symbols`);
                        continue;
                    }
                    filesMetadata.push(metadata);
                }
            }
            // sort files to make output deterministic
            filesMetadata.sort((a, b) => a.filename.localeCompare(b.filename));
            return filesMetadata;
        });
    }
    removeBuildIdDuplicates(filesMetadata) {
        const buildIds = new Map();
        for (const metadata of filesMetadata) {
            const buildId = (0, pe_1.getBuildId)(metadata);
            const existing = buildIds.get(buildId);
            if (existing) {
                // if both files have debug info and symbols, we keep the first one
                this.context.stderr.write((0, renderer_1.renderWarning)(`Duplicate build_id found: ${buildId} in ${metadata.filename} and ${existing.filename} - skipping ${metadata.filename}`));
            }
            else {
                buildIds.set(buildId, metadata);
            }
        }
        return Array.from(buildIds.values()).sort((a, b) => a.filename.localeCompare(b.filename));
    }
    getFileInSameFolder(pathname, newFilename) {
        const dirname = upath_1.default.dirname(pathname);
        const newPathname = upath_1.default.join(dirname, upath_1.default.basename(newFilename));
        return newPathname;
    }
    getAssociatedPdbFilename(pathname) {
        const basename = upath_1.default.basename(pathname, upath_1.default.extname(pathname));
        const dirname = upath_1.default.dirname(pathname);
        const newPathname = upath_1.default.join(dirname, `${basename}.pdb`);
        return newPathname;
    }
    performPESymbolsUpload() {
        return __awaiter(this, void 0, void 0, function* () {
            const metricsLogger = this.getMetricsLogger();
            const apiKeyValidator = this.getApiKeyValidator(metricsLogger);
            let peFilesMetadata = (yield Promise.all(this.symbolsLocations.map((location) => this.getPESymbolFiles(location)))).flat();
            peFilesMetadata = this.removeBuildIdDuplicates(peFilesMetadata);
            const requestBuilder = (0, helpers_1.getPERequestBuilder)(this.config.apiKey, this.cliVersion, this.config.datadogSite);
            try {
                const results = yield (0, concurrency_1.doWithMaxConcurrency)(this.maxConcurrency, peFilesMetadata, (fileMetadata) => __awaiter(this, void 0, void 0, function* () {
                    const metadata = this.getMappingMetadata(fileMetadata);
                    if (this.dryRun) {
                        this.context.stdout.write(`[DRYRUN] ${(0, renderer_1.renderUpload)(fileMetadata.filename, metadata)}`);
                        // TODO: uncomment the following when dryRun won't be TRUE by default
                        // return UploadStatus.Success
                    }
                    // get the .pdb filename based on the .dll filename and copy it into a temp folder
                    // --> not sure the ELF-based code makes any sense for PE files...
                    //     instead, we should not need to copy anything:
                    //     1. get the .pdb filename from the .dll file (ex: foo64.dll --> foo.pdb)
                    //     2. look for it in the same folder as the .dll file
                    //     3. if it is not there, look in the same folder for a file with the same name as .dll but with a .pdb extension
                    //     4. if it is there, upload it; if not generate a skip warning
                    //
                    let pdbFilename = this.getFileInSameFolder(fileMetadata.filename, fileMetadata.pdbFilename);
                    // TODO: remove this log after debugging
                    this.context.stdout.write(`[LOG] Look for pdb file = ${pdbFilename}\n`);
                    if (!fs_1.default.existsSync(pdbFilename)) {
                        pdbFilename = this.getAssociatedPdbFilename(fileMetadata.filename);
                        if (!fs_1.default.existsSync(pdbFilename)) {
                            this.context.stdout.write((0, renderer_1.renderMissingPdbFile)(fileMetadata.pdbFilename, fileMetadata.filename));
                            return upload_1.UploadStatus.Skipped;
                        }
                    }
                    // TODO: remove this log after debugging
                    this.context.stdout.write(`[LOG]      Use pdb file = ${pdbFilename}\n`);
                    const eventValue = JSON.stringify(metadata);
                    this.context.stdout.write((0, renderer_1.renderEventPayload)(eventValue));
                    const payload = {
                        content: new Map([
                            [
                                'event',
                                {
                                    type: 'string',
                                    value: eventValue,
                                    options: { filename: 'event', contentType: 'application/json' },
                                },
                            ],
                            [
                                interfaces_1.VALUE_NAME_PE_DEBUG_INFOS,
                                {
                                    type: 'file',
                                    path: pdbFilename,
                                    options: { filename: interfaces_1.PE_DEBUG_INFOS_FILENAME },
                                },
                            ],
                        ]),
                    };
                    if (this.gitData !== undefined) {
                        payload.content.set('repository', this.getGitDataPayload(this.gitData));
                    }
                    return (0, helpers_1.uploadMultipartHelper)(requestBuilder, payload, {
                        apiKeyValidator,
                        onError: (e) => {
                            this.context.stdout.write((0, renderer_1.renderFailedUpload)(fileMetadata.filename, e.message));
                            metricsLogger.logger.increment('failed', 1);
                        },
                        onRetry: (e, attempts) => {
                            this.context.stdout.write((0, renderer_1.renderRetriedUpload)(fileMetadata.filename, e.message, attempts));
                            metricsLogger.logger.increment('retries', 1);
                        },
                        onUpload: () => {
                            this.context.stdout.write((0, renderer_1.renderUpload)(fileMetadata.filename, metadata));
                        },
                        retries: 5,
                        useGzip: true,
                    });
                }));
                return results;
            }
            catch (error) {
                throw error;
            }
            finally {
                try {
                    yield metricsLogger.flush();
                }
                catch (err) {
                    this.context.stdout.write(`WARN: ${err}\n`);
                }
            }
        });
    }
    verifyParameters() {
        return __awaiter(this, void 0, void 0, function* () {
            let parametersOkay = true;
            if (!this.symbolsLocations || this.symbolsLocations.length === 0) {
                this.context.stderr.write((0, renderer_1.renderArgumentMissingError)('symbols locations'));
                parametersOkay = false;
            }
            else {
                for (const symbolsLocation of this.symbolsLocations) {
                    if (fs_1.default.existsSync(symbolsLocation)) {
                        const stats = fs_1.default.statSync(symbolsLocation);
                        if (!stats.isDirectory() && !stats.isFile()) {
                            this.context.stderr.write((0, renderer_1.renderInvalidSymbolsLocation)(symbolsLocation));
                            parametersOkay = false;
                        }
                    }
                    else {
                        this.context.stderr.write((0, renderer_1.renderInvalidSymbolsLocation)(symbolsLocation));
                        parametersOkay = false;
                    }
                }
            }
            return parametersOkay;
        });
    }
}
exports.UploadCommand = UploadCommand;
UploadCommand.paths = [['pe-symbols', 'upload']];
UploadCommand.usage = clipanion_1.Command.Usage({
    category: 'Profiling',
    description: 'Upload Windows PE debug info files to Datadog.',
    details: `
            This command will upload debug info from all PE files found recursively in the given location in order to symbolicate profiles
        `,
    examples: [['Upload debug infos for all PE files in the current directory', 'datadog-ci pe-symbols upload .']],
});
//# sourceMappingURL=upload.js.map