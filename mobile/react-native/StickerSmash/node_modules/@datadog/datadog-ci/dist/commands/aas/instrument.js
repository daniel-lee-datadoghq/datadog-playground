"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstrumentCommand = void 0;
const arm_appservice_1 = require("@azure/arm-appservice");
const arm_resources_1 = require("@azure/arm-resources");
const identity_1 = require("@azure/identity");
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const es6_1 = __importDefault(require("fast-deep-equal/es6"));
const constants_1 = require("../../constants");
const apikey_1 = require("../../helpers/apikey");
const instrument_helpers_1 = require("../../helpers/git/instrument-helpers");
const renderer_1 = require("../../helpers/renderer");
const utils_1 = require("../../helpers/utils");
const common_1 = require("./common");
class InstrumentCommand extends common_1.AasCommand {
    constructor() {
        super(...arguments);
        this.service = clipanion_1.Option.String('--service', {
            description: 'The value for the service tag. For example, `my-service`',
        });
        this.environment = clipanion_1.Option.String('--env,--environment', {
            description: 'The value for the env tag. For example, `prod`',
        });
        this.version = clipanion_1.Option.String('--version', {
            description: 'The value for the version tag. For example, `1.0.0`',
        });
        this.isInstanceLoggingEnabled = clipanion_1.Option.Boolean('--instance-logging', false, {
            description: 'When enabled, log collection is automatically configured for an additional file path: /home/LogFiles/*$COMPUTERNAME*.log',
        });
        this.logPath = clipanion_1.Option.String('--log-path', {
            description: 'Where you write your logs. For example, /home/LogFiles/*.log or /home/LogFiles/myapp/*.log',
        });
        this.shouldNotRestart = clipanion_1.Option.Boolean('--no-restart', false, {
            description: 'Do not restart the App Service after applying instrumentation.',
        });
        this.isDotnet = clipanion_1.Option.Boolean('--dotnet', false, {
            description: 'Add in required .NET-specific configuration options, is automatically inferred for code runtimes. This should be specified if you are using a containerized .NET app.',
        });
        this.isMusl = clipanion_1.Option.Boolean('--musl', false, {
            description: 'Add in required .NET-specific configuration options for musl-based .NET apps. This should be specified if you are using a containerized .NET app on a musl-based distribution like Alpine Linux.',
        });
        this.sourceCodeIntegration = clipanion_1.Option.Boolean('--source-code-integration,--sourceCodeIntegration', true, {
            description: 'Enable source code integration to add git metadata as tags. Defaults to enabled. Specify `--no-source-code-integration` to disable.',
        });
        this.uploadGitMetadata = clipanion_1.Option.Boolean('--upload-git-metadata,--uploadGitMetadata', true, {
            description: 'Upload git metadata to Datadog. Defaults to enabled. Specify `--no-upload-git-metadata` to disable.',
        });
        this.extraTags = clipanion_1.Option.String('--extra-tags,--extraTags', {
            description: 'Additional tags to add to the service in the format "key1:value1,key2:value2"',
        });
    }
    get additionalConfig() {
        return {
            service: this.service,
            environment: this.environment,
            version: this.version,
            isInstanceLoggingEnabled: this.isInstanceLoggingEnabled,
            logPath: this.logPath,
            shouldNotRestart: this.shouldNotRestart,
            isDotnet: this.isDotnet,
            isMusl: this.isMusl,
            sourceCodeIntegration: this.sourceCodeIntegration,
            uploadGitMetadata: this.uploadGitMetadata,
            extraTags: this.extraTags,
        };
    }
    execute() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.enableFips();
            const [appServicesToInstrument, config, errors] = yield this.ensureConfig();
            if (errors.length > 0) {
                for (const error of errors) {
                    this.context.stdout.write((0, renderer_1.renderError)(error));
                }
                return 1;
            }
            try {
                const isApiKeyValid = yield (0, apikey_1.newApiKeyValidator)({
                    apiKey: process.env.DD_API_KEY,
                    datadogSite: (_a = process.env.DD_SITE) !== null && _a !== void 0 ? _a : constants_1.DATADOG_SITE_US1,
                }).validateApiKey();
                if (!isApiKeyValid) {
                    throw Error();
                }
            }
            catch (e) {
                this.context.stdout.write((0, renderer_1.renderSoftWarning)(`Invalid API Key stored in the environment variable ${chalk_1.default.bold('DD_API_KEY')}: ${(0, utils_1.maskString)((_b = process.env.DD_API_KEY) !== null && _b !== void 0 ? _b : '')}\nEnsure you copied the value and not the Key ID.`));
                return 1;
            }
            const cred = new identity_1.DefaultAzureCredential();
            if (!(yield this.ensureAzureAuth(cred))) {
                return 1;
            }
            const tagClient = new arm_resources_1.ResourceManagementClient(cred).tagsOperations;
            if (config.sourceCodeIntegration) {
                config.extraTags = yield (0, instrument_helpers_1.handleSourceCodeIntegration)(this.context, this.uploadGitMetadata, config.extraTags);
            }
            this.context.stdout.write(`${this.dryRunPrefix}🐶 Beginning instrumentation of Azure App Service(s)\n`);
            const results = yield Promise.all(Object.entries(appServicesToInstrument).map(([subscriptionId, resourceGroupToNames]) => this.processSubscription(cred, tagClient, subscriptionId, resourceGroupToNames, config)));
            const success = results.every((result) => result);
            this.context.stdout.write(`${this.dryRunPrefix}🐶 Instrumentation completed ${success ? 'successfully!' : 'with errors, see above for details.'}\n`);
            return success ? 0 : 1;
        });
    }
    processSubscription(cred, tagClient, subscriptionId, resourceGroupToNames, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const aasClient = new arm_appservice_1.WebSiteManagementClient(cred, subscriptionId, { apiVersion: '2024-11-01' });
            const results = yield Promise.all(Object.entries(resourceGroupToNames).flatMap(([resourceGroup, aasNames]) => aasNames.map((aasName) => this.processAas(aasClient, tagClient, config, subscriptionId, resourceGroup, aasName))));
            return results.every((result) => result);
        });
    }
    /**
     * Process an Azure App Service for instrumentation.
     * @returns A promise that resolves to a boolean indicating success or failure.
     */
    processAas(aasClient, tagClient, config, subscriptionId, resourceGroup, aasName) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const site = yield aasClient.webApps.get(resourceGroup, aasName);
                if (!this.ensureLinux(site)) {
                    return false;
                }
                const isContainer = (0, common_1.isLinuxContainer)(site);
                if (config.isMusl && !isContainer) {
                    this.context.stdout.write((0, renderer_1.renderSoftWarning)(`The --musl flag is set, but the App Service ${chalk_1.default.bold(aasName)} is not a containerized app. \
This flag is only applicable for containerized .NET apps (on musl-based distributions like Alpine Linux), and will be ignored.`));
                }
                yield this.instrumentSidecar(aasClient, Object.assign(Object.assign({}, config), { isDotnet: config.isDotnet || (0, common_1.isDotnet)(site), isMusl: config.isMusl && config.isDotnet && isContainer }), resourceGroup, aasName);
                yield this.addTags(tagClient, config, subscriptionId, resourceGroup, aasName, (_a = site.tags) !== null && _a !== void 0 ? _a : {});
            }
            catch (error) {
                this.context.stdout.write((0, renderer_1.renderError)(`Failed to instrument ${aasName}: ${(0, common_1.formatError)(error)}`));
                return false;
            }
            if (!config.shouldNotRestart) {
                this.context.stdout.write(`${this.dryRunPrefix}Restarting Azure App Service ${chalk_1.default.bold(aasName)}\n`);
                if (!this.dryRun) {
                    try {
                        yield aasClient.webApps.restart(resourceGroup, aasName);
                    }
                    catch (error) {
                        this.context.stdout.write((0, renderer_1.renderError)(`Failed to restart Azure App Service ${chalk_1.default.bold(aasName)}: ${error}`));
                        return false;
                    }
                }
            }
            return true;
        });
    }
    addTags(tagClient, config, subscriptionId, resourceGroup, aasName, tags) {
        return __awaiter(this, void 0, void 0, function* () {
            const updatedTags = Object.assign({}, tags);
            if (config.service) {
                updatedTags.service = config.service;
            }
            if (config.environment) {
                updatedTags.env = config.environment;
            }
            if (config.version) {
                updatedTags.version = config.version;
            }
            if (!(0, es6_1.default)(tags, updatedTags)) {
                this.context.stdout.write(`${this.dryRunPrefix}Updating tags for ${chalk_1.default.bold(aasName)}\n`);
                if (!this.dryRun) {
                    try {
                        yield tagClient.beginCreateOrUpdateAtScopeAndWait(`/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Web/sites/${aasName}`, { properties: { tags: updatedTags } });
                    }
                    catch (error) {
                        this.context.stdout.write((0, renderer_1.renderError)(`Failed to update tags for ${chalk_1.default.bold(aasName)}: ${(0, common_1.formatError)(error)}`));
                    }
                }
            }
        });
    }
    instrumentSidecar(client, config, resourceGroup, aasName) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const siteContainers = yield (0, common_1.collectAsyncIterator)(client.webApps.listSiteContainers(resourceGroup, aasName));
            const sidecarContainer = siteContainers.find((c) => c.name === common_1.SIDECAR_CONTAINER_NAME);
            const envVars = (0, common_1.getEnvVars)(config);
            // We need to ensure that the sidecar container is configured correctly, which means checking the image, target port,
            // and environment variables. The sidecar environment variables must have matching names and values, as the sidecar
            // env values point to env keys in the main App Settings. (essentially env var forwarding)
            if (sidecarContainer === undefined ||
                sidecarContainer.image !== common_1.SIDECAR_IMAGE ||
                sidecarContainer.targetPort !== common_1.SIDECAR_PORT ||
                !((_a = sidecarContainer.environmentVariables) === null || _a === void 0 ? void 0 : _a.every(({ name, value }) => name === value)) ||
                !(0, es6_1.default)(new Set(sidecarContainer.environmentVariables.map(({ name }) => name)), new Set(Object.keys(envVars)))) {
                this.context.stdout.write(`${this.dryRunPrefix}${sidecarContainer === undefined ? 'Creating' : 'Updating'} sidecar container ${chalk_1.default.bold(common_1.SIDECAR_CONTAINER_NAME)} on ${chalk_1.default.bold(aasName)}\n`);
                if (!this.dryRun) {
                    yield client.webApps.createOrUpdateSiteContainer(resourceGroup, aasName, common_1.SIDECAR_CONTAINER_NAME, {
                        image: common_1.SIDECAR_IMAGE,
                        targetPort: common_1.SIDECAR_PORT,
                        isMain: false,
                        // We're allowing access to all env vars since it is simpler
                        // and doesn't cause problems, but not all env vars are needed for the sidecar.
                        environmentVariables: Object.keys(envVars).map((name) => ({ name, value: name })),
                    });
                }
            }
            else {
                this.context.stdout.write(`${this.dryRunPrefix}Sidecar container ${chalk_1.default.bold(common_1.SIDECAR_CONTAINER_NAME)} already exists with correct configuration.\n`);
            }
            const existingEnvVars = yield client.webApps.listApplicationSettings(resourceGroup, aasName);
            const updatedEnvVars = { properties: Object.assign(Object.assign({}, existingEnvVars.properties), envVars) };
            if (!(0, es6_1.default)(existingEnvVars.properties, updatedEnvVars.properties)) {
                this.context.stdout.write(`${this.dryRunPrefix}Updating Application Settings for ${chalk_1.default.bold(aasName)}\n`);
                if (!this.dryRun) {
                    yield client.webApps.updateApplicationSettings(resourceGroup, aasName, updatedEnvVars);
                }
            }
            else {
                this.context.stdout.write(`${this.dryRunPrefix}No Application Settings changes needed for ${chalk_1.default.bold(aasName)}.\n`);
            }
        });
    }
}
exports.InstrumentCommand = InstrumentCommand;
InstrumentCommand.paths = [['aas', 'instrument']];
InstrumentCommand.usage = clipanion_1.Command.Usage({
    category: 'Serverless',
    description: 'Apply Datadog instrumentation to an Azure App Service.',
});
//# sourceMappingURL=instrument.js.map