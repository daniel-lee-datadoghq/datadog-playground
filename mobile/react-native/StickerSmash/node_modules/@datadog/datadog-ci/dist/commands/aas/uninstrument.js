"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UninstrumentCommand = void 0;
const arm_appservice_1 = require("@azure/arm-appservice");
const identity_1 = require("@azure/identity");
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const renderer_1 = require("../../helpers/renderer");
const common_1 = require("./common");
class UninstrumentCommand extends common_1.AasCommand {
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            this.enableFips();
            const [appServicesToUninstrument, config, errors] = yield this.ensureConfig();
            if (errors.length > 0) {
                for (const error of errors) {
                    this.context.stdout.write((0, renderer_1.renderError)(error));
                }
                return 1;
            }
            const cred = new identity_1.DefaultAzureCredential();
            if (!(yield this.ensureAzureAuth(cred))) {
                return 1;
            }
            this.context.stdout.write(`${this.dryRunPrefix}🐶 Beginning uninstrumentation of Azure App Service(s)\n`);
            const results = yield Promise.all(Object.entries(appServicesToUninstrument).map(([subscriptionId, resourceGroupToNames]) => this.processSubscription(cred, subscriptionId, resourceGroupToNames, config)));
            const success = results.every((result) => result);
            this.context.stdout.write(`${this.dryRunPrefix}🐶 Uninstrumentation completed ${success ? 'successfully!' : 'with errors, see above for details.'}\n`);
            return success ? 0 : 1;
        });
    }
    processSubscription(cred, subscriptionId, resourceGroupToNames, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = new arm_appservice_1.WebSiteManagementClient(cred, subscriptionId, { apiVersion: '2024-11-01' });
            const results = yield Promise.all(Object.entries(resourceGroupToNames).flatMap(([resourceGroup, aasNames]) => aasNames.map((aasName) => this.processAas(client, config, resourceGroup, aasName))));
            return results.every((result) => result);
        });
    }
    /**
     * Process an Azure App Service for uninstrumentation.
     * @returns A promise that resolves to a boolean indicating success or failure.
     */
    processAas(client, config, resourceGroup, aasName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const site = yield client.webApps.get(resourceGroup, aasName);
                if (!this.ensureLinux(site)) {
                    return false;
                }
                yield this.uninstrumentSidecar(client, Object.assign(Object.assign({}, config), { isDotnet: config.isDotnet || (0, common_1.isDotnet)(site) }), resourceGroup, aasName);
            }
            catch (error) {
                this.context.stdout.write((0, renderer_1.renderError)(`Failed to uninstrument ${chalk_1.default.bold(aasName)}: ${(0, common_1.formatError)(error)}`));
                return false;
            }
            return true;
        });
    }
    uninstrumentSidecar(client, config, resourceGroup, aasName) {
        return __awaiter(this, void 0, void 0, function* () {
            this.context.stdout.write(`${this.dryRunPrefix}Removing sidecar container ${chalk_1.default.bold(common_1.SIDECAR_CONTAINER_NAME)} from ${chalk_1.default.bold(aasName)} (if it exists)\n`);
            if (!this.dryRun) {
                yield client.webApps.deleteSiteContainer(resourceGroup, aasName, common_1.SIDECAR_CONTAINER_NAME);
            }
            const configuredSettings = new Set([...common_1.AAS_DD_SETTING_NAMES, ...Object.keys((0, common_1.parseEnvVars)(config.envVars))]);
            this.context.stdout.write(`${this.dryRunPrefix}Checking Application Settings on ${chalk_1.default.bold(aasName)}\n`);
            const currentEnvVars = (yield client.webApps.listApplicationSettings(resourceGroup, aasName)).properties;
            if (currentEnvVars !== undefined && Object.keys(currentEnvVars).some((key) => configuredSettings.has(key))) {
                this.context.stdout.write(`${this.dryRunPrefix}Updating Application Settings for ${chalk_1.default.bold(aasName)}\n`);
                if (!this.dryRun) {
                    yield client.webApps.updateApplicationSettings(resourceGroup, aasName, {
                        properties: Object.fromEntries(Object.entries(currentEnvVars).filter(([key]) => !configuredSettings.has(key))),
                    });
                }
            }
            else {
                this.context.stdout.write(`${this.dryRunPrefix}No Application Settings changes needed for ${chalk_1.default.bold(aasName)}.\n`);
            }
        });
    }
}
exports.UninstrumentCommand = UninstrumentCommand;
UninstrumentCommand.paths = [['aas', 'uninstrument']];
UninstrumentCommand.usage = clipanion_1.Command.Usage({
    category: 'Serverless',
    description: 'Remove Datadog instrumentation from an Azure App Service.',
});
//# sourceMappingURL=uninstrument.js.map