"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UploadCommand = void 0;
const fs_1 = __importDefault(require("fs"));
const clipanion_1 = require("clipanion");
const js_yaml_1 = __importDefault(require("js-yaml"));
const semver_1 = __importDefault(require("semver"));
const constants_1 = require("../../constants");
const apikey_1 = require("../../helpers/apikey");
const concurrency_1 = require("../../helpers/concurrency");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const format_git_sourcemaps_data_1 = require("../../helpers/git/format-git-sourcemaps-data");
const glob_1 = require("../../helpers/glob");
const metrics_1 = require("../../helpers/metrics");
const upload_1 = require("../../helpers/upload");
const utils_1 = require("../../helpers/utils");
const validation = __importStar(require("../../helpers/validation"));
const validation_1 = require("../../helpers/validation");
const version_1 = require("../../helpers/version");
const dsyms = __importStar(require("../dsyms/upload"));
const git_1 = require("../git-metadata/git");
const sourcemaps = __importStar(require("../sourcemaps/upload"));
const helpers_1 = require("./helpers");
const interfaces_1 = require("./interfaces");
const renderer_1 = require("./renderer");
class UploadCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.androidMapping = clipanion_1.Option.Boolean('--android-mapping', false);
        this.androidMappingLocation = clipanion_1.Option.String('--android-mapping-location');
        this.webSourceMaps = clipanion_1.Option.Boolean('--web-sourcemaps', false);
        this.webSourceMapsLocation = clipanion_1.Option.String('--web-sourcemaps-location');
        this.minifiedPathPrefix = clipanion_1.Option.String('--minified-path-prefix');
        this.configPath = clipanion_1.Option.String('--config');
        this.dartSymbolsLocation = clipanion_1.Option.String('--dart-symbols-location');
        this.disableGit = clipanion_1.Option.Boolean('--disable-git', false);
        this.dryRun = clipanion_1.Option.Boolean('--dry-run', false);
        this.flavor = clipanion_1.Option.String('--flavor', 'release');
        this.iosDsyms = clipanion_1.Option.Boolean('--ios-dsyms', false);
        this.iosDsymsLocation = clipanion_1.Option.String('--ios-dsyms-location');
        this.maxConcurrency = clipanion_1.Option.String('--max-concurrency', '5', { validator: validation.isInteger() });
        this.pubspecLocation = clipanion_1.Option.String('--pubspec', './pubspec.yaml');
        this.repositoryUrl = clipanion_1.Option.String('--repository-url');
        this.serviceName = clipanion_1.Option.String('--service-name');
        this.version = clipanion_1.Option.String('--version');
        this.cliVersion = version_1.version;
        this.config = {
            datadogSite: 'datadoghq.com',
        };
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.fipsConfig = {
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.fipsConfig.fips, this.fipsIgnoreError || this.fipsConfig.fipsIgnoreError);
            if (!(yield this.verifyParameters())) {
                return 1;
            }
            const uploadInfo = [];
            if (this.iosDsymsLocation) {
                uploadInfo.push({
                    fileType: 'dSYMs',
                    location: this.iosDsymsLocation,
                    platform: 'ios',
                });
            }
            if (this.androidMappingLocation) {
                uploadInfo.push({
                    fileType: 'Proguard Mapping File',
                    location: this.androidMappingLocation,
                    platform: 'Android',
                });
            }
            if (this.dartSymbolsLocation) {
                uploadInfo.push({
                    fileType: 'Dart Symbol Files',
                    location: this.dartSymbolsLocation,
                    platform: 'Flutter',
                });
            }
            if (this.webSourceMapsLocation) {
                uploadInfo.push({
                    fileType: 'JavaScript Source Maps',
                    location: this.webSourceMapsLocation,
                    platform: 'Browser',
                });
            }
            this.context.stdout.write((0, renderer_1.renderCommandInfo)(this.dryRun, this.version, this.serviceName, this.flavor, uploadInfo));
            this.config = yield (0, utils_1.resolveConfigFromFileAndEnvironment)(this.config, {
                apiKey: process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
                datadogSite: process.env.DATADOG_SITE || process.env.DD_SITE,
            }, {
                configPath: this.configPath,
                defaultConfigPaths: utils_1.DEFAULT_CONFIG_PATHS,
                configFromFileCallback: (configFromFile) => {
                    (0, validation_1.checkAPIKeyOverride)(process.env.DATADOG_API_KEY || process.env.DD_API_KEY, configFromFile.apiKey, this.context.stdout);
                },
            });
            if (!this.disableGit) {
                this.gitData = yield this.getGitMetadata();
            }
            const initialTime = Date.now();
            const callResults = [];
            try {
                if (this.iosDsymsLocation) {
                    callResults.push(yield this.performDsymUpload());
                }
                if (this.androidMappingLocation) {
                    callResults.push(yield this.performAndroidMappingUpload());
                }
                if (this.dartSymbolsLocation) {
                    callResults.push(...(yield this.performDartSymbolsUpload()));
                }
                if (this.webSourceMapsLocation) {
                    callResults.push(yield this.performSourceMapUpload());
                }
                const totalTime = (Date.now() - initialTime) / 1000;
                this.context.stdout.write((0, renderer_1.renderCommandSummary)(callResults, totalTime, this.dryRun));
            }
            catch (e) {
                this.context.stderr.write((0, renderer_1.renderGeneralizedError)(e));
                return 1;
            }
            return 0;
        });
    }
    getAndroidMetadata() {
        return this.getMappingMetadata(interfaces_1.TYPE_JVM_MAPPING);
    }
    getApiKeyValidator(metricsLogger) {
        return (0, apikey_1.newApiKeyValidator)({
            apiKey: this.config.apiKey,
            datadogSite: this.config.datadogSite,
            metricsLogger: metricsLogger.logger,
        });
    }
    getFlutterMetadata(platform, arch) {
        return this.getMappingMetadata(interfaces_1.TYPE_DART_SYMBOLS, platform, arch);
    }
    getFlutterSymbolFiles(dartSymbolLocation) {
        const symbolPaths = (0, glob_1.globSync)((0, utils_1.buildPath)(dartSymbolLocation, '*.symbols'), { dotRelative: true });
        return symbolPaths;
    }
    getGitDataPayload(gitData) {
        const files = gitData.trackedFilesMatcher.rawTrackedFilesList();
        const repoPayload = {
            data: [
                {
                    files,
                    hash: gitData.hash,
                    repository_url: gitData.remote,
                },
            ],
            version: 1,
        };
        return {
            type: 'string',
            options: { filename: 'repository', contentType: 'application/json' },
            value: JSON.stringify(repoPayload),
        };
    }
    getGitMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield (0, format_git_sourcemaps_data_1.getRepositoryData)(yield (0, git_1.newSimpleGit)(), this.repositoryUrl);
            }
            catch (e) {
                this.context.stdout.write((0, renderer_1.renderGitWarning)(e));
            }
            return undefined;
        });
    }
    getMappingMetadata(type, platform, arch) {
        var _a, _b;
        return {
            arch,
            cli_version: this.cliVersion,
            git_commit_sha: (_a = this.gitData) === null || _a === void 0 ? void 0 : _a.hash,
            git_repository_url: (_b = this.gitData) === null || _b === void 0 ? void 0 : _b.remote,
            platform,
            service: this.serviceName,
            type,
            variant: this.flavor,
            version: this.getSanitizedVersion(),
        };
    }
    getMetricsLogger(tags) {
        const metricsLogger = (0, metrics_1.getMetricsLogger)({
            apiKey: this.config.apiKey,
            datadogSite: this.config.datadogSite,
            defaultTags: [
                `version:${this.version}`,
                `service:${this.serviceName}`,
                `cli_version:${this.cliVersion}`,
                'platform:flutter',
                ...tags,
            ],
            prefix: 'datadog.ci.symbols.upload.',
        });
        return metricsLogger;
    }
    getSanitizedVersion() {
        return this.version.replace('+', '-');
    }
    parsePubspecVersion(pubspecLocation) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fs_1.default.existsSync(pubspecLocation)) {
                this.context.stderr.write((0, renderer_1.renderMissingPubspecError)(pubspecLocation));
                return 1;
            }
            try {
                const doc = js_yaml_1.default.load(fs_1.default.readFileSync(pubspecLocation, 'utf8'));
                if (doc.version) {
                    this.version = doc.version;
                    const parsedVersion = semver_1.default.parse(this.version);
                    if (parsedVersion) {
                        if (parsedVersion.build.length > 0 || parsedVersion.prerelease.length > 0) {
                            this.context.stderr.write((0, renderer_1.renderVersionBuildNumberWarning)(pubspecLocation));
                            this.version = `${parsedVersion.major}.${parsedVersion.minor}.${parsedVersion.patch}`;
                        }
                    }
                    else {
                        this.context.stderr.write((0, renderer_1.renderVersionNotSemver)(pubspecLocation, this.version));
                    }
                }
                else {
                    this.context.stderr.write((0, renderer_1.renderPubspecMissingVersionError)(pubspecLocation));
                    return 1;
                }
            }
            catch (e) {
                this.context.stderr.write((0, renderer_1.renderInvalidPubspecError)(pubspecLocation));
                return 1;
            }
            return 0;
        });
    }
    performAndroidMappingUpload() {
        return __awaiter(this, void 0, void 0, function* () {
            const metricsLogger = this.getMetricsLogger(['platform:android']);
            const apiKeyValidator = this.getApiKeyValidator(metricsLogger);
            const requestBuilder = (0, helpers_1.getFlutterRequestBuilder)(this.config.apiKey, this.cliVersion, this.config.datadogSite);
            if (this.dryRun) {
                this.context.stdout.write(`[DRYRUN] ${(0, renderer_1.renderUpload)('Android Mapping File', this.androidMappingLocation)}`);
                return 0;
            }
            const metadata = this.getAndroidMetadata();
            const payload = {
                content: new Map([
                    [
                        'event',
                        {
                            type: 'string',
                            value: JSON.stringify(metadata),
                            options: { filename: 'event', contentType: 'application/json' },
                        },
                    ],
                    [
                        interfaces_1.VALUE_NAME_JVM_MAPPING,
                        { type: 'file', path: this.androidMappingLocation, options: { filename: interfaces_1.JVM_MAPPING_FILE_NAME } },
                    ],
                ]),
            };
            if (this.gitData !== undefined) {
                payload.content.set('repository', this.getGitDataPayload(this.gitData));
            }
            const status = yield (0, helpers_1.uploadMultipartHelper)(requestBuilder, payload, {
                apiKeyValidator,
                onError: (e) => {
                    this.context.stdout.write((0, renderer_1.renderFailedUpload)(this.androidMappingLocation, e.message));
                    metricsLogger.logger.increment('failed', 1);
                },
                onRetry: (e, attempts) => {
                    this.context.stdout.write((0, renderer_1.renderRetriedUpload)(this.androidMappingLocation, e.message, attempts));
                    metricsLogger.logger.increment('retries', 1);
                },
                onUpload: () => {
                    this.context.stdout.write((0, renderer_1.renderUpload)('Android Mapping File', this.androidMappingLocation));
                },
                retries: 5,
                useGzip: true,
            });
            if (status === upload_1.UploadStatus.Success) {
                this.context.stdout.write('Mapping upload finished\n');
            }
            else {
                this.context.stdout.write(`Mapping upload failed\n`);
            }
            return status;
        });
    }
    performDartSymbolsUpload() {
        return __awaiter(this, void 0, void 0, function* () {
            const metricsLogger = this.getMetricsLogger(['platform:android']);
            const apiKeyValidator = this.getApiKeyValidator(metricsLogger);
            const files = this.getFlutterSymbolFiles(this.dartSymbolsLocation);
            const filesMetadata = files.map((filename) => (Object.assign({ filename }, (0, helpers_1.getArchInfoFromFilename)(filename))));
            const requestBuilder = (0, helpers_1.getFlutterRequestBuilder)(this.config.apiKey, this.cliVersion, this.config.datadogSite);
            try {
                const results = yield (0, concurrency_1.doWithMaxConcurrency)(this.maxConcurrency, filesMetadata, (fileMetadata) => __awaiter(this, void 0, void 0, function* () {
                    if (!fileMetadata.arch || !fileMetadata.platform) {
                        (0, renderer_1.renderFailedUpload)(fileMetadata.filename, 'Skipped because we could not determine the architecture or platform.');
                        return upload_1.UploadStatus.Skipped;
                    }
                    if (this.dryRun) {
                        this.context.stdout.write(`[DRYRUN] ${(0, renderer_1.renderUpload)('Dart Symbol File', fileMetadata.filename)}`);
                        return upload_1.UploadStatus.Success;
                    }
                    const metadata = this.getFlutterMetadata(fileMetadata.platform, fileMetadata.arch);
                    const payload = {
                        content: new Map([
                            [
                                'event',
                                {
                                    type: 'string',
                                    value: JSON.stringify(metadata),
                                    options: { filename: 'event', contentType: 'application/json' },
                                },
                            ],
                            [
                                interfaces_1.VALUE_NAME_DART_MAPPING,
                                {
                                    type: 'file',
                                    path: fileMetadata.filename,
                                    options: { filename: interfaces_1.DART_SYMBOL_FILE_NAME },
                                },
                            ],
                        ]),
                    };
                    if (this.gitData !== undefined) {
                        payload.content.set('repository', this.getGitDataPayload(this.gitData));
                    }
                    return (0, helpers_1.uploadMultipartHelper)(requestBuilder, payload, {
                        apiKeyValidator,
                        onError: (e) => {
                            this.context.stdout.write((0, renderer_1.renderFailedUpload)(fileMetadata.filename, e.message));
                            metricsLogger.logger.increment('failed', 1);
                        },
                        onRetry: (e, attempts) => {
                            this.context.stdout.write((0, renderer_1.renderRetriedUpload)(fileMetadata.filename, e.message, attempts));
                            metricsLogger.logger.increment('retries', 1);
                        },
                        onUpload: () => {
                            this.context.stdout.write((0, renderer_1.renderUpload)('Flutter Symbol File', fileMetadata.filename));
                        },
                        retries: 5,
                        useGzip: true,
                    });
                }));
                return results;
            }
            catch (error) {
                throw error;
            }
            finally {
                try {
                    yield metricsLogger.flush();
                }
                catch (err) {
                    this.context.stdout.write(`WARN: ${err}\n`);
                }
            }
        });
    }
    performDsymUpload() {
        return __awaiter(this, void 0, void 0, function* () {
            const dsymUploadCommand = ['dsyms', 'upload', this.iosDsymsLocation];
            if (this.dryRun) {
                dsymUploadCommand.push('--dry-run');
            }
            const exitCode = yield (0, utils_1.performSubCommand)(dsyms.UploadCommand, dsymUploadCommand, this.context);
            if (exitCode && exitCode !== 0) {
                return upload_1.UploadStatus.Failure;
            }
            return upload_1.UploadStatus.Success;
        });
    }
    performSourceMapUpload() {
        return __awaiter(this, void 0, void 0, function* () {
            const sourceMapUploadCommand = [
                'sourcemaps',
                'upload',
                this.webSourceMapsLocation,
                `--service=${this.serviceName}`,
                `--release-version=${this.version}`,
                `--minified-path-prefix=${this.minifiedPathPrefix}`,
            ];
            if (this.dryRun) {
                sourceMapUploadCommand.push('--dry-run');
            }
            const exitCode = yield (0, utils_1.performSubCommand)(sourcemaps.UploadCommand, sourceMapUploadCommand, this.context);
            if (exitCode && exitCode !== 0) {
                return upload_1.UploadStatus.Failure;
            }
            return upload_1.UploadStatus.Success;
        });
    }
    verifyParameters() {
        return __awaiter(this, void 0, void 0, function* () {
            let parametersOkay = true;
            if (!this.serviceName) {
                this.context.stderr.write((0, renderer_1.renderArgumentMissingError)('service-name'));
                parametersOkay = false;
            }
            if (this.dartSymbolsLocation) {
                if (fs_1.default.existsSync(this.dartSymbolsLocation)) {
                    const stats = fs_1.default.statSync(this.dartSymbolsLocation);
                    if (!stats.isDirectory()) {
                        this.context.stderr.write((0, renderer_1.renderInvalidSymbolsDir)(this.dartSymbolsLocation));
                        parametersOkay = false;
                    }
                }
                else {
                    this.context.stderr.write((0, renderer_1.renderMissingDartSymbolsDir)(this.dartSymbolsLocation));
                    parametersOkay = false;
                }
            }
            if (this.iosDsyms && !this.iosDsymsLocation) {
                this.iosDsymsLocation = './build/ios/archive/Runner.xcarchive/dSYMs';
            }
            if (this.androidMapping && !this.androidMappingLocation) {
                this.androidMappingLocation = `./build/app/outputs/mapping/${this.flavor}/mapping.txt`;
            }
            if (this.androidMappingLocation) {
                if (!fs_1.default.existsSync(this.androidMappingLocation)) {
                    this.context.stderr.write((0, renderer_1.renderMissingAndroidMappingFile)(this.androidMappingLocation));
                    parametersOkay = false;
                }
            }
            if (this.webSourceMaps && !this.webSourceMapsLocation) {
                this.webSourceMapsLocation = './build/web';
            }
            if (this.webSourceMapsLocation) {
                if (!this.minifiedPathPrefix) {
                    this.context.stderr.write((0, renderer_1.renderMinifiedPathPrefixRequired)());
                    parametersOkay = false;
                }
            }
            if (!this.version && (yield this.parsePubspecVersion(this.pubspecLocation))) {
                parametersOkay = false;
            }
            return parametersOkay;
        });
    }
}
exports.UploadCommand = UploadCommand;
UploadCommand.paths = [['flutter-symbols', 'upload']];
UploadCommand.usage = clipanion_1.Command.Usage({
    category: 'RUM',
    description: 'Upload Flutter symbol files to Datadog.',
    details: `
            This command will upload all symbol files for Flutter applications in order to symbolicate errors and
            crash reports received by Datadog. This includes uploading iOS dSYMs, Proguard mapping files, and Dart
            symbol files.
        `,
    examples: [
        [
            'Upload all symbol files from default locations',
            'datadog-ci flutter-symbols upload --dart-symbols-location ./debug-info --service-name com.datadog.example --ios-dsyms --android-mapping',
        ],
    ],
});
//# sourceMappingURL=upload.js.map