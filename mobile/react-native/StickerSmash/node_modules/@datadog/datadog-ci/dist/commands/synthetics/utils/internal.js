"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBasePayload = exports.validateAndParseOverrides = exports.parseOverrideValue = exports.toExecutionRule = exports.getResultIdOrLinkedResultId = exports.isMobileTestWithOverride = exports.isResultInBatchSkippedBySelectiveRerun = exports.getPublicIdOrPlaceholder = exports.LOCAL_TEST_DEFINITION_PUBLIC_ID_PLACEHOLDER = exports.getTriggerConfigPublicId = exports.isBrowserServerResult = exports.isLocalTriggerConfig = exports.isTimedOutRetry = exports.isNonFinalResult = exports.hasDefinedResult = exports.isBaseResult = exports.hasResultPassed = exports.getOverriddenExecutionRule = exports.wait = void 0;
const env_1 = require("../../../helpers/env");
const utils_1 = require("../../../helpers/utils");
const interfaces_1 = require("../interfaces");
const public_1 = require("./public");
const levenshtein = require('fast-levenshtein');
const wait = (duration) => __awaiter(void 0, void 0, void 0, function* () { return new Promise((resolve) => setTimeout(resolve, duration)); });
exports.wait = wait;
const getOverriddenExecutionRule = (test, testOverrides) => {
    var _a, _b;
    if (testOverrides === null || testOverrides === void 0 ? void 0 : testOverrides.executionRule) {
        return (0, public_1.getStrictestExecutionRule)(testOverrides.executionRule, (_b = (_a = test === null || test === void 0 ? void 0 : test.options) === null || _a === void 0 ? void 0 : _a.ci) === null || _b === void 0 ? void 0 : _b.executionRule);
    }
};
exports.getOverriddenExecutionRule = getOverriddenExecutionRule;
const hasResultPassed = (result, isUnhealthy, hasTimedOut, options) => {
    if (isUnhealthy && !options.failOnCriticalErrors) {
        return true;
    }
    if (hasTimedOut && !options.failOnTimeout) {
        return true;
    }
    return result.status === 'passed';
};
exports.hasResultPassed = hasResultPassed;
/**
 * Whether the result is of type {@link BaseResult}, i.e. it wasn't skipped.
 */
const isBaseResult = (result) => {
    return !(0, public_1.isResultSkippedBySelectiveRerun)(result);
};
exports.isBaseResult = isBaseResult;
/**
 * Whether the result has a defined {@link BaseResult.result} property.
 *
 * This property would be undefined if the server result isn't available when polling for it,
 * which is a known latency issue. We call such result an incomplete result.
 */
const hasDefinedResult = (result) => {
    return (0, exports.isBaseResult)(result) && result.result !== undefined;
};
exports.hasDefinedResult = hasDefinedResult;
/**
 * When the test is configured to be retried and the first attempt fails, `retries` is set to `0`
 * and the result is kept `in_progress` until the final result is received.
 */
const isNonFinalResult = (result) => {
    return result.status === 'in_progress' && Number.isInteger(result.retries);
};
exports.isNonFinalResult = isNonFinalResult;
const isTimedOutRetry = (retries, maxRetries, timedOut) => {
    return !!timedOut && (retries !== null && retries !== void 0 ? retries : 0) < (maxRetries !== null && maxRetries !== void 0 ? maxRetries : 0);
};
exports.isTimedOutRetry = isTimedOutRetry;
const isLocalTriggerConfig = (triggerConfig) => {
    return triggerConfig ? 'localTestDefinition' in triggerConfig : false;
};
exports.isLocalTriggerConfig = isLocalTriggerConfig;
const isBrowserServerResult = (serverResult) => {
    return serverResult.steps !== undefined;
};
exports.isBrowserServerResult = isBrowserServerResult;
const getTriggerConfigPublicId = (triggerConfig) => {
    if ((0, exports.isLocalTriggerConfig)(triggerConfig)) {
        return triggerConfig.localTestDefinition.public_id;
    }
    return triggerConfig.id;
};
exports.getTriggerConfigPublicId = getTriggerConfigPublicId;
exports.LOCAL_TEST_DEFINITION_PUBLIC_ID_PLACEHOLDER = 'local';
const getPublicIdOrPlaceholder = (test) => ('public_id' in test && test.public_id) || exports.LOCAL_TEST_DEFINITION_PUBLIC_ID_PLACEHOLDER;
exports.getPublicIdOrPlaceholder = getPublicIdOrPlaceholder;
const isResultInBatchSkippedBySelectiveRerun = (result) => {
    var _a;
    return ((_a = result.selective_rerun) === null || _a === void 0 ? void 0 : _a.decision) === 'skip';
};
exports.isResultInBatchSkippedBySelectiveRerun = isResultInBatchSkippedBySelectiveRerun;
const isMobileTestWithOverride = (item) => 'test' in item && item.test.type === 'mobile' && !!item.test.options && !!item.test.options.mobileApplication;
exports.isMobileTestWithOverride = isMobileTestWithOverride;
const getResultIdOrLinkedResultId = (result) => {
    if ((0, exports.isResultInBatchSkippedBySelectiveRerun)(result)) {
        return result.selective_rerun.linked_result_id;
    }
    return result.result_id;
};
exports.getResultIdOrLinkedResultId = getResultIdOrLinkedResultId;
const toExecutionRule = (env) => {
    if (env === undefined) {
        return undefined;
    }
    const enumValues = Object.values(interfaces_1.ExecutionRule);
    if (enumValues.includes(env.toLowerCase())) {
        return env.toLowerCase();
    }
    return undefined;
};
exports.toExecutionRule = toExecutionRule;
const allOverrideKeys = [
    'cookies',
    'setCookies',
    'retry',
    'basicAuth',
    'allowInsecureCertificates',
    'body',
    'bodyType',
    'defaultStepTimeout',
    'deviceIds',
    'executionRule',
    'followRedirects',
    'headers',
    'locations',
    'resourceUrlSubstitutionRegexes',
    'startUrl',
    'startUrlSubstitutionRegex',
    'testTimeout',
    'variables',
];
const parseOverrideValue = (value, type) => {
    switch (type) {
        case 'boolean':
            const parsedBoolean = (0, env_1.toBoolean)(value);
            if (parsedBoolean !== undefined) {
                return parsedBoolean;
            }
            throw new Error(`Invalid boolean value: ${value}`);
        case 'number':
            const parsedNumber = (0, env_1.toNumber)(value);
            if (parsedNumber !== undefined) {
                return parsedNumber;
            }
            throw new Error(`Invalid number value: ${value}`);
        case 'string':
            return value.replace(/\\n/g, '\n').trim();
        case 'string[]':
            return value.split(';').map((item) => item.trim());
        case 'ExecutionRule':
            const parsedExecutionRule = (0, exports.toExecutionRule)(value);
            if (parsedExecutionRule !== undefined) {
                return parsedExecutionRule;
            }
            throw new Error(`Invalid ExecutionRule value: ${value}`);
        default:
            throw new Error(`Unknown type: ${type}`);
    }
};
exports.parseOverrideValue = parseOverrideValue;
const validateAndParseOverrides = (overrides) => {
    if (!overrides) {
        return {};
    }
    const parsedOverrides = overrides.reduce((acc, override) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const match = (_a = override.match(/^(.*?)=(.*)$/s)) !== null && _a !== void 0 ? _a : []; // split key and value at first equal sign
        const rawKey = (_b = match[1]) !== null && _b !== void 0 ? _b : '';
        const value = (_c = match[2]) !== null && _c !== void 0 ? _c : '';
        const key = rawKey.split('.')[0];
        const subKey = rawKey.split('.')[1];
        switch (key) {
            // Convert to number
            case 'defaultStepTimeout':
            case 'testTimeout':
                acc[key] = (0, exports.parseOverrideValue)(value, 'number');
                break;
            // Convert to boolean
            case 'allowInsecureCertificates':
            case 'followRedirects':
                acc[key] = (0, exports.parseOverrideValue)(value, 'boolean');
                break;
            // Convert to string
            case 'body':
            case 'bodyType':
            case 'startUrl':
            case 'startUrlSubstitutionRegex':
                acc[key] = (0, exports.parseOverrideValue)(value, 'string');
                break;
            // Convert to string[]
            case 'deviceIds':
            case 'locations':
            case 'resourceUrlSubstitutionRegexes':
                acc[key] = (0, exports.parseOverrideValue)(value, 'string[]');
                break;
            // Convert to ExecutionRule
            case 'executionRule':
                acc[key] = (0, exports.parseOverrideValue)(value, 'ExecutionRule');
                break;
            // Convert to RetryConfig
            case 'retry':
                switch (subKey) {
                    case 'count':
                    case 'interval':
                        acc['retry'] = (_d = acc['retry']) !== null && _d !== void 0 ? _d : {};
                        acc['retry'][subKey] = (0, exports.parseOverrideValue)(value, 'number');
                        break;
                    default:
                        throw new Error(`Invalid subkey for ${key}`);
                }
                break;
            // Convert to BasicAuthCredentials
            case 'basicAuth':
                switch (subKey) {
                    case 'username':
                    case 'password':
                        acc['basicAuth'] = (_e = acc['basicAuth']) !== null && _e !== void 0 ? _e : {};
                        acc['basicAuth'][subKey] = (0, exports.parseOverrideValue)(value, 'string');
                        break;
                    default:
                        throw new Error(`Invalid subkey for ${key}`);
                }
                break;
            // Convert to cookies and set-cookies (either a string or an object)
            case 'cookies':
            case 'setCookies':
                acc[key] = (_f = acc[key]) !== null && _f !== void 0 ? _f : {};
                if (subKey) {
                    if (subKey === 'append') {
                        ;
                        acc[key].append = (0, exports.parseOverrideValue)(value, 'boolean');
                    }
                    else {
                        throw new Error(`The path "${key}.${subKey}" is invalid. Did you mean \`--override ${key}=...\`?`);
                    }
                }
                else {
                    ;
                    acc[key].value = (0, exports.parseOverrideValue)(value, 'string');
                }
                break;
            // Convert to StringMap
            case 'headers':
            case 'variables':
                if (subKey) {
                    acc[key] = (_g = acc[key]) !== null && _g !== void 0 ? _g : {};
                    acc[key][subKey] = value;
                }
                else {
                    throw new Error(`No subkey found for ${key}`);
                }
                break;
            default:
                const closestKey = allOverrideKeys.reduce((prev, curr) => levenshtein.get(curr, key) < levenshtein.get(prev, key) ? curr : prev);
                if (levenshtein.get(closestKey, key) > 5) {
                    throw new Error(`Invalid key: ${key}`);
                }
                throw new Error(`Invalid key: ${key}. Did you mean \`${closestKey}\`?`);
        }
        return acc;
    }, {});
    return parsedOverrides;
};
exports.validateAndParseOverrides = validateAndParseOverrides;
const TEMPLATE_REGEX = /{{\s*([^{}]*?)\s*}}/g;
const template = (st, context) => st.replace(TEMPLATE_REGEX, (match, p1) => (p1 in context ? context[p1] : match));
const getBasePayload = (test, testOverrides) => {
    let overriddenConfig = {};
    if (!testOverrides || !Object.keys(testOverrides).length) {
        return overriddenConfig;
    }
    const executionRule = (0, exports.getOverriddenExecutionRule)(test, testOverrides);
    if (executionRule) {
        overriddenConfig.executionRule = executionRule;
    }
    overriddenConfig = Object.assign(Object.assign({}, overriddenConfig), (0, utils_1.pick)(testOverrides, [
        'allowInsecureCertificates',
        'basicAuth',
        'body',
        'bodyType',
        'cookies',
        'setCookies',
        'defaultStepTimeout',
        'deviceIds',
        'followRedirects',
        'headers',
        'locations',
        'resourceUrlSubstitutionRegexes',
        'retry',
        'startUrlSubstitutionRegex',
        'testTimeout',
        'variables',
    ]));
    if ((test.type === 'browser' || test.subtype === 'http') && testOverrides.startUrl) {
        overriddenConfig.startUrl = template(testOverrides.startUrl, Object.assign({}, process.env));
    }
    return overriddenConfig;
};
exports.getBasePayload = getBasePayload;
//# sourceMappingURL=internal.js.map