"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeploymentGateCommand = void 0;
const axios_1 = require("axios");
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const t = __importStar(require("typanion"));
const constants_1 = require("../../constants");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const formatting_1 = require("../../helpers/formatting");
const logger_1 = require("../../helpers/logger");
const retry_1 = require("../../helpers/retry");
const utils_1 = require("../../helpers/utils");
const api_1 = require("./api");
/**
 * This command allows to evaluate a deployment gate in Datadog.
 * It handles the entire process of requesting a gate evaluation and polling for results
 * The command will exit with status 0 when the gate passes and status 1 otherwise.
 */
class DeploymentGateCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        // Required parameters
        this.service = clipanion_1.Option.String('--service', {
            description: 'The service name (e.g. payments-backend)',
            validator: t.isString(),
        });
        this.env = clipanion_1.Option.String('--env', {
            description: 'The environment name (e.g. prod, staging)',
            validator: t.isString(),
        });
        // Optional parameters
        this.identifier = clipanion_1.Option.String('--identifier', {
            description: 'The deployment identifier (defaults to "default")',
            validator: t.isString(),
        });
        this.version = clipanion_1.Option.String('--version', {
            description: 'The deployment version (required for gates with faulty deployment detection rules)',
            validator: t.isString(),
        });
        this.apmPrimaryTag = clipanion_1.Option.String('--apm-primary-tag', {
            description: 'The APM primary tag (only for gates with faulty deployment detection rules)',
            validator: t.isString(),
        });
        this.timeout = clipanion_1.Option.String('--timeout', '10800', {
            description: 'Maximum amount of seconds to wait for the script execution in seconds (default: 10800 = 3 hours)',
            validator: t.isString(),
        });
        this.failOnError = clipanion_1.Option.Boolean('--fail-on-error', false, {
            description: 'When true, the script will consider the gate as failed when timeout is reached or unexpected errors occur calling the Datadog APIs',
        });
        // monitorVariable is hidden because it's not available yet
        this.monitorVariable = clipanion_1.Option.String('--monitor-variable', '', {
            validator: t.isString(),
            hidden: true,
        });
        // FIPS options
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.config = {
            apiKey: process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
            appKey: process.env.DATADOG_APP_KEY || process.env.DD_APP_KEY,
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
        this.logger = new logger_1.Logger((s) => this.context.stdout.write(s), logger_1.LogLevel.INFO);
        this.evaluationRequestTimeout = 60000; // 1 minute
        this.pollingInterval = 15000; // 15 seconds
        this.startTime = Date.now();
    }
    execute() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.config.fips, this.fipsIgnoreError || this.config.fipsIgnoreError);
            if (!this.service) {
                this.logger.error(chalk_1.default.red(`${formatting_1.ICONS.FAILED} Missing required parameter: ${chalk_1.default.bold('--service')}`));
                return 1;
            }
            if (!this.env) {
                this.logger.error(chalk_1.default.red(`${formatting_1.ICONS.FAILED} Missing required parameter: ${chalk_1.default.bold('--env')}`));
                return 1;
            }
            const timeoutSeconds = parseInt(this.timeout, 10);
            if (isNaN(timeoutSeconds) || timeoutSeconds <= 0) {
                this.logger.error(chalk_1.default.red(`${formatting_1.ICONS.FAILED} Invalid ${chalk_1.default.bold('--timeout')} value. Must be a positive integer.`));
                return 1;
            }
            const timeoutMilliseconds = timeoutSeconds * 1000;
            if (!this.config.apiKey) {
                this.logger.error(`${formatting_1.ICONS.FAILED} Neither ${chalk_1.default.red.bold('DATADOG_API_KEY')} nor ${chalk_1.default.red.bold('DD_API_KEY')} are in your environment.`);
                return 1;
            }
            if (!this.config.appKey) {
                this.logger.error(`${formatting_1.ICONS.FAILED} Neither ${chalk_1.default.red.bold('DATADOG_APP_KEY')} nor ${chalk_1.default.red.bold('DD_APP_KEY')} are in your environment.`);
                return 1;
            }
            this.logger.info('Starting deployment gate evaluation with parameters:');
            this.logger.info(`\tService: ${this.service}`);
            this.logger.info(`\tEnvironment: ${this.env}`);
            if (this.identifier) {
                this.logger.info(`\tIdentifier: ${this.identifier}`);
            }
            if (this.version) {
                this.logger.info(`\tVersion: ${this.version}`);
            }
            if (this.apmPrimaryTag) {
                this.logger.info(`\tAPM Primary Tag: ${this.apmPrimaryTag}`);
            }
            this.logger.info(`\tTimeout: ${timeoutSeconds} seconds`);
            this.logger.info(`\tFail on error: ${this.failOnError ? 'true' : 'false'}\n`);
            let result;
            try {
                const api = this.getApiHelper(this.config.apiKey, this.config.appKey);
                const evaluationRequest = this.buildEvaluationRequest();
                const evaluationId = yield this.requestGateEvaluation(api, evaluationRequest, this.evaluationRequestTimeout);
                result = yield this.pollForEvaluationResults(api, evaluationId, timeoutMilliseconds);
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.logger.error(`Deployment gate evaluation failed due to a non-retryable error: ${errorMessage}`);
                if ((0, axios_1.isAxiosError)(error) && ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status)) {
                    if (error.response.status >= 400 && error.response.status < 500) {
                        this.logger.error(`${formatting_1.ICONS.FAILED} Request failed with client error, exiting with status 1`);
                        return 1;
                    }
                }
                result = this.getResultForDatadogError();
            }
            return result === 'PASS' ? 0 : 1;
        });
    }
    getApiHelper(apiKey, appKey) {
        const site = process.env.DATADOG_SITE || process.env.DD_SITE || 'datadoghq.com';
        const baseAPIURL = `https://${(0, utils_1.getApiHostForSite)(site)}`;
        return (0, api_1.apiConstructor)(baseAPIURL, apiKey, appKey);
    }
    buildEvaluationRequest() {
        const request = {
            service: this.service || '',
            env: this.env || '',
        };
        if (this.identifier) {
            request.identifier = this.identifier;
        }
        if (this.version) {
            request.version = this.version;
        }
        if (this.apmPrimaryTag) {
            request.apm_primary_tag = this.apmPrimaryTag;
        }
        if (this.monitorVariable) {
            request.monitor_variable = this.monitorVariable;
        }
        return request;
    }
    requestGateEvaluation(api, request, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info('Requesting gate evaluation...');
            const doRequest = () => __awaiter(this, void 0, void 0, function* () {
                var _a;
                try {
                    const response = yield api.requestGateEvaluation(request);
                    const id = response.data.data.attributes.evaluation_id;
                    this.logger.info(chalk_1.default.green(`Gate evaluation started successfully. Evaluation ID: ${id}\n`));
                    return id;
                }
                catch (error) {
                    if ((0, axios_1.isAxiosError)(error) && ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status)) {
                        this.logger.error(`Request failed with error: ${error.response.status} ${error.response.statusText}`);
                    }
                    else {
                        const errorMessage = error instanceof Error ? error.message : String(error);
                        this.logger.error(`Could not start gate evaluation with unknown error: ${errorMessage}`);
                    }
                    throw error;
                }
            });
            const evaluationId = yield (0, retry_1.retryRequest)(doRequest, Object.assign(Object.assign({}, this.getRetryOptions(timeout)), { onRetry: (e, attempt) => {
                    this.logger.info(`Retrying gate evaluation request (${attempt} attempts)...`);
                } }));
            return evaluationId;
        });
    }
    pollForEvaluationResults(api, evaluationId, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info('Waiting for gate evaluation results...');
            let timePassed = Date.now() - this.startTime;
            let result;
            while (timePassed < timeout) {
                const remainingTime = timeout - timePassed;
                const waitTime = Math.min(this.pollingInterval, remainingTime);
                const waitTimeInSeconds = Math.floor(waitTime / 1000);
                result = yield this.getEvaluationResult(api, evaluationId);
                if (result) {
                    return result;
                }
                this.logger.info(`\tRetrying in ${waitTimeInSeconds}s...`);
                yield new Promise((resolve) => setTimeout(resolve, waitTime));
                timePassed = Date.now() - this.startTime;
            }
            // The block above may not have run the last time, so we need to check again
            result = yield this.getEvaluationResult(api, evaluationId);
            if (result) {
                return result;
            }
            this.logger.warn(`${formatting_1.ICONS.WARNING} Timeout reached (${timeout / 1000} seconds). Gate evaluation did not complete in time.`);
            return this.getResultForDatadogError();
        });
    }
    getEvaluationResult(api, evaluationId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield api.getGateEvaluationResult(evaluationId);
                const status = response.data.data.attributes.gate_status;
                switch (status) {
                    case 'pass':
                        this.logger.info(chalk_1.default.green(`\t${formatting_1.ICONS.SUCCESS} Gate evaluation passed`));
                        return 'PASS';
                    case 'fail':
                        this.logger.info(chalk_1.default.red(`\t${formatting_1.ICONS.FAILED} Gate evaluation failed`));
                        return 'FAIL';
                    case 'in_progress':
                        const rules = response.data.data.attributes.rules;
                        const totalRules = rules.length;
                        const completedRules = rules.filter((rule) => rule.status !== 'in_progress').length;
                        this.logger.info(`\tGate evaluation in progress (${completedRules}/${totalRules} rules completed)`);
                        break;
                    default:
                        this.logger.warn(`Unknown gate evaluation status: ${status}`);
                }
            }
            catch (error) {
                if ((0, axios_1.isAxiosError)(error) && ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status)) {
                    const status = error.response.status;
                    const statusText = error.response.statusText;
                    if (status === 404 || status >= 500) {
                        this.logger.error(`Error polling for gate evaluation results: ${status} ${statusText}`);
                        // We want to retry in this case, so we return undefined to trigger the retry
                        return;
                    }
                    else {
                        this.logger.error(`Error polling for gate evaluation results: ${status} ${statusText}`);
                    }
                }
                else {
                    const errorMessage = error instanceof Error ? error.message : String(error);
                    this.logger.error(`Error polling for gate evaluation results: ${errorMessage}`);
                }
                throw error;
            }
        });
    }
    getResultForDatadogError() {
        if (this.failOnError) {
            this.logger.warn('Unexpected error happened, exiting with status 1 because --fail-on-error is enabled');
            return 'FAIL';
        }
        this.logger.warn('Unexpected error happened, exiting with status 0');
        return 'PASS';
    }
    getRetryOptions(timeout) {
        const timeElapsed = Date.now() - this.startTime;
        const maxRetryTime = timeout - timeElapsed;
        return {
            forever: true,
            randomize: false,
            factor: 1.5,
            minTimeout: 5000,
            maxTimeout: 30000,
            maxRetryTime,
        };
    }
}
exports.DeploymentGateCommand = DeploymentGateCommand;
DeploymentGateCommand.paths = [['deployment', 'gate']];
DeploymentGateCommand.usage = clipanion_1.Command.Usage({
    category: 'CI Visibility',
    description: 'Evaluate deployment gates in Datadog.',
    details: `
      This command allows to evaluate a deployment gate in Datadog.
      The command will exit with status 0 when the gate passes and status 1 otherwise.
    `,
    examples: [
        [
            'Evaluate a deployment gate for payments-backend service in prod environment',
            'datadog-ci deployment gate --service payments-backend --env prod',
        ],
        [
            'Evaluate a deployment gate with custom timeout',
            'datadog-ci deployment gate --service payments-backend --env prod --timeout 7200',
        ],
        [
            'Evaluate a deployment gate and fail if an error occurs',
            'datadog-ci deployment gate --service payments-backend --env prod --fail-on-error',
        ],
        [
            'Evaluate a deployment gate with version and APM primary tag',
            'datadog-ci deployment gate --service payments-backend --env prod --version 1.2.3 --apm-primary-tag region:us-central-1',
        ],
    ],
});
//# sourceMappingURL=gate.js.map