"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstrumentStepFunctionsCommand = void 0;
const client_cloudwatch_logs_1 = require("@aws-sdk/client-cloudwatch-logs");
const client_iam_1 = require("@aws-sdk/client-iam");
const client_sfn_1 = require("@aws-sdk/client-sfn");
const clipanion_1 = require("clipanion");
const constants_1 = require("../../constants");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const version_1 = require("../../helpers/version");
const awsCommands_1 = require("./awsCommands");
const constants_2 = require("./constants");
const helpers_1 = require("./helpers");
const cliVersion = version_1.version;
class InstrumentStepFunctionsCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.dryRun = clipanion_1.Option.Boolean('-d,--dry-run', false);
        this.environment = clipanion_1.Option.String('-e,--env');
        this.forwarderArn = clipanion_1.Option.String('--forwarder');
        this.service = clipanion_1.Option.String('--service');
        this.stepFunctionArns = clipanion_1.Option.Array('-s,--step-function');
        this.mergeStepFunctionAndLambdaTraces = clipanion_1.Option.Boolean('-mlt,--merge-lambda-traces,--merge-step-function-and-lambda-traces', false);
        this.propagateUpstreamTrace = clipanion_1.Option.Boolean('--propagate-upstream-trace', false);
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.config = {
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
    }
    execute() {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.config.fips, this.fipsIgnoreError || this.config.fipsIgnoreError);
            let validationError = false;
            if (typeof this.forwarderArn !== 'string') {
                this.context.stdout.write('[Error] `--forwarder` is required\n');
                validationError = true;
            }
            else if (!(0, helpers_1.isValidArn)(this.forwarderArn)) {
                this.context.stdout.write(`[Error] Invalid arn format for \`--forwarder\` ${this.forwarderArn}\n`);
                validationError = true;
            }
            if (validationError) {
                return 1;
            }
            // remove duplicate step function arns
            const stepFunctionArns = [...new Set(this.stepFunctionArns)];
            if (stepFunctionArns.length === 0) {
                this.context.stdout.write(`[Error] Must specify at least one \`--step-function\`\n`);
                validationError = true;
            }
            for (const stepFunctionArn of stepFunctionArns) {
                if (!(0, helpers_1.isValidArn)(stepFunctionArn)) {
                    this.context.stdout.write(`[Error] Invalid arn format for \`--step-function\` ${stepFunctionArn}\n`);
                    validationError = true;
                }
            }
            if (validationError) {
                return 1;
            }
            let hasChanges = false;
            // loop over step functions passed as parameters and generate a list of requests to make to AWS for each step function
            for (const stepFunctionArn of stepFunctionArns) {
                this.context.stdout.write(`\n======= ${this.dryRun ? '[Dry Run] Planning for' : 'For'} ${stepFunctionArn} =========\n`);
                // use region from the step function arn to make requests to AWS
                const arnObject = (0, helpers_1.parseArn)(stepFunctionArn);
                const region = arnObject.region;
                const cloudWatchLogsClient = new client_cloudwatch_logs_1.CloudWatchLogsClient({ region });
                const stepFunctionsClient = new client_sfn_1.SFNClient({ region });
                const iamClient = new client_iam_1.IAMClient({ region });
                let describeStateMachineCommandOutput;
                try {
                    describeStateMachineCommandOutput = yield (0, awsCommands_1.describeStateMachine)(stepFunctionsClient, stepFunctionArn);
                }
                catch (err) {
                    if (err instanceof Error) {
                        this.context.stdout.write(`\n[Error] ${err.message}. Unable to describe state machine ${stepFunctionArn}\n`);
                    }
                    return 1;
                }
                let listStepFunctionTagsResponse;
                try {
                    listStepFunctionTagsResponse = yield (0, awsCommands_1.listTagsForResource)(stepFunctionsClient, stepFunctionArn);
                }
                catch (err) {
                    if (err instanceof Error) {
                        this.context.stdout.write(`\n[Error] ${err.message}. Unable to fetch tags for Step Function ${stepFunctionArn}\n`);
                    }
                    return 1;
                }
                const stepFunctionTagsToAdd = [];
                // if env and service tags are not already set on step function, set these tags using the values passed as parameters
                const hasEnvTag = (_a = listStepFunctionTagsResponse === null || listStepFunctionTagsResponse === void 0 ? void 0 : listStepFunctionTagsResponse.tags) === null || _a === void 0 ? void 0 : _a.some((tag) => tag.key === 'env');
                if (!hasEnvTag && typeof this.environment === 'string') {
                    stepFunctionTagsToAdd.push({
                        key: 'env',
                        value: this.environment,
                    });
                }
                else if (!hasEnvTag && this.environment === undefined) {
                    this.context.stdout.write('\n[Error] --env is required when a Step Function has no env tag\n');
                    return 1;
                }
                if (!((_b = listStepFunctionTagsResponse === null || listStepFunctionTagsResponse === void 0 ? void 0 : listStepFunctionTagsResponse.tags) === null || _b === void 0 ? void 0 : _b.some((tag) => tag.key === 'service' && tag.value === this.service)) &&
                    typeof this.service === 'string') {
                    stepFunctionTagsToAdd.push({ key: 'service', value: this.service });
                }
                // set version tag if it changed
                if (!((_c = listStepFunctionTagsResponse === null || listStepFunctionTagsResponse === void 0 ? void 0 : listStepFunctionTagsResponse.tags) === null || _c === void 0 ? void 0 : _c.some((tag) => tag.key === constants_2.TAG_VERSION_NAME && tag.value === `v${cliVersion}`))) {
                    stepFunctionTagsToAdd.push({ key: constants_2.TAG_VERSION_NAME, value: `v${cliVersion}` });
                }
                if (!((_d = listStepFunctionTagsResponse === null || listStepFunctionTagsResponse === void 0 ? void 0 : listStepFunctionTagsResponse.tags) === null || _d === void 0 ? void 0 : _d.some((tag) => { var _a; return tag.key === constants_2.DD_TRACE_ENABLED && ((_a = tag.value) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'true'; }))) {
                    stepFunctionTagsToAdd.push({ key: constants_2.DD_TRACE_ENABLED, value: 'true' });
                }
                if (stepFunctionTagsToAdd.length > 0) {
                    try {
                        yield (0, awsCommands_1.tagResource)(stepFunctionsClient, stepFunctionArn, stepFunctionTagsToAdd, this.context, this.dryRun);
                    }
                    catch (err) {
                        if (err instanceof Error) {
                            this.context.stdout.write(`\n[Error] ${err.message}. Failed to tag resource for ${stepFunctionArn}\n`);
                        }
                        return 1;
                    }
                    hasChanges = true;
                }
                const stateMachineName = describeStateMachineCommandOutput.name;
                const subscriptionFilterName = (0, helpers_1.buildSubscriptionFilterName)(stateMachineName);
                const logLevel = (_e = describeStateMachineCommandOutput.loggingConfiguration) === null || _e === void 0 ? void 0 : _e.level;
                if (logLevel === 'OFF') {
                    // if step function logging is disabled, create a log group, subscribe the forwarder to it, and enable step function logging to the created log group
                    const logGroupName = (0, helpers_1.buildLogGroupName)(stateMachineName, this.environment);
                    try {
                        yield (0, awsCommands_1.createLogGroup)(cloudWatchLogsClient, logGroupName, stepFunctionArn, this.context, this.dryRun);
                    }
                    catch (err) {
                        if (err instanceof Error) {
                            this.context.stdout.write(`\n[Error] ${err.message}. Failed to Create Log Group ${logGroupName} for ${stepFunctionArn}\n`);
                        }
                        return 1;
                    }
                    try {
                        yield (0, awsCommands_1.putSubscriptionFilter)(cloudWatchLogsClient, this.forwarderArn, subscriptionFilterName, logGroupName, stepFunctionArn, this.context, this.dryRun);
                    }
                    catch (err) {
                        if (err instanceof Error) {
                            this.context.stdout.write(`\n[Error] ${err.message}. Failed to put subscription filter ${subscriptionFilterName} for Log Group ${logGroupName}\n`);
                        }
                        return 1;
                    }
                    const logGroupArn = (0, helpers_1.buildArn)(arnObject.partition, 'logs', arnObject.region, arnObject.accountId, 'log-group', `${logGroupName}:*`);
                    // Create Logs Access policy
                    try {
                        yield (0, awsCommands_1.createLogsAccessPolicy)(iamClient, describeStateMachineCommandOutput, stepFunctionArn, this.context, this.dryRun);
                    }
                    catch (err) {
                        if (err instanceof Error) {
                            this.context.stdout.write(`\n[Error] ${err.message}. Failed to create logs access policy for ${stepFunctionArn}\n`);
                        }
                        return 1;
                    }
                    // Attach policy to state machine IAM role
                    try {
                        yield (0, awsCommands_1.attachPolicyToStateMachineIamRole)(iamClient, describeStateMachineCommandOutput, arnObject.accountId, stepFunctionArn, this.context, this.dryRun);
                    }
                    catch (err) {
                        if (err instanceof Error) {
                            this.context.stdout.write(`\n[Error] ${err.message}. Failed to attach policy to state machine iam role for ${stepFunctionArn}\n`);
                        }
                        return 1;
                    }
                    // IAM policy on step function role should include log permissions now
                    try {
                        yield (0, awsCommands_1.enableStepFunctionLogs)(stepFunctionsClient, describeStateMachineCommandOutput, logGroupArn, stepFunctionArn, this.context, this.dryRun);
                    }
                    catch (err) {
                        if (err instanceof Error) {
                            this.context.stdout.write(`\n[Error] ${err.message}. Failed to enable log group ${logGroupArn} for ${stepFunctionArn}\n`);
                        }
                        return 1;
                    }
                    hasChanges = true;
                }
                else {
                    // if step function logging is enabled, subscribe the forwarder to the log group in the step function logging config
                    const logGroupArn = (0, helpers_1.getStepFunctionLogGroupArn)(describeStateMachineCommandOutput);
                    if (logGroupArn === undefined) {
                        this.context.stdout.write('\n[Error] Unable to get Log Group arn from Step Function logging configuration\n');
                        return 1;
                    }
                    const logGroupName = (0, helpers_1.parseArn)(logGroupArn).resourceName;
                    // update step function logging config to have logLevel `ALL` and includeExecutionData `true` if not already configured
                    const includeExecutionData = (_f = describeStateMachineCommandOutput.loggingConfiguration) === null || _f === void 0 ? void 0 : _f.includeExecutionData;
                    if (logLevel !== 'ALL' || !includeExecutionData) {
                        try {
                            yield (0, awsCommands_1.enableStepFunctionLogs)(stepFunctionsClient, describeStateMachineCommandOutput, logGroupArn, stepFunctionArn, this.context, this.dryRun);
                        }
                        catch (err) {
                            if (err instanceof Error) {
                                this.context.stdout.write(`\n[Error] ${err.message}. Failed to enable step function logs for ${stepFunctionArn} when logLevel is not ALL or includeExecutionData is not true\n`);
                            }
                            return 1;
                        }
                        hasChanges = true;
                    }
                    try {
                        yield (0, awsCommands_1.putSubscriptionFilter)(cloudWatchLogsClient, this.forwarderArn, subscriptionFilterName, logGroupName, stepFunctionArn, this.context, this.dryRun);
                    }
                    catch (err) {
                        if (err instanceof Error) {
                            this.context.stdout.write(`\n[Error] ${err.message}. Failed to put subscription filter ${subscriptionFilterName} for ${stepFunctionArn}\n`);
                        }
                        return 1;
                    }
                    hasChanges = true;
                }
                if (this.mergeStepFunctionAndLambdaTraces || this.propagateUpstreamTrace) {
                    // Not putting the update operation into the business logic of logs subscription. This will
                    // add additional API call, but it would also allow easier testing and cleaner code.
                    yield (0, helpers_1.injectContextIntoTasks)(describeStateMachineCommandOutput, stepFunctionsClient, this.context, this.dryRun);
                }
            }
            if (!hasChanges) {
                this.context.stdout.write(`\nNo change is applied.\n `);
            }
            return 0;
        });
    }
}
exports.InstrumentStepFunctionsCommand = InstrumentStepFunctionsCommand;
InstrumentStepFunctionsCommand.paths = [['stepfunctions', 'instrument']];
InstrumentStepFunctionsCommand.usage = clipanion_1.Command.Usage({
    category: 'Serverless',
    description: 'Subscribe Step Function log groups to a Datadog Forwarder.',
    details: '--step-function expects a Step Function ARN\n--forwarder expects a Lambda ARN',
    examples: [
        [
            'View and apply changes to subscribe a Step Function Log Group to a Datadog Forwarder',
            'datadog-ci stepfunctions instrument --step-function arn:aws:states:us-east-1:000000000000:stateMachine:ExampleStepFunction --forwarder arn:aws:lambda:us-east-1:000000000000:function:ExampleDatadogForwarder --env dev --service example-service',
        ],
        [
            'View changes to subscribe a Step Function Log Group to a Datadog Forwarder',
            'datadog-ci stepfunctions instrument --step-function arn:aws:states:us-east-1:000000000000:stateMachine:ExampleStepFunction --forwarder arn:aws:lambda:us-east-1:000000000000:function:ExampleDatadogForwarder --env dev --service example-service --dry-run',
        ],
        [
            'View and apply changes to subscribe multiple Step Function Log Groups to a Datadog Forwarder',
            'datadog-ci stepfunctions instrument --step-function arn:aws:states:us-east-1:000000000000:stateMachine:ExampleStepFunction1 --step-function arn:aws:states:us-east-1:000000000000:stateMachine:ExampleStepFunction2 --forwarder arn:aws:lambda:us-east-1:000000000000:function:ExampleDatadogForwarder --env dev --service example-service',
        ],
    ],
});
//# sourceMappingURL=instrument.js.map