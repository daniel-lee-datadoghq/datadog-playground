"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateDependencyName = exports.filterInvalidDependencies = exports.validateFileAgainstToolRequirements = exports.validateSbomFileAgainstSchema = exports.getValidator = void 0;
const fs_1 = __importDefault(require("fs"));
const ajv_1 = __importDefault(require("ajv"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const packageurl_js_1 = require("packageurl-js");
const bom_1_4_schema_json_1 = __importDefault(require("./json-schema/cyclonedx/bom-1.4.schema.json"));
const bom_1_5_schema_json_1 = __importDefault(require("./json-schema/cyclonedx/bom-1.5.schema.json"));
const bom_1_6_schema_json_1 = __importDefault(require("./json-schema/cyclonedx/bom-1.6.schema.json"));
const jsf_0_82_schema_json_1 = __importDefault(require("./json-schema/jsf/jsf-0.82.schema.json"));
const spdx_schema_json_1 = __importDefault(require("./json-schema/spdx/spdx.schema.json"));
const types_1 = require("./types");
/**
 * Get the validate function. Read all the schemas and return
 * the function used to validate all SBOM documents.
 */
const getValidator = () => {
    const ajv = new ajv_1.default({ strict: false, validateFormats: false });
    ajv.addMetaSchema(spdx_schema_json_1.default);
    ajv.addMetaSchema(jsf_0_82_schema_json_1.default);
    (0, ajv_formats_1.default)(ajv);
    return ajv;
};
exports.getValidator = getValidator;
/**
 * Validate an SBOM file against the SBOM CycloneDX schema.
 *
 * @param path - the path of the file to validate
 * @param ajv - an instance of Ajv fully initialized and ready to use.
 * @param debug - if we need to show debug information
 */
const validateSbomFileAgainstSchema = (path, ajv, debug) => {
    const showValidationErrors = (version, errors) => {
        errors.forEach((message) => {
            process.stderr.write(`Error while validating file against CycloneDX ${version}: ${path}, ${message.schemaPath}: ${message.instancePath} ${message.message}\n`);
        });
    };
    try {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const fileContent = JSON.parse(fs_1.default.readFileSync(path).toString('utf8'));
        const validateFunctionCycloneDx16 = ajv.compile(bom_1_6_schema_json_1.default);
        const validateFunctionCycloneDx15 = ajv.compile(bom_1_5_schema_json_1.default);
        const validateFunctionCycloneDx14 = ajv.compile(bom_1_4_schema_json_1.default);
        const isValid16 = validateFunctionCycloneDx16(fileContent);
        const isValid15 = validateFunctionCycloneDx15(fileContent);
        const isValid14 = validateFunctionCycloneDx14(fileContent);
        // if debug is set, we should show what version is valid, either CycloneDX 1.4 or 1.5
        if (isValid16 && debug) {
            process.stdout.write('File is a valid CycloneDX 1.6 file\n');
        }
        if (isValid15 && debug) {
            process.stdout.write('File is a valid CycloneDX 1.5 file\n');
        }
        if (isValid14 && debug) {
            process.stdout.write('File is a valid CycloneDX 1.4 file\n');
        }
        if (isValid14 || isValid15 || isValid16) {
            return true;
        }
        // show the errors
        if (!isValid16) {
            if (debug) {
                showValidationErrors('1.6', validateFunctionCycloneDx16.errors || []);
            }
        }
        // show the errors
        if (!isValid15) {
            showValidationErrors('1.5', validateFunctionCycloneDx15.errors || []);
        }
        if (!isValid14) {
            if (debug) {
                showValidationErrors('1.4', validateFunctionCycloneDx14.errors || []);
            }
        }
        return false;
    }
    catch (error) {
        if (debug) {
            process.stderr.write(`Error while reading file: ${error.message}\n`);
        }
        return false;
    }
};
exports.validateSbomFileAgainstSchema = validateSbomFileAgainstSchema;
/**
 * Validate an SBOM file again what we need.
 * @param path - the path of the file to validate
 * @param debug - if we need to show debug information
 */
const validateFileAgainstToolRequirements = (path, debug) => {
    try {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const fileContent = JSON.parse(fs_1.default.readFileSync(path).toString('utf8'));
        if (!fileContent) {
            return false;
        }
        const components = fileContent['components'];
        if (!components) {
            return true;
        }
        for (const component of components) {
            if (!component['type']) {
                return false;
            }
            if (component['type'] === 'library') {
                const name = component['name'];
                if (!component['version']) {
                    continue;
                }
                if (!component['purl']) {
                    if (debug) {
                        process.stderr.write(`Component ${name} has no purl\n`);
                    }
                    return false;
                }
            }
        }
    }
    catch (error) {
        if (debug) {
            process.stderr.write(`Error while reading file: ${error.message}\n`);
        }
        return false;
    }
    return true;
};
exports.validateFileAgainstToolRequirements = validateFileAgainstToolRequirements;
/**
 * Filter invalid dependencies if some data is not compliant to what we expect.
 * @param dependencies
 */
const filterInvalidDependencies = (dependencies) => {
    const filteredDependencies = [];
    for (const dep of dependencies) {
        let isValid = true;
        try {
            packageurl_js_1.PackageURL.fromString(dep.purl);
        }
        catch (purlError) {
            isValid = false;
            process.stderr.write(`invalid purl ${dep.purl} for component ${dep.name}\n`);
        }
        if (isValid) {
            filteredDependencies.push(dep);
        }
    }
    return filteredDependencies;
};
exports.filterInvalidDependencies = filterInvalidDependencies;
const pythonPackaNameRegex = new RegExp('^[a-zA-Z0-9][a-zA-Z0-9\\-_.]*[a-zA-Z0-9]$');
const validateDependencyName = (dependency) => {
    if (dependency.language === types_1.DependencyLanguage.PYTHON && !pythonPackaNameRegex.test(dependency.name)) {
        return false;
    }
    return true;
};
exports.validateDependencyName = validateDependencyName;
//# sourceMappingURL=validation.js.map