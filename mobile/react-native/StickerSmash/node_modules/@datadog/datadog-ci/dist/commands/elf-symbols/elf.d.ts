/// <reference types="node" />
/// <reference types="node" />
export type ElfFileMetadata = {
    filename: string;
    isElf: boolean;
    arch: string;
    littleEndian: boolean;
    elfClass: number;
    gnuBuildId: string;
    goBuildId: string;
    fileHash: string;
    elfType: string;
    hasDebugInfo: boolean;
    hasDynamicSymbolTable: boolean;
    hasSymbolTable: boolean;
    hasCode: boolean;
    error?: Error;
};
export type ElfHeader = {
    elfClass: number;
    data: number;
    elfVersion: number;
    abi: number;
    abiVersion: number;
    littleEndian: boolean;
    e_type: number;
    e_machine: number;
    e_version: number;
    e_entry: bigint;
    e_phoff: bigint;
    e_shoff: bigint;
    e_flags: number;
    e_ehsize: number;
    e_phentsize: number;
    e_phnum: number;
    e_shentsize: number;
    e_shnum: number;
    e_shstrndx: number;
};
export type ProgramHeader = {
    p_type: number;
    p_flags: number;
    p_offset: bigint;
    p_vaddr: bigint;
    p_paddr: bigint;
    p_filesz: bigint;
    p_memsz: bigint;
    p_align: bigint;
};
export type SectionHeader = {
    name: string;
    sh_name: number;
    sh_type: number;
    sh_flags: bigint;
    sh_addr: bigint;
    sh_offset: bigint;
    sh_size: bigint;
    sh_link: number;
    sh_info: number;
    sh_addralign: bigint;
    sh_entsize: bigint;
};
export interface Reader {
    read(length: number, position?: number): Promise<Buffer>;
    close(): Promise<void>;
}
export interface StringTable {
    [index: number]: string;
}
export type ElfResult = {
    isElf: boolean;
    elfHeader?: ElfHeader;
    error?: Error;
};
export declare const readElfHeader: (reader: Reader) => Promise<ElfResult>;
export declare const readElfSectionHeader: (reader: Reader, elfHeader: ElfHeader, index: number) => Promise<SectionHeader>;
export declare const readElfSectionHeaderTable: (reader: Reader, elfHeader: ElfHeader) => Promise<SectionHeader[]>;
export declare const readElfProgramHeader: (reader: Reader, elfHeader: ElfHeader, index: number) => Promise<ProgramHeader>;
export declare const readElfProgramHeaderTable: (reader: Reader, elfHeader: ElfHeader) => Promise<ProgramHeader[]>;
export declare const getBuildIds: (reader: Reader, sectionHeaders: SectionHeader[], elfHeader: ElfHeader) => Promise<{
    gnuBuildId: string;
    goBuildId: string;
}>;
export declare const isSupportedArch: (arch: string) => boolean;
export declare const isSupportedElfType: (type: string) => boolean;
export declare const hasNonEmptySection: (sectionHeaders: SectionHeader[], name: string) => boolean;
export declare const getSectionInfo: (sections: SectionHeader[]) => {
    hasDebugInfo: boolean;
    hasSymbolTable: boolean;
    hasDynamicSymbolTable: boolean;
    hasCode: boolean;
};
export declare const getElfFileMetadata: (filename: string) => Promise<ElfFileMetadata>;
export declare const computeFileHash: (filename: string) => Promise<string>;
export declare const copyElfDebugInfo: (filename: string, outputFile: string, elfFileMetadata: ElfFileMetadata, compressDebugSections: boolean) => Promise<void>;
export declare const getOutputFilenameFromBuildId: (buildId: string) => string;
export declare const getBuildIdWithArch: (fileMetadata: ElfFileMetadata) => string;
