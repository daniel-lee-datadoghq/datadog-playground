"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.untagResource = exports.describeSubscriptionFilters = exports.deleteSubscriptionFilter = exports.updateStateMachineDefinition = exports.enableStepFunctionLogs = exports.attachPolicyToStateMachineIamRole = exports.createLogsAccessPolicy = exports.createLogGroup = exports.tagResource = exports.putSubscriptionFilter = exports.listTagsForResource = exports.describeStateMachine = void 0;
const client_cloudwatch_logs_1 = require("@aws-sdk/client-cloudwatch-logs");
const client_iam_1 = require("@aws-sdk/client-iam");
const client_sfn_1 = require("@aws-sdk/client-sfn");
const helpers_1 = require("./helpers");
const describeStateMachine = (stepFunctionsClient, stepFunctionArn) => __awaiter(void 0, void 0, void 0, function* () {
    const input = { stateMachineArn: stepFunctionArn };
    const command = new client_sfn_1.DescribeStateMachineCommand(input);
    const data = yield stepFunctionsClient.send(command);
    return data;
});
exports.describeStateMachine = describeStateMachine;
const listTagsForResource = (stepFunctionsClient, stepFunctionArn) => __awaiter(void 0, void 0, void 0, function* () {
    const input = { resourceArn: stepFunctionArn };
    const command = new client_sfn_1.ListTagsForResourceCommand(input);
    const data = yield stepFunctionsClient.send(command);
    return data;
});
exports.listTagsForResource = listTagsForResource;
const putSubscriptionFilter = (cloudWatchLogsClient, forwarderArn, filterName, logGroupName, stepFunctionArn, context, dryRun) => __awaiter(void 0, void 0, void 0, function* () {
    // Running this function multiple times would not create duplicate filters (old filter with the same name would be overwritten).
    // However, two filters with the same destination forwarder can exist when the filter names are different.
    const input = {
        destinationArn: forwarderArn,
        filterName,
        filterPattern: '',
        logGroupName,
    };
    const command = new client_cloudwatch_logs_1.PutSubscriptionFilterCommand(input);
    const commandName = 'PutSubscriptionFilter';
    (0, helpers_1.displayChanges)(stepFunctionArn, context, commandName, dryRun, input);
    if (!dryRun) {
        const data = yield cloudWatchLogsClient.send(command);
        // Even if the same filter name is created before, the response is still 200.
        // there are no way to tell
        context.stdout.write(`Subscription filter ${filterName} is created or the original filter ${filterName} is overwritten.\n\n`);
        return data;
    }
});
exports.putSubscriptionFilter = putSubscriptionFilter;
const tagResource = (stepFunctionsClient, stepFunctionArn, tags, context, dryRun) => __awaiter(void 0, void 0, void 0, function* () {
    const input = {
        resourceArn: stepFunctionArn,
        tags,
    };
    const command = new client_sfn_1.TagResourceCommand(input);
    const commandName = 'TagResource';
    (0, helpers_1.displayChanges)(stepFunctionArn, context, commandName, dryRun, input);
    if (!dryRun) {
        const data = yield stepFunctionsClient.send(command);
        printSuccessfulMessage(commandName, context);
        return data;
    }
});
exports.tagResource = tagResource;
const createLogGroup = (cloudWatchLogsClient, logGroupName, stepFunctionArn, context, dryRun) => __awaiter(void 0, void 0, void 0, function* () {
    const input = {
        logGroupName,
    };
    const command = new client_cloudwatch_logs_1.CreateLogGroupCommand(input);
    const commandName = 'CreateLogGroup';
    (0, helpers_1.displayChanges)(stepFunctionArn, context, commandName, dryRun, input);
    try {
        if (!dryRun) {
            const data = yield cloudWatchLogsClient.send(command);
            printSuccessfulMessage(commandName, context);
            return data;
        }
    }
    catch (err) {
        // if a resource already exists it's a warning since we can use that resource instead of creating it
        if (err instanceof Error && err.name === 'ResourceAlreadyExistsException') {
            context.stdout.write(` -> [Info] ${err.message}. Skipping resource creation and continuing with instrumentation.\n`);
        }
    }
});
exports.createLogGroup = createLogGroup;
const createLogsAccessPolicy = (iamClient, describeStateMachineCommandOutput, stepFunctionArn, context, dryRun) => __awaiter(void 0, void 0, void 0, function* () {
    // according to https://docs.aws.amazon.com/step-functions/latest/dg/cw-logs.html#cloudwatch-iam-policy
    const logsAccessPolicy = {
        Version: '2012-10-17',
        Statement: [
            {
                Effect: 'Allow',
                Action: [
                    'logs:CreateLogDelivery',
                    'logs:CreateLogStream',
                    'logs:GetLogDelivery',
                    'logs:UpdateLogDelivery',
                    'logs:DeleteLogDelivery',
                    'logs:ListLogDeliveries',
                    'logs:PutLogEvents',
                    'logs:PutResourcePolicy',
                    'logs:DescribeResourcePolicies',
                    'logs:DescribeLogGroups',
                ],
                Resource: '*',
            },
        ],
    };
    const input = {
        PolicyDocument: JSON.stringify(logsAccessPolicy),
        PolicyName: (0, helpers_1.buildLogAccessPolicyName)(describeStateMachineCommandOutput),
    };
    const command = new client_iam_1.CreatePolicyCommand(input);
    const commandName = 'CreatePolicy';
    (0, helpers_1.displayChanges)(stepFunctionArn, context, commandName, dryRun, input);
    try {
        if (!dryRun) {
            const data = yield iamClient.send(command);
            printSuccessfulMessage(commandName, context);
            return data;
        }
    }
    catch (err) {
        // if a resource already exists it's a warning since we can use that resource instead of creating it
        if (err instanceof Error && err.name === 'ResourceAlreadyExistsException') {
            context.stdout.write(` -> [Info] ${err.message}. Skipping resource creation and continuing with instrumentation.\n`);
        }
    }
});
exports.createLogsAccessPolicy = createLogsAccessPolicy;
const attachPolicyToStateMachineIamRole = (iamClient, describeStateMachineCommandOutput, accountId, stepFunctionArn, context, dryRun) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const splitRoleArnList = (_a = describeStateMachineCommandOutput === null || describeStateMachineCommandOutput === void 0 ? void 0 : describeStateMachineCommandOutput.roleArn) === null || _a === void 0 ? void 0 : _a.split('/');
    if (splitRoleArnList === undefined) {
        throw Error(`Unexpected roleArn ${describeStateMachineCommandOutput === null || describeStateMachineCommandOutput === void 0 ? void 0 : describeStateMachineCommandOutput.roleArn} for the describeStateMachineCommandOutput ${describeStateMachineCommandOutput}`);
    }
    // `arn:aws:iam::<accountId>:role/<name>` or `arn:aws:iam::<accountId>:role/service-role/<name>`
    const roleName = splitRoleArnList[splitRoleArnList.length - 1];
    const policyArn = `arn:aws:iam::${accountId}:policy/${(0, helpers_1.buildLogAccessPolicyName)(describeStateMachineCommandOutput)}`;
    const input = {
        PolicyArn: policyArn,
        RoleName: roleName,
    };
    const command = new client_iam_1.AttachRolePolicyCommand(input);
    const commandName = 'AttachRolePolicy';
    (0, helpers_1.displayChanges)(stepFunctionArn, context, commandName, dryRun, input);
    if (!dryRun) {
        const data = yield iamClient.send(command);
        printSuccessfulMessage(commandName, context);
        return data;
    }
});
exports.attachPolicyToStateMachineIamRole = attachPolicyToStateMachineIamRole;
const enableStepFunctionLogs = (stepFunctionsClient, stepFunction, logGroupArn, stepFunctionArn, context, dryRun) => __awaiter(void 0, void 0, void 0, function* () {
    const input = {
        stateMachineArn: stepFunction.stateMachineArn,
        loggingConfiguration: {
            destinations: [{ cloudWatchLogsLogGroup: { logGroupArn } }],
            level: client_sfn_1.LogLevel.ALL,
            includeExecutionData: true,
        },
    };
    const previousParams = {
        stateMachineArn: stepFunction.stateMachineArn,
        loggingConfiguration: stepFunction.loggingConfiguration,
    };
    const command = new client_sfn_1.UpdateStateMachineCommand(input);
    const commandName = 'UpdateStateMachine';
    (0, helpers_1.displayChanges)(stepFunctionArn, context, commandName, dryRun, input, previousParams);
    if (!dryRun) {
        const data = yield stepFunctionsClient.send(command);
        printSuccessfulMessage(commandName, context);
        return data;
    }
});
exports.enableStepFunctionLogs = enableStepFunctionLogs;
const updateStateMachineDefinition = (stepFunctionsClient, stepFunction, definitionObj, context, dryRun) => __awaiter(void 0, void 0, void 0, function* () {
    if (stepFunction === undefined) {
        return;
    }
    const input = {
        stateMachineArn: stepFunction.stateMachineArn,
        definition: JSON.stringify(definitionObj),
    };
    const command = new client_sfn_1.UpdateStateMachineCommand(input);
    context.stdout.write(`Going to inject Step Function context into lambda payload in steps of ${stepFunction.stateMachineArn}.\n\n`);
    if (!dryRun) {
        try {
            const data = yield stepFunctionsClient.send(command);
            context.stdout.write(`Step Function context is injected into lambda payload in steps of ${stepFunction.stateMachineArn}\n\n`);
            return data;
        }
        catch (err) {
            if (err instanceof Error) {
                context.stdout.write(`\n[Error] ${err.message}. Failed to inject context into lambda functions' payload of ${stepFunction.stateMachineArn} \n`);
            }
        }
    }
});
exports.updateStateMachineDefinition = updateStateMachineDefinition;
const deleteSubscriptionFilter = (cloudWatchLogsClient, filterName, logGroupName, stepFunctionArn, context, dryRun) => __awaiter(void 0, void 0, void 0, function* () {
    const input = {
        filterName,
        logGroupName,
    };
    const command = new client_cloudwatch_logs_1.DeleteSubscriptionFilterCommand(input);
    const commandName = 'DeleteSubscriptionFilter';
    (0, helpers_1.displayChanges)(stepFunctionArn, context, commandName, dryRun, input);
    if (!dryRun) {
        const data = yield cloudWatchLogsClient.send(command);
        printSuccessfulMessage(commandName, context);
        return data;
    }
});
exports.deleteSubscriptionFilter = deleteSubscriptionFilter;
const describeSubscriptionFilters = (cloudWatchLogsClient, logGroupName) => __awaiter(void 0, void 0, void 0, function* () {
    const input = { logGroupName };
    const command = new client_cloudwatch_logs_1.DescribeSubscriptionFiltersCommand(input);
    const data = yield cloudWatchLogsClient.send(command);
    return data;
});
exports.describeSubscriptionFilters = describeSubscriptionFilters;
const printSuccessfulMessage = (commandName, context) => {
    context.stdout.write(`${commandName} finished successfully!\n\n`);
};
const untagResource = (stepFunctionsClient, tagKeys, stepFunctionArn, context, dryRun) => __awaiter(void 0, void 0, void 0, function* () {
    const input = {
        resourceArn: stepFunctionArn,
        tagKeys,
    };
    const command = new client_sfn_1.UntagResourceCommand(input);
    const commandName = 'UntagResource';
    (0, helpers_1.displayChanges)(stepFunctionArn, context, commandName, dryRun, input);
    if (!dryRun) {
        const data = yield stepFunctionsClient.send(command);
        printSuccessfulMessage(commandName, context);
        return data;
    }
});
exports.untagResource = untagResource;
//# sourceMappingURL=awsCommands.js.map