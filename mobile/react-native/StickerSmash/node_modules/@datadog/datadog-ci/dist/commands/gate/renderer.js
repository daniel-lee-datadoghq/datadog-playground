"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderWaiting = exports.renderEvaluationRetry = exports.renderGateEvaluationError = exports.renderGateEvaluationInput = exports.renderDryRunEvaluation = exports.renderRuleEvaluation = exports.renderRuleUrl = exports.renderStatus = exports.renderEmptyEvaluation = exports.renderEvaluationResponse = void 0;
const chalk_1 = __importDefault(require("chalk"));
const tags_1 = require("../../helpers/tags");
const utils_1 = require("./utils");
const ICONS = {
    FAILED: '❌',
    SUCCESS: '✅',
    WARNING: '⚠️',
    INFO: 'ℹ️',
};
const renderEvaluationResponse = (evaluationResponse) => {
    if (evaluationResponse.status.toLowerCase() === 'empty') {
        return (0, exports.renderEmptyEvaluation)();
    }
    if (evaluationResponse.status.toLowerCase() === 'dry_run') {
        return (0, exports.renderDryRunEvaluation)(evaluationResponse);
    }
    let fullStr = '';
    fullStr += chalk_1.default.green('Successfully evaluated all matching rules.\n');
    fullStr += `Overall result: ${(0, exports.renderStatus)(evaluationResponse.status)}\n`;
    fullStr += `Number of rules evaluated: ${chalk_1.default.bold(evaluationResponse.rule_evaluations.length)}\n`;
    fullStr += '\n';
    fullStr += chalk_1.default.yellow('####### Rules evaluated #######\n');
    evaluationResponse.rule_evaluations.forEach((ruleEvaluation) => (fullStr += (0, exports.renderRuleEvaluation)(ruleEvaluation)));
    return fullStr;
};
exports.renderEvaluationResponse = renderEvaluationResponse;
const renderEmptyEvaluation = () => {
    return chalk_1.default.yellow(`${ICONS.WARNING} No matching rules were found in Datadog. Use the '--fail-on-empty' option to fail the command in this situation.\n`);
};
exports.renderEmptyEvaluation = renderEmptyEvaluation;
const renderStatus = (result) => {
    switch (result.toLowerCase()) {
        case 'passed':
            return chalk_1.default.green(`Passed ${ICONS.SUCCESS} `);
        case 'failed':
            return chalk_1.default.red(`Failed ${ICONS.FAILED} `);
        case 'no_data':
            return chalk_1.default.yellow(`No Data ${ICONS.WARNING} `);
        case 'dry_run':
            return chalk_1.default.yellow(`Dry Run ${ICONS.INFO}`);
    }
    return result.toLowerCase();
};
exports.renderStatus = renderStatus;
const renderRuleUrl = (ruleId) => {
    return `${(0, utils_1.getBaseUrl)()}ci/quality-gates/rule/${ruleId}`;
};
exports.renderRuleUrl = renderRuleUrl;
const renderRuleEvaluation = (ruleEvaluation) => {
    let fullStr = '';
    fullStr += `Rule Name: ${ruleEvaluation.rule_name}\n`;
    fullStr += `Rule URL: ${(0, exports.renderRuleUrl)(ruleEvaluation.rule_id)}\n`;
    fullStr += `Status: ${(0, exports.renderStatus)(ruleEvaluation.status)}\n`;
    if (ruleEvaluation.status.toLowerCase() === 'failed') {
        fullStr += `${chalk_1.default.red.bold('Failure reason')}: ${ruleEvaluation.failure_reason}\n`;
    }
    fullStr += `${chalk_1.default.yellow('Blocking')}: ${ruleEvaluation.is_blocking}\n`;
    if (ruleEvaluation.details_url) {
        fullStr += `Details: ${ruleEvaluation.details_url}\n`;
    }
    fullStr += '\n';
    return fullStr;
};
exports.renderRuleEvaluation = renderRuleEvaluation;
const renderDryRunEvaluation = (evaluationResponse) => {
    let fullStr = '';
    fullStr += chalk_1.default.green('Successfully completed a dry run request\n');
    fullStr += `Overall result: ${(0, exports.renderStatus)(evaluationResponse.status)}\n`;
    fullStr += `Number of matching rules: ${chalk_1.default.bold(evaluationResponse.rule_evaluations.length)}\n`;
    if (evaluationResponse.rule_evaluations.length > 0) {
        fullStr += '\n';
        fullStr += chalk_1.default.yellow('####### Matching rules #######\n');
        evaluationResponse.rule_evaluations.forEach((ruleEvaluation) => (fullStr += (0, exports.renderRuleEvaluation)(ruleEvaluation)));
    }
    return fullStr;
};
exports.renderDryRunEvaluation = renderDryRunEvaluation;
const renderGateEvaluationInput = (evaluateRequest) => {
    let fullStr = chalk_1.default.bold(`${ICONS.INFO} Evaluating rules matching the following information:\n`);
    fullStr += `Repository: ${evaluateRequest.spanTags[tags_1.GIT_REPOSITORY_URL]}\n`;
    fullStr += `Branch: ${evaluateRequest.spanTags[tags_1.GIT_BRANCH]}\n`;
    for (const [scopeKey, scopeValue] of Object.entries(evaluateRequest.userScope)) {
        const valueString = scopeValue.join(' OR ');
        fullStr += `${scopeKey}: ${valueString}\n`;
    }
    fullStr += '\n';
    return fullStr;
};
exports.renderGateEvaluationInput = renderGateEvaluationInput;
const renderGateEvaluationError = (error, failIfUnavailable) => {
    let errorStr = 'ERROR: Could not evaluate the rules.';
    if (error.message === 'wait') {
        errorStr += ` The command timed out.\n`;
    }
    if (error.response) {
        errorStr += ` Status code: ${error.response.status}.\n`;
    }
    if ((0, utils_1.isBadRequestError)(error)) {
        const errorMessage = error.response.data.errors[0].detail;
        errorStr += `Error is "${errorMessage}".\n`;
    }
    else if (((0, utils_1.is5xxError)(error) || (0, utils_1.isTimeout)(error)) && !failIfUnavailable) {
        errorStr += "Use the '--fail-if-unavailable' option to fail the command in this situation.\n";
    }
    return chalk_1.default.red(errorStr);
};
exports.renderGateEvaluationError = renderGateEvaluationError;
const renderEvaluationRetry = (attempt, error) => {
    if ((0, utils_1.is5xxError)(error)) {
        const errorStatus = (0, utils_1.getStatus)(error);
        return chalk_1.default.yellow(`[attempt ${attempt}] Gate evaluation failed with status code ${errorStatus}, retrying.\n`);
    }
    return chalk_1.default.yellow(`[attempt ${attempt}] Gate evaluation failed, retrying.\n`);
};
exports.renderEvaluationRetry = renderEvaluationRetry;
const renderWaiting = () => {
    return 'Waiting for events to arrive...\n';
};
exports.renderWaiting = renderWaiting;
//# sourceMappingURL=renderer.js.map