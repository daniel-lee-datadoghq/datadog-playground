"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportReceivedResults = exports.getResultsToReport = exports.waitForResults = exports.runTests = exports.DEFAULT_BATCH_TIMEOUT = void 0;
const chalk_1 = __importDefault(require("chalk"));
const deep_extend_1 = __importDefault(require("deep-extend"));
const api_1 = require("./api");
const errors_1 = require("./errors");
const internal_1 = require("./utils/internal");
const public_1 = require("./utils/public");
exports.DEFAULT_BATCH_TIMEOUT = 30 * 60 * 1000;
const POLLING_INTERVAL = 5000; // In ms
const runTests = (api, testsToTrigger, reporter, metadata, failOnMissingTests, selectiveRerun, batchTimeout = exports.DEFAULT_BATCH_TIMEOUT) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const payload = {
        tests: testsToTrigger,
        metadata,
        options: {
            batch_timeout: batchTimeout,
            selective_rerun: selectiveRerun,
        },
    };
    try {
        const response = yield api.triggerTests(payload);
        return {
            batchId: response.batch_id,
            locations: response.locations,
            selectiveRerunRateLimited: response.selective_rerun_rate_limited,
            testsNotAuthorized: new Set(),
        };
    }
    catch (e) {
        const errorMessage = (0, api_1.formatBackendErrors)(e);
        const unauthorizedTestPublicIds = (0, api_1.extractUnauthorizedTestPublicIds)(e);
        if (unauthorizedTestPublicIds === null || unauthorizedTestPublicIds === void 0 ? void 0 : unauthorizedTestPublicIds.size) {
            // Abort if `failOnMissingTests` is true.
            if (failOnMissingTests) {
                reporter.error(`${chalk_1.default.red.bold('Some tests were not authorized to be triggered. Aborting due to `failOnMissingTests: true`.')}\n  Error: ${errorMessage}\n\n`);
                const testsNotAuthorizedListStr = chalk_1.default.gray([...unauthorizedTestPublicIds].join(', '));
                throw new errors_1.CiError('UNAUTHORIZED_TESTS', testsNotAuthorizedListStr);
            }
            // Retry without unauthorized tests.
            reporter.error(`${chalk_1.default.red.bold('Some tests were not authorized to be triggered, retrying without themâ€¦')}\n  Error: ${errorMessage}\n\n`);
            const newTestsToTrigger = testsToTrigger.filter((t) => !unauthorizedTestPublicIds.has((0, internal_1.getPublicIdOrPlaceholder)(t)));
            const trigger = yield (0, exports.runTests)(api, newTestsToTrigger, reporter, metadata, failOnMissingTests, selectiveRerun, batchTimeout);
            return Object.assign(Object.assign({}, trigger), { testsNotAuthorized: new Set([...unauthorizedTestPublicIds, ...trigger.testsNotAuthorized]) });
        }
        // Rewrite error message
        const testIds = testsToTrigger.map((t) => (0, internal_1.getPublicIdOrPlaceholder)(t)).join(',');
        throw new api_1.EndpointError(`[${testIds}] Failed to trigger tests: ${errorMessage}\n`, (_a = e.response) === null || _a === void 0 ? void 0 : _a.status);
    }
});
exports.runTests = runTests;
const waitForResults = (api, trigger, tests, options, reporter, tunnel) => __awaiter(void 0, void 0, void 0, function* () {
    let isTunnelConnected = true;
    if (tunnel) {
        tunnel
            .keepAlive()
            .then(() => (isTunnelConnected = false))
            .catch(() => (isTunnelConnected = false));
    }
    reporter.testsWait(tests, (0, public_1.getAppBaseURL)(options), trigger.batchId);
    const locationNames = trigger.locations.reduce((mapping, location) => {
        mapping[location.name] = location.display_name;
        return mapping;
    }, {});
    const getLocation = (dcId, test) => {
        const hasTunnel = !!tunnel && (0, public_1.isTestSupportedByTunnel)(test);
        return hasTunnel ? 'Tunneled' : locationNames[dcId] || dcId;
    };
    const resultDisplayInfo = {
        getLocation,
        options,
        tests,
    };
    const results = yield waitForBatchToFinish(api, trigger.batchId, options.batchTimeout, resultDisplayInfo, reporter);
    if (tunnel && !isTunnelConnected) {
        reporter.error('The tunnel was closed during execution, this may have affected the results.\n');
    }
    return results;
});
exports.waitForResults = waitForResults;
const waitForBatchToFinish = (api, batchId, batchTimeout, resultDisplayInfo, reporter) => __awaiter(void 0, void 0, void 0, function* () {
    const safeDeadline = Date.now() + batchTimeout + 12 * POLLING_INTERVAL;
    const emittedResultIds = new Set();
    const backupPollResultMap = new Map();
    let oldIncompleteResultIds = new Set();
    while (true) {
        const batch = yield getBatch(api, batchId);
        const safeDeadlineReached = Date.now() >= safeDeadline;
        // The backend is expected to handle the time out of the batch by eventually changing its status to `failed`.
        // But `safeDeadlineReached` is a safety in case it fails to do that on time.
        const shouldContinuePolling = batch.status === 'in_progress' && !safeDeadlineReached;
        const newlyReceivedResults = (0, exports.reportReceivedResults)(batch, emittedResultIds, reporter);
        const resultIdsToFetch = getResultIdsToFetch(shouldContinuePolling, batch, newlyReceivedResults, oldIncompleteResultIds);
        const { pollResultMap, incompleteResultIds } = yield getPollResultMap(api, resultIdsToFetch, backupPollResultMap);
        const resultsToReport = (0, exports.getResultsToReport)(shouldContinuePolling, batch, newlyReceivedResults, emittedResultIds, oldIncompleteResultIds, incompleteResultIds, reporter);
        reportResults(batchId, resultsToReport, pollResultMap, resultDisplayInfo, safeDeadlineReached, reporter);
        oldIncompleteResultIds = incompleteResultIds;
        if (safeDeadlineReached) {
            throw new errors_1.BatchTimeoutRunawayError();
        }
        if (!shouldContinuePolling) {
            return batch.results.map((r) => getResultFromBatch(r, pollResultMap, resultDisplayInfo));
        }
        reportWaitingTests(batchId, batch, resultDisplayInfo, reporter);
        yield (0, internal_1.wait)(POLLING_INTERVAL);
    }
});
const getResultIdsToFetch = (shouldContinuePolling, batch, newlyReceivedResults, oldIncompleteResultIds) => {
    // For the last iteration, the full up-to-date data has to be fetched to compute the return value of `waitForResults()`.
    if (!shouldContinuePolling) {
        return getResultIds(batch.results);
    }
    return getResultIds(newlyReceivedResults).concat(...oldIncompleteResultIds);
};
const getResultsToReport = (shouldContinuePolling, batch, newlyReceivedResults, emittedResultIds, oldIncompleteResultIds, incompleteResultIds, reporter) => {
    const newlyCompleteResults = excludeSkipped(batch.results).filter((r) => oldIncompleteResultIds.has(r.result_id) && !incompleteResultIds.has(r.result_id));
    const resultsToReport = newlyReceivedResults
        .filter((r) => (0, internal_1.isResultInBatchSkippedBySelectiveRerun)(r) || !isResidualResult(r, emittedResultIds, incompleteResultIds))
        .concat(newlyCompleteResults);
    if (shouldContinuePolling) {
        return resultsToReport;
    }
    // Results that we failed to report for some reason are finally reported as "residues".
    const residualResults = excludeSkipped(batch.results).filter((r) => isResidualResult(r, emittedResultIds, incompleteResultIds));
    const errors = [];
    for (const result of residualResults) {
        if (!result.timed_out) {
            errors.push(`The information for result ${result.result_id} of test ${result.test_public_id} was incomplete at the end of the batch.`);
        }
    }
    if (errors.length > 0) {
        reporter.error(errors.join('\n') + '\n\n');
    }
    return resultsToReport.concat(residualResults);
};
exports.getResultsToReport = getResultsToReport;
const reportReceivedResults = (batch, emittedResultIds, reporter) => {
    const receivedResults = [];
    for (const [index, result] of batch.results.entries()) {
        // Skipped results are only reported by `resultReceived()`, then they are excluded everywhere with `excludeSkipped()`.
        const resultId = result.status === 'skipped' ? `skipped-${index}` : result.result_id;
        // The result is reported if it has a final status, or if it's a non-final result.
        if ((result.status !== 'in_progress' || (0, internal_1.isNonFinalResult)(result)) && !emittedResultIds.has(resultId)) {
            emittedResultIds.add(resultId);
            reporter.resultReceived(result);
            receivedResults.push(result);
        }
    }
    return receivedResults;
};
exports.reportReceivedResults = reportReceivedResults;
const reportResults = (batchId, results, pollResultMap, resultDisplayInfo, safeDeadlineReached, reporter) => {
    const baseUrl = (0, public_1.getAppBaseURL)(resultDisplayInfo.options);
    for (const result of results) {
        reporter.resultEnd(getResultFromBatch(result, pollResultMap, resultDisplayInfo, safeDeadlineReached), baseUrl, batchId);
    }
};
const reportWaitingTests = (batchId, batch, resultDisplayInfo, reporter) => {
    const baseUrl = (0, public_1.getAppBaseURL)(resultDisplayInfo.options);
    const { tests } = resultDisplayInfo;
    const inProgressPublicIds = new Set();
    const skippedBySelectiveRerunPublicIds = new Set();
    for (const result of batch.results) {
        if (result.status === 'in_progress') {
            inProgressPublicIds.add(result.test_public_id);
        }
        if ((0, internal_1.isResultInBatchSkippedBySelectiveRerun)(result)) {
            skippedBySelectiveRerunPublicIds.add(result.test_public_id);
        }
    }
    const remainingTests = [];
    let skippedCount = 0;
    for (const test of tests) {
        if (inProgressPublicIds.has(test.public_id)) {
            remainingTests.push(test);
        }
        if (skippedBySelectiveRerunPublicIds.has(test.public_id)) {
            skippedCount++;
        }
    }
    reporter.testsWait(remainingTests, baseUrl, batchId, skippedCount);
};
const getResultFromBatch = (resultInBatch, pollResultMap, resultDisplayInfo, safeDeadlineReached = false) => {
    var _a, _b, _c;
    const { tests } = resultDisplayInfo;
    const test = getTestByPublicId(resultInBatch.test_public_id, tests);
    const hasTimedOut = (_a = resultInBatch.timed_out) !== null && _a !== void 0 ? _a : safeDeadlineReached;
    const timedOutRetry = (0, internal_1.isTimedOutRetry)(resultInBatch.retries, resultInBatch.max_retries, resultInBatch.timed_out);
    if ((0, internal_1.isResultInBatchSkippedBySelectiveRerun)(resultInBatch)) {
        return {
            executionRule: resultInBatch.execution_rule,
            passed: true,
            resultId: (0, internal_1.getResultIdOrLinkedResultId)(resultInBatch),
            selectiveRerun: resultInBatch.selective_rerun,
            test,
            timedOut: hasTimedOut,
        };
    }
    const pollResult = pollResultMap.get(resultInBatch.result_id);
    const isUnhealthy = (_c = (_b = pollResult === null || pollResult === void 0 ? void 0 : pollResult.result) === null || _b === void 0 ? void 0 : _b.unhealthy) !== null && _c !== void 0 ? _c : false;
    if (!(pollResult === null || pollResult === void 0 ? void 0 : pollResult.result)) {
        return createResult(resultInBatch, pollResult, test, hasTimedOut, isUnhealthy, resultDisplayInfo);
    }
    if (safeDeadlineReached) {
        pollResult.result.failure = new errors_1.BatchTimeoutRunawayError().toJson();
        pollResult.result.status = 'failed';
    }
    else if (timedOutRetry) {
        pollResult.result.failure = { code: 'TIMEOUT', message: 'The batch timed out before receiving the retry.' };
        pollResult.result.status = 'failed';
    }
    else if (hasTimedOut) {
        pollResult.result.failure = { code: 'TIMEOUT', message: 'The batch timed out before receiving the result.' };
        pollResult.result.status = 'failed';
    }
    return createResult(resultInBatch, pollResult, test, hasTimedOut, isUnhealthy, resultDisplayInfo);
};
const createResult = (resultInBatch, pollResult, test, hasTimedOut, isUnhealthy, { getLocation, options }) => {
    var _a, _b;
    return {
        device: pollResult === null || pollResult === void 0 ? void 0 : pollResult.device,
        duration: resultInBatch.duration,
        executionRule: resultInBatch.execution_rule,
        initialResultId: resultInBatch.initial_result_id,
        isNonFinal: (0, internal_1.isNonFinalResult)(resultInBatch),
        location: getLocation(resultInBatch.location, test),
        passed: (0, internal_1.hasResultPassed)(resultInBatch, isUnhealthy, hasTimedOut, options),
        result: pollResult === null || pollResult === void 0 ? void 0 : pollResult.result,
        resultId: (0, internal_1.getResultIdOrLinkedResultId)(resultInBatch),
        retries: resultInBatch.retries || 0,
        maxRetries: resultInBatch.max_retries || 0,
        selectiveRerun: resultInBatch.selective_rerun,
        test: (0, deep_extend_1.default)({}, test, pollResult === null || pollResult === void 0 ? void 0 : pollResult.test),
        timedOut: hasTimedOut,
        timestamp: (_b = (_a = pollResult === null || pollResult === void 0 ? void 0 : pollResult.result) === null || _a === void 0 ? void 0 : _a.finished_at) !== null && _b !== void 0 ? _b : Date.now(),
    };
};
const getBatch = (api, batchId) => __awaiter(void 0, void 0, void 0, function* () {
    var _b;
    try {
        const batch = yield api.getBatch(batchId);
        return batch;
    }
    catch (e) {
        throw new api_1.EndpointError(`Failed to get batch: ${(0, api_1.formatBackendErrors)(e)}\n`, (_b = e.response) === null || _b === void 0 ? void 0 : _b.status);
    }
});
/**
 * Returns fresh poll results, or reads the backup map in case of 404.
 */
const getPollResultMap = (api, resultIds, backupPollResultMap) => __awaiter(void 0, void 0, void 0, function* () {
    var _c;
    const pollResultMap = new Map();
    const incompleteResultIds = new Set();
    try {
        const pollResults = yield api.pollResults(resultIds);
        pollResults.forEach((r) => {
            // Server results can take some time to arrive. During this time,
            // the endpoint returns a partial result with only `test_type` and `result.id` set.
            // We keep the `PollResult` but remove the `ServerResult` to avoid reporting incomplete data.
            if (r.result && !('finished_at' in r.result)) {
                incompleteResultIds.add(r.resultID);
                delete r.result;
            }
            pollResultMap.set(r.resultID, r);
            backupPollResultMap.set(r.resultID, r);
        });
        return { pollResultMap, incompleteResultIds };
    }
    catch (e) {
        if ((0, api_1.getErrorHttpStatus)(e) === 404) {
            // If some results have latency and retries were not enough, the whole request fails with "Test results not found".
            // In that case, we mark results IDs that were never polled before as incomplete so they are fetched in the next polling cycles.
            resultIds.forEach((resultId) => {
                const backupPollResult = backupPollResultMap.get(resultId);
                if (backupPollResult) {
                    pollResultMap.set(resultId, backupPollResult);
                }
                else {
                    incompleteResultIds.add(resultId);
                }
            });
            return { pollResultMap, incompleteResultIds };
        }
        throw new api_1.EndpointError(`Failed to poll results: ${(0, api_1.formatBackendErrors)(e)}\n`, (_c = e.response) === null || _c === void 0 ? void 0 : _c.status);
    }
});
/**
 * A residual result is either:
 * - Still incomplete (from the poll results POV): report it with incomplete data and a warning.
 * - Still in progress (from the batch POV): it was never emitted.
 * - A timed out retry.
 */
const isResidualResult = (result, emittedResultIds, incompleteResultIds) => {
    if (incompleteResultIds.has(result.result_id)) {
        // The poll results endpoint returned an incomplete result: report it with incomplete data and a warning.
        return true;
    }
    if (!emittedResultIds.has(result.result_id)) {
        // Was never emitted, which means the batch never set a final status for it.
        return true;
    }
    if (emittedResultIds.has(result.result_id) && (0, internal_1.isTimedOutRetry)(result.retries, result.max_retries, result.timed_out)) {
        // The result ID was already emitted but it used to be non-final result, and it's now a timed out retry.
        return true;
    }
    return false;
};
const getTestByPublicId = (id, tests) => tests.find((t) => t.public_id === id);
const getResultIds = (results) => excludeSkipped(results).map((r) => r.result_id);
const excludeSkipped = (results) => results.filter((r) => !(0, internal_1.isResultInBatchSkippedBySelectiveRerun)(r));
//# sourceMappingURL=batch.js.map