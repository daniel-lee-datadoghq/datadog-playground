"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadRepository = exports.uploadGitCommitHash = exports.getGitCommitInfo = exports.isGitRepo = void 0;
const apikey_1 = require("../../helpers/apikey");
const logger_1 = require("../../helpers/logger");
const upload_1 = require("../../helpers/upload");
const utils_1 = require("../../helpers/utils");
const version_1 = require("../../helpers/version");
const git_1 = require("./git");
const gitdb_1 = require("./gitdb");
const isGitRepo = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const simpleGit = yield (0, git_1.newSimpleGit)();
        const isRepo = simpleGit.checkIsRepo();
        return isRepo;
    }
    catch (_a) {
        return false;
    }
});
exports.isGitRepo = isGitRepo;
// getGitCommitInfo returns the current [repositoryURL, commitHash]. If parameter
// filterAndFormatGitRepoUrl == true, the repositoryURL will have sensitive information filtered and
// git prefix normalized.
// ("git@github.com:" and "https://github.com/" prefixes will be normalized into "github.com/")
const getGitCommitInfo = (filterAndFormatGitRepoUrl = true) => __awaiter(void 0, void 0, void 0, function* () {
    const simpleGit = yield (0, git_1.newSimpleGit)();
    const payload = yield (0, git_1.getCommitInfo)(simpleGit);
    const gitRemote = filterAndFormatGitRepoUrl ? (0, utils_1.filterAndFormatGithubRemote)(payload.remote) : payload.remote;
    // gitRemote will never be undefined, as filterAndFormatGithubRemote will ONLY return undefined if it's
    // parameter value is also undefined. Added the " gitRemote ?? '' " to make the typechecker happy.
    return [gitRemote !== null && gitRemote !== void 0 ? gitRemote : '', payload.hash];
});
exports.getGitCommitInfo = getGitCommitInfo;
// uploadGitCommitHash uploads local git metadata and returns the current [repositoryURL, commitHash].
// The current repositoryURL can be overridden by specifying the 'repositoryURL' arg.
const uploadGitCommitHash = (apiKey, datadogSite, repositoryURL) => __awaiter(void 0, void 0, void 0, function* () {
    const simpleGit = yield (0, git_1.newSimpleGit)();
    const payload = yield (0, git_1.getCommitInfo)(simpleGit, repositoryURL);
    return Promise.all([
        syncGitDB(simpleGit, apiKey, datadogSite, payload.remote),
        uploadToSrcmapTrack(apiKey, datadogSite, payload),
    ]).then(() => [payload.remote, payload.hash]);
});
exports.uploadGitCommitHash = uploadGitCommitHash;
const syncGitDB = (simpleGit, apiKey, datadogSite, repositoryURL) => __awaiter(void 0, void 0, void 0, function* () {
    // no-op logger
    const log = new logger_1.Logger((s) => { }, logger_1.LogLevel.INFO);
    const requestBuilder = (0, utils_1.getRequestBuilder)({
        apiKey,
        baseUrl: 'https://api.' + datadogSite,
    });
    yield (0, gitdb_1.uploadToGitDB)(log, requestBuilder, simpleGit, false, repositoryURL);
});
// uploadToSrcmapTrack uploads the payload with tracked files to the sourcemap intake
// this will be deprecated in the future, as we're transitioning to GitDB
const uploadToSrcmapTrack = (apiKey, datadogSite, payload) => __awaiter(void 0, void 0, void 0, function* () {
    const apiKeyValidator = (0, apikey_1.newApiKeyValidator)({
        apiKey,
        datadogSite,
    });
    const requestBuilder = (0, utils_1.getRequestBuilder)({
        apiKey,
        baseUrl: 'https://sourcemap-intake.' + datadogSite,
        headers: new Map([
            ['DD-EVP-ORIGIN', 'datadog-ci_sci'],
            ['DD-EVP-ORIGIN-VERSION', version_1.version],
        ]),
        overrideUrl: 'api/v2/srcmap',
    });
    const status = yield (0, exports.uploadRepository)(requestBuilder, version_1.version)(payload, {
        apiKeyValidator,
        onError: (e) => {
            throw e;
        },
        onRetry: () => {
            // Do nothing
        },
        onUpload: () => {
            return;
        },
        retries: 5,
    });
    if (status !== upload_1.UploadStatus.Success) {
        throw new Error('Error uploading commit information.');
    }
});
const uploadRepository = (requestBuilder, libraryVersion) => (commitInfo, opts) => __awaiter(void 0, void 0, void 0, function* () {
    const payload = commitInfo.asMultipartPayload(libraryVersion);
    return (0, upload_1.upload)(requestBuilder)(payload, opts);
});
exports.uploadRepository = uploadRepository;
//# sourceMappingURL=library.js.map