"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSubscriptionFilters = exports.getSubscriptionFilterState = exports.hasLogGroup = exports.calculateLogGroupRemoveRequest = exports.calculateLogGroupUpdateRequest = exports.putSubscriptionFilter = exports.deleteSubscriptionFilter = exports.createLogGroup = exports.applyLogGroupConfig = exports.SubscriptionState = void 0;
const client_cloudwatch_logs_1 = require("@aws-sdk/client-cloudwatch-logs");
const constants_1 = require("./constants");
var SubscriptionState;
(function (SubscriptionState) {
    SubscriptionState[SubscriptionState["Empty"] = 0] = "Empty";
    SubscriptionState[SubscriptionState["CorrectDestination"] = 1] = "CorrectDestination";
    SubscriptionState[SubscriptionState["WrongDestinationOwned"] = 2] = "WrongDestinationOwned";
    SubscriptionState[SubscriptionState["WrongDestinationUnowned"] = 3] = "WrongDestinationUnowned";
})(SubscriptionState || (exports.SubscriptionState = SubscriptionState = {}));
const MAX_LOG_GROUP_SUBSCRIPTIONS = 2;
const applyLogGroupConfig = (client, config) => __awaiter(void 0, void 0, void 0, function* () {
    const { createLogGroupCommandInput, deleteSubscriptionFilterCommandInput, putSubscriptionFilterCommandInput } = config;
    if (createLogGroupCommandInput !== undefined) {
        yield (0, exports.createLogGroup)(client, createLogGroupCommandInput);
    }
    if (deleteSubscriptionFilterCommandInput !== undefined) {
        yield (0, exports.deleteSubscriptionFilter)(client, deleteSubscriptionFilterCommandInput);
    }
    if (putSubscriptionFilterCommandInput !== undefined) {
        yield (0, exports.putSubscriptionFilter)(client, putSubscriptionFilterCommandInput);
    }
});
exports.applyLogGroupConfig = applyLogGroupConfig;
const createLogGroup = (client, input) => __awaiter(void 0, void 0, void 0, function* () {
    const command = new client_cloudwatch_logs_1.CreateLogGroupCommand(input);
    yield client.send(command);
});
exports.createLogGroup = createLogGroup;
const deleteSubscriptionFilter = (client, input) => __awaiter(void 0, void 0, void 0, function* () {
    const command = new client_cloudwatch_logs_1.DeleteSubscriptionFilterCommand(input);
    yield client.send(command);
});
exports.deleteSubscriptionFilter = deleteSubscriptionFilter;
const putSubscriptionFilter = (client, input) => __awaiter(void 0, void 0, void 0, function* () {
    const command = new client_cloudwatch_logs_1.PutSubscriptionFilterCommand(input);
    yield client.send(command);
});
exports.putSubscriptionFilter = putSubscriptionFilter;
const calculateLogGroupUpdateRequest = (client, logGroupName, forwarderARN) => __awaiter(void 0, void 0, void 0, function* () {
    const config = {
        logGroupName,
        putSubscriptionFilterCommandInput: {
            destinationArn: forwarderARN,
            filterName: constants_1.SUBSCRIPTION_FILTER_NAME,
            filterPattern: '',
            logGroupName,
        },
    };
    const logGroupPresent = yield (0, exports.hasLogGroup)(client, logGroupName);
    let subscriptionState = SubscriptionState.Empty;
    if (logGroupPresent) {
        subscriptionState = yield (0, exports.getSubscriptionFilterState)(client, logGroupName, forwarderARN);
    }
    else {
        config.createLogGroupCommandInput = {
            logGroupName,
        };
    }
    if (subscriptionState === SubscriptionState.CorrectDestination) {
        // All up to date, nothing to be done
        return;
    }
    if (subscriptionState === SubscriptionState.WrongDestinationUnowned) {
        // Can't update, don't own the subscription
        throw Error(`Maximum of ${MAX_LOG_GROUP_SUBSCRIPTIONS} subscription filters already exist on log group ${logGroupName}. Cannot add Datadog forwarder subscription.`);
    }
    return config;
});
exports.calculateLogGroupUpdateRequest = calculateLogGroupUpdateRequest;
const calculateLogGroupRemoveRequest = (client, logGroupName, forwarderARN) => __awaiter(void 0, void 0, void 0, function* () {
    const config = {
        logGroupName,
    };
    const subscriptionFilters = yield (0, exports.getSubscriptionFilters)(client, logGroupName);
    const subscriptionToRemove = subscriptionFilters === null || subscriptionFilters === void 0 ? void 0 : subscriptionFilters.find((subscription) => subscription.destinationArn === forwarderARN || subscription.filterName === constants_1.SUBSCRIPTION_FILTER_NAME);
    if (subscriptionToRemove) {
        config.deleteSubscriptionFilterCommandInput = {
            filterName: subscriptionToRemove.filterName,
            logGroupName,
        };
    }
    return config;
});
exports.calculateLogGroupRemoveRequest = calculateLogGroupRemoveRequest;
const hasLogGroup = (client, logGroupName) => __awaiter(void 0, void 0, void 0, function* () {
    const input = {
        logGroupNamePrefix: logGroupName,
    };
    const command = new client_cloudwatch_logs_1.DescribeLogGroupsCommand(input);
    const response = yield client.send(command);
    const { logGroups } = response;
    if (logGroups === undefined || logGroups.length === 0) {
        return false;
    }
    return logGroups.find((lg) => lg.logGroupName === logGroupName) !== undefined;
});
exports.hasLogGroup = hasLogGroup;
const getSubscriptionFilterState = (client, logGroupName, forwarderARN) => __awaiter(void 0, void 0, void 0, function* () {
    const subscriptionFilters = yield (0, exports.getSubscriptionFilters)(client, logGroupName);
    if (subscriptionFilters === undefined || subscriptionFilters.length === 0) {
        return SubscriptionState.Empty;
    }
    if (subscriptionFilters.find((sf) => sf.destinationArn === forwarderARN) !== undefined) {
        return SubscriptionState.CorrectDestination;
    }
    if (subscriptionFilters.find((sf) => sf.filterName === constants_1.SUBSCRIPTION_FILTER_NAME)) {
        // Subscription filter was created by this CI tool
        return SubscriptionState.WrongDestinationOwned;
    }
    // If a non-Datadog subscription already exists but we are still under the max
    // then we have an empty slot to add the Datadog subscription
    if (subscriptionFilters.length < MAX_LOG_GROUP_SUBSCRIPTIONS) {
        return SubscriptionState.Empty;
    }
    return SubscriptionState.WrongDestinationUnowned;
});
exports.getSubscriptionFilterState = getSubscriptionFilterState;
const getSubscriptionFilters = (client, logGroupName) => __awaiter(void 0, void 0, void 0, function* () {
    const input = {
        logGroupName,
    };
    const command = new client_cloudwatch_logs_1.DescribeSubscriptionFiltersCommand(input);
    const response = yield client.send(command);
    const { subscriptionFilters } = response;
    return subscriptionFilters;
});
exports.getSubscriptionFilters = getSubscriptionFilters;
//# sourceMappingURL=loggroup.js.map