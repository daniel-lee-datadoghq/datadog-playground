"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCoverageDetailsUrl = exports.validateCoverageReport = exports.detectFormat = exports.toCoverageFormat = exports.isCoverageFormat = exports.coverageFormats = exports.cloverFormat = exports.simplecovInternalFormat = exports.simplecovFormat = exports.coberturaFormat = exports.opencoverFormat = exports.lcovFormat = exports.jacocoFormat = void 0;
const fs_1 = __importDefault(require("fs"));
const fast_xml_parser_1 = require("fast-xml-parser");
const upath_1 = __importDefault(require("upath"));
const app_1 = require("../../helpers/app");
const tags_1 = require("../../helpers/tags");
const renderer_1 = require("./renderer");
const ROOT_TAG_REGEX = /<([^?!\s/>]+)/;
exports.jacocoFormat = 'jacoco';
exports.lcovFormat = 'lcov';
exports.opencoverFormat = 'opencover';
exports.coberturaFormat = 'cobertura';
exports.simplecovFormat = 'simplecov';
exports.simplecovInternalFormat = 'simplecov-internal';
exports.cloverFormat = 'clover';
exports.coverageFormats = [
    exports.jacocoFormat,
    exports.lcovFormat,
    exports.opencoverFormat,
    exports.coberturaFormat,
    exports.simplecovFormat,
    exports.simplecovInternalFormat,
    exports.cloverFormat,
];
const isCoverageFormat = (value) => {
    return exports.coverageFormats.includes(value);
};
exports.isCoverageFormat = isCoverageFormat;
const toCoverageFormat = (value) => {
    if (value === undefined) {
        return undefined;
    }
    if ((0, exports.isCoverageFormat)(value)) {
        return value;
    }
    throw new Error(`Invalid coverage format: ${value}`);
};
exports.toCoverageFormat = toCoverageFormat;
const detectFormat = (filePath) => {
    if (!fs_1.default.existsSync(filePath)) {
        return undefined;
    }
    const lowercaseFile = filePath.toLowerCase();
    const filename = upath_1.default.basename(lowercaseFile);
    const extension = upath_1.default.extname(lowercaseFile);
    if (extension === '.xml' &&
        (filename.includes('coverage') ||
            filename.includes('jacoco') ||
            filename.includes('cobertura') ||
            filename.includes('clover'))) {
        return readFirstKb(filePath, (data) => {
            if (data.includes('<CoverageSession')) {
                return exports.opencoverFormat;
            }
            else if ((data.includes('<!DOCTYPE coverage') && data.includes('cobertura.sourceforge.net/xml/coverage')) ||
                (data.includes('<coverage') && data.includes('line-rate='))) {
                return exports.coberturaFormat;
            }
            else if ((data.includes('<!DOCTYPE report') && data.includes('-//JACOCO//DTD Report')) ||
                data.includes('<report')) {
                return exports.jacocoFormat;
            }
            else if (data.includes('<coverage') && data.includes('<project')) {
                return exports.cloverFormat;
            }
        });
    }
    else if (extension === '.json' && filename.includes('coverage')) {
        return readFirstKb(filePath, (data) => {
            if (data.includes('simplecov_version')) {
                return exports.simplecovFormat;
            }
        });
    }
    else if (filename === '.resultset.json') {
        return readFirstKb(filePath, (data) => {
            if (data.includes('coverage') && data.includes('lines')) {
                return exports.simplecovInternalFormat;
            }
        });
    }
    else if (extension === '.lcov' ||
        extension === '.lcov.info' ||
        extension === '.lcov-report.info' ||
        filename === 'lcov.info' ||
        filename === 'lcov-report.info' ||
        filename === 'lcov.dat') {
        return readFirstKb(filePath, (data) => {
            return data.startsWith('TN:') || data.startsWith('SF:') ? exports.lcovFormat : undefined;
        });
    }
    return undefined;
};
exports.detectFormat = detectFormat;
const readFirstKb = (filePath, action) => {
    let fd;
    try {
        fd = fs_1.default.openSync(filePath, 'r');
        const buffer = Buffer.alloc(1024);
        fs_1.default.readSync(fd, buffer, 0, 1024, 0);
        const data = buffer.toString('utf8');
        return action(data);
    }
    catch (error) {
        (0, renderer_1.renderFileReadError)(filePath, error);
        return undefined;
    }
    finally {
        if (fd !== undefined) {
            fs_1.default.closeSync(fd);
        }
    }
};
const validateCoverageReport = (filePath, format) => {
    if (format === exports.jacocoFormat) {
        const xmlFileContentString = String(fs_1.default.readFileSync(filePath));
        const validationOutput = fast_xml_parser_1.XMLValidator.validate(xmlFileContentString);
        if (validationOutput !== true) {
            return validationOutput.err.msg;
        }
        // Check that the root element is 'report' and that the report contains sourcefile tags
        const rootTagMatch = xmlFileContentString.match(ROOT_TAG_REGEX);
        if (!rootTagMatch || rootTagMatch[1] !== 'report') {
            return 'Invalid Jacoco report: root element must be <report>';
        }
        if (!xmlFileContentString.includes('<sourcefile')) {
            return 'Invalid Jacoco report: missing <sourcefile> tags';
        }
    }
    if (format === exports.opencoverFormat) {
        const xmlFileContentString = String(fs_1.default.readFileSync(filePath));
        const validationOutput = fast_xml_parser_1.XMLValidator.validate(xmlFileContentString);
        if (validationOutput !== true) {
            return validationOutput.err.msg;
        }
        // Check that the root element is 'CoverageSession'
        const rootTagMatch = xmlFileContentString.match(ROOT_TAG_REGEX);
        if (!rootTagMatch || rootTagMatch[1] !== 'CoverageSession') {
            return 'Invalid Opencover report: root element must be <CoverageSession>';
        }
    }
    if (format === exports.coberturaFormat) {
        const xmlFileContentString = String(fs_1.default.readFileSync(filePath));
        const validationOutput = fast_xml_parser_1.XMLValidator.validate(xmlFileContentString);
        if (validationOutput !== true) {
            return validationOutput.err.msg;
        }
        // Check that the root element is 'coverage'
        const rootTagMatch = xmlFileContentString.match(ROOT_TAG_REGEX);
        if (!rootTagMatch || rootTagMatch[1] !== 'coverage') {
            return 'Invalid Cobertura report: root element must be <coverage>';
        }
    }
    if (format === exports.cloverFormat) {
        const xmlFileContentString = String(fs_1.default.readFileSync(filePath));
        const validationOutput = fast_xml_parser_1.XMLValidator.validate(xmlFileContentString);
        if (validationOutput !== true) {
            return validationOutput.err.msg;
        }
        // Check that the root element is 'coverage'
        const rootTagMatch = xmlFileContentString.match(ROOT_TAG_REGEX);
        if (!rootTagMatch || rootTagMatch[1] !== 'coverage') {
            return 'Invalid Clover report: root element must be <coverage>';
        }
    }
    if (format === exports.simplecovFormat) {
        try {
            const jsonContent = String(fs_1.default.readFileSync(filePath));
            const simplecovReport = JSON.parse(jsonContent);
            if (!simplecovReport['coverage']) {
                return `Invalid simplecov report: missing "meta" or "coverage" top-level fields`;
            }
            for (const [fileName, fileCoverage] of Object.entries(simplecovReport['coverage'])) {
                if (!fileCoverage['lines']) {
                    return `Invalid simplecov report: file ${fileName} is missing "lines" field`;
                }
            }
        }
        catch (err) {
            return `Invalid simplecov report: could not parse JSON: ${err}`;
        }
    }
    if (format === exports.simplecovInternalFormat) {
        try {
            const jsonContent = String(fs_1.default.readFileSync(filePath));
            const simplecovInternalReport = JSON.parse(jsonContent);
            for (const [specName, s] of Object.entries(simplecovInternalReport)) {
                const spec = s;
                if (!spec['coverage']) {
                    return `Invalid internal simplecov report: spec ${specName} is missing "coverage" field`;
                }
                for (const [fileName, fileCoverage] of Object.entries(spec['coverage'])) {
                    if (!fileCoverage['lines']) {
                        return `Invalid internal simplecov report: file ${fileName} is missing "lines" field`;
                    }
                }
            }
        }
        catch (err) {
            return `Invalid internal simplecov report: could not parse JSON: ${err}`;
        }
    }
    if (format === exports.lcovFormat) {
        const content = fs_1.default.readFileSync(filePath, 'utf8');
        if (!content.startsWith('TN:') && !content.startsWith('SF:')) {
            return 'Invalid LCOV report: must start with TN: or SF:';
        }
        const lines = content.split(/\r?\n/).filter((line) => line.trim().length > 0);
        const hasData = lines.some((line) => line.startsWith('DA:'));
        if (!hasData) {
            return 'Invalid LCOV report: missing DA: lines';
        }
        const endsCorrectly = lines[lines.length - 1] === 'end_of_record';
        if (!endsCorrectly) {
            return 'Invalid LCOV report: does not end with "end_of_record"';
        }
    }
    return undefined;
};
exports.validateCoverageReport = validateCoverageReport;
const getCoverageDetailsUrl = (spanTags) => {
    const repoUrl = spanTags[tags_1.GIT_REPOSITORY_URL];
    if (!repoUrl) {
        return '';
    }
    const prNumber = spanTags[tags_1.PR_NUMBER];
    if (!prNumber) {
        return '';
    }
    const escapedPrNumber = encodeURIComponent(prNumber);
    const escapedRepoUrl = encodeURIComponent(repoUrl);
    return `${(0, app_1.getBaseUrl)()}api/ui/code-coverage/redirect/pull-requests/${escapedPrNumber}?repository_url=${escapedRepoUrl}`;
};
exports.getCoverageDetailsUrl = getCoverageDetailsUrl;
//# sourceMappingURL=utils.js.map