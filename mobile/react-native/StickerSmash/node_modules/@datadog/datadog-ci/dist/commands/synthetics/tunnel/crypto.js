"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSSHKey = exports.generateOpenSSHKeys = void 0;
const crypto_1 = require("crypto");
const ssh2_1 = require("ssh2");
const sshpk_1 = require("sshpk");
// Generate public/private key in OpenSSH format (used for encryption in tunnel over SSH)
const generateOpenSSHKeys = () => {
    const format = 'pem';
    const { publicKey, privateKey } = (0, crypto_1.generateKeyPairSync)('ec', {
        namedCurve: 'P-256',
        privateKeyEncoding: {
            format,
            type: 'pkcs8',
        },
        publicKeyEncoding: {
            format,
            type: 'spki',
        },
    });
    const openSSHPublicKey = (0, sshpk_1.parseKey)(publicKey, format).toBuffer('ssh', {}).toString('utf-8');
    const openSSHPrivateKey = (0, sshpk_1.parsePrivateKey)(privateKey, format).toBuffer('ssh', {}).toString('utf-8');
    return {
        privateKey: openSSHPrivateKey,
        publicKey: openSSHPublicKey,
    };
};
exports.generateOpenSSHKeys = generateOpenSSHKeys;
// Parse SSH key for ssh2 module
const parseSSHKey = (key) => {
    const parsedKey = ssh2_1.utils.parseKey(key);
    if (!parsedKey) {
        throw new Error(`Invalid key ${key}`);
    }
    if (parsedKey instanceof Error) {
        throw parsedKey;
    }
    if (parsedKey instanceof Array) {
        // Multiple keys could be concatenated - in our use cases, a single key is expected
        if (parsedKey.length === 0) {
            throw new Error(`Invalid key ${key}`);
        }
        return parsedKey[0];
    }
    return parsedKey;
};
exports.parseSSHKey = parseSSHKey;
//# sourceMappingURL=crypto.js.map