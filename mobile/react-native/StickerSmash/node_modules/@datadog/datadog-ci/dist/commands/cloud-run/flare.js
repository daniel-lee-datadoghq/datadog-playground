"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateInsightsFile = exports.getRecentRevisions = exports.saveLogsFile = exports.getLogs = exports.summarizeConfig = exports.maskConfig = exports.getCloudRunServiceConfig = exports.CloudRunFlareCommand = exports.MAX_LOGS = void 0;
const fs_1 = __importDefault(require("fs"));
const process_1 = __importDefault(require("process"));
const util_1 = __importDefault(require("util"));
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const upath_1 = __importDefault(require("upath"));
const constants_1 = require("../../constants");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const flare_1 = require("../../helpers/flare");
const fs_2 = require("../../helpers/fs");
const prompt_1 = require("../../helpers/prompt");
const helpersRenderer = __importStar(require("../../helpers/renderer"));
const renderer_1 = require("../../helpers/renderer");
const utils_1 = require("../../helpers/utils");
const version_1 = require("../../helpers/version");
const flare_2 = require("../lambda/flare");
const constants_2 = require("./constants");
const renderer_2 = require("./renderer");
const utils_2 = require("./utils");
// XXX temporary workaround for @google-cloud/run ESM/CJS module issues
const { RevisionsClient, ServicesClient } = require('@google-cloud/run');
const SERVICE_CONFIG_FILE_NAME = 'service_config.json';
const FLARE_ZIP_FILE_NAME = 'cloud-run-flare-output.zip';
const ALL_LOGS_FILE_NAME = 'all_logs.csv';
const WARNING_LOGS_FILE_NAME = 'warning_logs.csv';
const ERRORS_LOGS_FILE_NAME = 'error_logs.csv';
const DEBUG_LOGS_FILE_NAME = 'debug_logs.csv';
// What's the maximum number of revisions we want to include? Too many revisions will flood the INSIGHTS.md file
const MAX_REVISIONS = 10;
// Must be in range 0 - 1000. If more logs are needed, pagination must be implemented
exports.MAX_LOGS = 1000;
// How old the logs can be in minutes. Skip older logs
const MAX_LOG_AGE_MINUTES = 1440;
const FILTER_ORDER = 'timestamp asc';
// Types of log files to create
const LOG_CONFIGS = [
    { type: 'total', fileName: ALL_LOGS_FILE_NAME },
    { type: 'warning', severityFilter: ' AND severity>="WARNING"', fileName: WARNING_LOGS_FILE_NAME },
    { type: 'error', severityFilter: ' AND severity>="ERROR"', fileName: ERRORS_LOGS_FILE_NAME },
    { type: 'debug', severityFilter: ' AND severity="DEBUG"', fileName: DEBUG_LOGS_FILE_NAME },
];
class CloudRunFlareCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.isDryRun = clipanion_1.Option.Boolean('-d,--dry,--dry-run', false);
        this.withLogs = clipanion_1.Option.Boolean('--with-logs', false);
        this.service = clipanion_1.Option.String('-s,--service');
        this.project = clipanion_1.Option.String('-p,--project');
        this.region = clipanion_1.Option.String('-r,--region,-l,--location');
        this.caseId = clipanion_1.Option.String('-c,--case-id');
        this.email = clipanion_1.Option.String('-e,--email');
        this.start = clipanion_1.Option.String('--start');
        this.end = clipanion_1.Option.String('--end');
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.config = {
            fips: (_a = (0, env_1.toBoolean)(process_1.default.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process_1.default.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
    }
    /**
     * Entry point for the `cloud-run flare` command.
     * Gathers Cloud Run service configuration and sends it to Datadog.
     * @returns 0 if the command ran successfully, 1 otherwise.
     */
    execute() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.config.fips, this.fipsIgnoreError || this.config.fipsIgnoreError);
            yield (0, flare_1.validateCliVersion)(this.context.stdout);
            this.context.stdout.write(helpersRenderer.renderFlareHeader('Cloud Run', this.isDryRun));
            const errorMessages = [];
            // Validate service
            if (this.service === undefined) {
                errorMessages.push(helpersRenderer.renderError('No service specified. [-s,--service]'));
            }
            // Validate project
            if (this.project === undefined) {
                errorMessages.push(helpersRenderer.renderError('No project specified. [-p,--project]'));
            }
            // Validate region
            if (this.region === undefined) {
                errorMessages.push(helpersRenderer.renderError('No region specified. [-r,--region]'));
            }
            // Validate Datadog API key
            this.apiKey = (_a = process_1.default.env[constants_1.CI_API_KEY_ENV_VAR]) !== null && _a !== void 0 ? _a : process_1.default.env[constants_1.API_KEY_ENV_VAR];
            if (this.apiKey === undefined) {
                errorMessages.push(helpersRenderer.renderError('No Datadog API key specified. Set an API key with the DD_API_KEY environment variable.'));
            }
            // Validate case ID
            if (this.caseId === undefined) {
                errorMessages.push(helpersRenderer.renderError('No case ID specified. [-c,--case-id]'));
            }
            // Validate email
            if (this.email === undefined) {
                errorMessages.push(helpersRenderer.renderError('No email specified. [-e,--email]'));
            }
            // Validate start/end flags if both are specified
            let startMillis;
            let endMillis;
            try {
                ;
                [startMillis, endMillis] = (0, flare_1.validateStartEndFlags)(this.start, this.end);
            }
            catch (err) {
                if (err instanceof Error) {
                    errorMessages.push(helpersRenderer.renderError(err.message));
                }
            }
            // If there are errors, print them and exit
            if (errorMessages.length > 0) {
                for (const message of errorMessages) {
                    this.context.stderr.write(message);
                }
                return 1;
            }
            // Verify GCP credentials
            this.context.stdout.write(chalk_1.default.bold('\nüîë Verifying GCP credentials...\n'));
            const authenticated = yield (0, utils_2.checkAuthentication)();
            if (!authenticated) {
                this.context.stderr.write((0, renderer_2.renderAuthenticationInstructions)());
                return 1;
            }
            this.context.stdout.write('GCP credentials verified!\n');
            // Get and print service configuration
            this.context.stdout.write(chalk_1.default.bold('\nüîç Fetching service configuration...\n'));
            const runClient = new ServicesClient();
            let config;
            try {
                config = yield (0, exports.getCloudRunServiceConfig)(runClient, this.service, this.project, this.region);
            }
            catch (err) {
                if (err instanceof Error) {
                    this.context.stderr.write(helpersRenderer.renderError(`Unable to fetch service configuration: ${err.message}`));
                }
                return 1;
            }
            config = (0, exports.maskConfig)(config);
            const summarizedConfig = (0, exports.summarizeConfig)(config);
            // 10 is the depth when inspecting the config file. Cloud-run configs have high depth, so
            // we must raise the depth from the default depth of 2.
            const summarizedConfigStr = util_1.default.inspect(summarizedConfig, false, 10, true);
            this.context.stdout.write(`\n${summarizedConfigStr}\n`);
            this.context.stdout.write(chalk_1.default.italic(`(This is a summary of the configuration. The full configuration will be saved in "${SERVICE_CONFIG_FILE_NAME}".)\n`));
            // Get project files
            this.context.stdout.write(chalk_1.default.bold('\nüìÅ Searching for project files in current directory...\n'));
            const projectFilePaths = yield (0, flare_1.getProjectFiles)(constants_1.FLARE_PROJECT_FILES);
            this.context.stdout.write((0, renderer_1.renderProjectFiles)(projectFilePaths));
            // Additional files
            this.context.stdout.write('\n');
            const additionalFilePaths = new Set();
            let confirmAdditionalFiles;
            try {
                confirmAdditionalFiles = yield (0, prompt_1.requestConfirmation)('Do you want to specify any additional files to flare?', false);
            }
            catch (err) {
                if (err instanceof Error) {
                    this.context.stderr.write(helpersRenderer.renderError(err.message));
                }
                return 1;
            }
            while (confirmAdditionalFiles) {
                this.context.stdout.write('\n');
                let filePath;
                try {
                    filePath = yield (0, prompt_1.requestFilePath)();
                }
                catch (err) {
                    if (err instanceof Error) {
                        this.context.stderr.write(helpersRenderer.renderError(err.message));
                    }
                    return 1;
                }
                if (filePath === '') {
                    this.context.stdout.write((0, renderer_1.renderAdditionalFiles)(additionalFilePaths));
                    break;
                }
                try {
                    filePath = (0, flare_1.validateFilePath)(filePath, projectFilePaths, additionalFilePaths);
                    additionalFilePaths.add(filePath);
                    const fileName = upath_1.default.basename(filePath);
                    this.context.stdout.write(`‚Ä¢ Added file '${fileName}'\n`);
                }
                catch (err) {
                    if (err instanceof Error) {
                        this.context.stderr.write(err.message);
                    }
                }
            }
            // Get recent revisions, which will be used to generate insights file
            this.context.stdout.write(chalk_1.default.bold('\nüåß Fetching recent revisions...\n'));
            let revisions = [];
            try {
                revisions = yield (0, exports.getRecentRevisions)(this.service, this.region, this.project);
                this.context.stdout.write(`‚Ä¢ Found ${revisions.length} revisions\n`);
            }
            catch (err) {
                const errorDetails = err instanceof Error ? err.message : '';
                this.context.stdout.write(helpersRenderer.renderSoftWarning(`Unable to fetch recent revisions. ${errorDetails}`));
            }
            // Get logs
            const logFileMappings = new Map();
            if (this.withLogs) {
                this.context.stdout.write(chalk_1.default.bold('\nüìñ Getting logs...\n'));
                const { Logging } = yield import('@google-cloud/logging');
                const logClient = new Logging({ projectId: this.project });
                for (const logConfig of LOG_CONFIGS) {
                    try {
                        const logs = yield (0, exports.getLogs)(logClient, this.service, this.region, startMillis, endMillis, logConfig.severityFilter);
                        if (logs.length === 0) {
                            this.context.stdout.write(`‚Ä¢ No ${logConfig.type} logs were found\n`);
                        }
                        else {
                            this.context.stdout.write(`‚Ä¢ Found ${logs.length} ${logConfig.type} logs\n`);
                            logFileMappings.set(logConfig.fileName, logs);
                        }
                    }
                    catch (err) {
                        const msg = err instanceof Error ? err.message : '';
                        this.context.stderr.write(`‚Ä¢ Unable to get ${logConfig.type} logs: ${msg}\n`);
                    }
                }
            }
            try {
                // Create folders
                const rootFolderPath = upath_1.default.join(process_1.default.cwd(), constants_1.FLARE_OUTPUT_DIRECTORY);
                const logsFolderPath = upath_1.default.join(rootFolderPath, constants_1.LOGS_DIRECTORY);
                const projectFilesFolderPath = upath_1.default.join(rootFolderPath, constants_1.PROJECT_FILES_DIRECTORY);
                const additionalFilesFolderPath = upath_1.default.join(rootFolderPath, constants_1.ADDITIONAL_FILES_DIRECTORY);
                this.context.stdout.write(chalk_1.default.bold(`\nüíæ Saving files to ${rootFolderPath}...\n`));
                if (fs_1.default.existsSync(rootFolderPath)) {
                    (0, fs_2.deleteFolder)(rootFolderPath);
                }
                const subFolders = [];
                if (logFileMappings.size > 0) {
                    subFolders.push(logsFolderPath);
                }
                if (projectFilePaths.size > 0) {
                    subFolders.push(projectFilesFolderPath);
                }
                if (additionalFilePaths.size > 0) {
                    subFolders.push(additionalFilesFolderPath);
                }
                (0, fs_2.createDirectories)(rootFolderPath, subFolders);
                // Write config file
                const configFilePath = upath_1.default.join(rootFolderPath, SERVICE_CONFIG_FILE_NAME);
                (0, fs_2.writeFile)(configFilePath, JSON.stringify(config, undefined, 2));
                this.context.stdout.write(`‚Ä¢ Saved function config to ./${SERVICE_CONFIG_FILE_NAME}\n`);
                // Write logs
                for (const [fileName, logs] of logFileMappings) {
                    const logFilePath = upath_1.default.join(logsFolderPath, fileName);
                    (0, exports.saveLogsFile)(logs, logFilePath);
                    this.context.stdout.write(`‚Ä¢ Saved logs to ./${constants_1.LOGS_DIRECTORY}/${fileName}\n`);
                }
                // Write project files
                for (const filePath of projectFilePaths) {
                    const fileName = upath_1.default.basename(filePath);
                    const newFilePath = upath_1.default.join(projectFilesFolderPath, fileName);
                    fs_1.default.copyFileSync(filePath, newFilePath);
                    this.context.stdout.write(`‚Ä¢ Copied ${fileName} to ./${constants_1.PROJECT_FILES_DIRECTORY}/${fileName}\n`);
                }
                // Write additional files
                const additionalFilesMap = (0, flare_2.getUniqueFileNames)(additionalFilePaths);
                for (const [originalFilePath, newFileName] of additionalFilesMap) {
                    const originalFileName = upath_1.default.basename(originalFilePath);
                    const newFilePath = upath_1.default.join(additionalFilesFolderPath, newFileName);
                    fs_1.default.copyFileSync(originalFilePath, newFilePath);
                    this.context.stdout.write(`‚Ä¢ Copied ${originalFileName} to ./${constants_1.ADDITIONAL_FILES_DIRECTORY}/${newFileName}\n`);
                }
                // Write insights file
                try {
                    const insightsFilePath = upath_1.default.join(rootFolderPath, constants_1.INSIGHTS_FILE_NAME);
                    (0, exports.generateInsightsFile)(insightsFilePath, this.isDryRun, config, this.service, this.region, this.project, revisions);
                    this.context.stdout.write(`‚Ä¢ Saved insights file to ./${constants_1.INSIGHTS_FILE_NAME}\n`);
                }
                catch (err) {
                    const errorDetails = err instanceof Error ? err.message : '';
                    this.context.stdout.write(helpersRenderer.renderSoftWarning(`Unable to create INSIGHTS.md file. ${errorDetails}`));
                }
                // Exit if dry run
                const outputMsg = `\n‚ÑπÔ∏è Your output files are located at: ${rootFolderPath}\n\n`;
                if (this.isDryRun) {
                    this.context.stdout.write('\nüö´ The flare files were not sent because the command was executed in dry run mode.');
                    this.context.stdout.write(outputMsg);
                    return 0;
                }
                // Confirm before sending
                this.context.stdout.write('\n');
                const confirmSendFiles = yield (0, prompt_1.requestConfirmation)('Are you sure you want to send the flare file to Datadog Support?', false);
                if (!confirmSendFiles) {
                    this.context.stdout.write('\nüö´ The flare files were not sent based on your selection.');
                    this.context.stdout.write(outputMsg);
                    return 0;
                }
                // Zip folder
                const zipPath = upath_1.default.join(rootFolderPath, FLARE_ZIP_FILE_NAME);
                yield (0, fs_2.zipContents)(rootFolderPath, zipPath);
                // Send to Datadog
                this.context.stdout.write(chalk_1.default.bold('\nüöÄ Sending to Datadog Support...\n'));
                yield (0, flare_1.sendToDatadog)(zipPath, this.caseId, this.email, this.apiKey, rootFolderPath);
                this.context.stdout.write(chalk_1.default.bold('\n‚úÖ Successfully sent flare file to Datadog Support!\n'));
                // Delete contents
                (0, fs_2.deleteFolder)(rootFolderPath);
            }
            catch (err) {
                if (err instanceof Error) {
                    this.context.stderr.write(helpersRenderer.renderError(err.message));
                }
                return 1;
            }
            return 0;
        });
    }
}
exports.CloudRunFlareCommand = CloudRunFlareCommand;
CloudRunFlareCommand.paths = [['cloud-run', 'flare']];
CloudRunFlareCommand.usage = clipanion_1.Command.Usage({
    category: 'Serverless',
    description: 'Gather Cloud Run service configuration and sends it to Datadog.',
});
/**
 * Call the google-cloud run sdk to get the configuration
 * for the given service.
 * @param runClient the google-cloud run sdk client
 * @param serviceName the name of the service
 * @param projectName the project where the service is deployed
 * @param region the region where the service is deployed
 * @returns the configuration for the given service
 */
const getCloudRunServiceConfig = (runClient, serviceName, projectName, region) => __awaiter(void 0, void 0, void 0, function* () {
    const request = {
        name: runClient.servicePath(projectName, region, serviceName),
    };
    const [response] = yield runClient.getService(request);
    return response;
});
exports.getCloudRunServiceConfig = getCloudRunServiceConfig;
/**
 * Masks environment variables in a Cloud Run service configuration.
 * Makes a copy as to not modify the config in place.
 * @param config
 * @returns masked config
 */
const maskConfig = (config) => {
    var _a, _b;
    // We stringify and parse again to make a deep copy
    const configCopy = JSON.parse(JSON.stringify(config));
    const containers = (_a = configCopy.template) === null || _a === void 0 ? void 0 : _a.containers;
    if (!containers) {
        return configCopy;
    }
    for (const container of containers) {
        const env = (_b = container.env) !== null && _b !== void 0 ? _b : [];
        for (const envVar of env) {
            const name = envVar.name;
            const val = envVar.value;
            if (!name || !val) {
                continue;
            }
            if (!constants_2.SKIP_MASKING_CLOUDRUN_ENV_VARS.has(name)) {
                envVar.value = (0, utils_1.maskString)(val);
            }
        }
    }
    return configCopy;
};
exports.maskConfig = maskConfig;
/**
 * Summarizes the Cloud Run config as to not flood the terminal
 * @param config
 * @returns a summarized config
 */
const summarizeConfig = (config) => {
    var _a;
    const summarizedConfig = {};
    summarizedConfig.name = config.name;
    summarizedConfig.uid = config.uid;
    summarizedConfig.uri = config.uri;
    // Get env vars and image for each containers
    const template = config.template;
    if (template) {
        const summarizedContainers = [];
        const containers = (_a = template.containers) !== null && _a !== void 0 ? _a : [];
        containers.forEach((container) => {
            const summarizedContainer = {};
            summarizedContainer.env = container.env;
            summarizedContainer.image = container.image;
            summarizedContainers.push(summarizedContainer);
        });
        summarizedConfig.containers = summarizedContainers;
    }
    return summarizedConfig;
};
exports.summarizeConfig = summarizeConfig;
/**
 * Gets recent logs
 * @param logClient Logging client
 * @param serviceId
 * @param location
 * @param startMillis start time in milliseconds or undefined if no start time is specified
 * @param endMillis end time in milliseconds or undefined if no end time is specified
 * @param severityFilter if included, adds the string to the filter
 * @returns array of logs as CloudRunLog interfaces
 */
const getLogs = (logClient, serviceId, location, startMillis, endMillis, severityFilter) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const logs = [];
    // Default to the recent logs using MAX_LOG_AGE_MINUTES
    const date = new Date();
    date.setMinutes(date.getMinutes() - MAX_LOG_AGE_MINUTES);
    let startDate = date.toISOString();
    let endDate = new Date().toISOString(); // Current time
    // If startMillis and endMillis are provided, use them to set the date range
    if (startMillis && endMillis) {
        startDate = new Date(startMillis).toISOString();
        endDate = new Date(endMillis).toISOString();
    }
    // Query options
    let filter = `resource.labels.service_name="${serviceId}" AND resource.labels.location="${location}" AND timestamp>="${startDate}" AND timestamp<="${endDate}" AND (textPayload:* OR httpRequest:*)`;
    // We only want to include logs with a textPayload or logs that were an HTTP request.
    // Any other logs are just audit logs which are spammy and don't have any relevant information.
    filter += severityFilter !== null && severityFilter !== void 0 ? severityFilter : '';
    const options = {
        filter,
        orderBy: FILTER_ORDER,
        pageSize: exports.MAX_LOGS,
    };
    const [entries] = yield logClient.getEntries(options);
    for (const entry of entries) {
        let msg = '';
        if (entry.metadata.textPayload) {
            msg = entry.metadata.textPayload;
        }
        if (entry.metadata.httpRequest) {
            const request = entry.metadata.httpRequest;
            const status = (_a = request.status) !== null && _a !== void 0 ? _a : '';
            let ms = 'unknown';
            const latency = request.latency;
            if (latency) {
                ms = (Number(latency.seconds) * 1000 + Math.round(Number(latency.nanos) / 1000000)).toString();
            }
            const bytes = (0, utils_1.formatBytes)(Number(request.responseSize));
            const method = (_b = request.requestMethod) !== null && _b !== void 0 ? _b : '';
            const requestUrl = (_c = request.requestUrl) !== null && _c !== void 0 ? _c : '';
            msg += `${method} ${status}. responseSize: ${bytes}. latency: ${ms} ms. requestUrl: ${requestUrl}`;
        }
        const log = {
            severity: (_e = (_d = entry.metadata.severity) === null || _d === void 0 ? void 0 : _d.toString()) !== null && _e !== void 0 ? _e : '',
            timestamp: (_g = (_f = entry.metadata.timestamp) === null || _f === void 0 ? void 0 : _f.toString()) !== null && _g !== void 0 ? _g : '',
            logName: (_h = entry.metadata.logName) !== null && _h !== void 0 ? _h : '',
            message: `"${msg}"`,
        };
        logs.push(log);
    }
    return logs;
});
exports.getLogs = getLogs;
/**
 * Save logs in a CSV format
 * @param logs array of logs stored as CloudRunLog interfaces
 * @param filePath path to save the CSV file
 */
const saveLogsFile = (logs, filePath) => {
    const rows = [['severity', 'timestamp', 'logName', 'message']];
    logs.forEach((log) => {
        const severity = `"${log.severity}"`;
        const timestamp = `"${log.timestamp}"`;
        const logName = `"${log.logName}"`;
        const logMessage = `"${log.message}"`;
        rows.push([severity, timestamp, logName, logMessage]);
    });
    const data = rows.join('\n');
    (0, fs_2.writeFile)(filePath, data);
};
exports.saveLogsFile = saveLogsFile;
/**
 * Gets recent revisions for a cloud-run service
 * @param service
 * @param location
 * @param project
 * @returns a string array of recent revisions and their deployment timestamp
 */
const getRecentRevisions = (service, location, project) => __awaiter(void 0, void 0, void 0, function* () {
    var _j;
    const client = new RevisionsClient();
    const request = {
        parent: client.servicePath(project, location, service),
    };
    // listRevisions() returns a tuple [Revision[], Request, Response],
    // so we index the first element to get the array of revisions
    const revisions = (yield client.listRevisions(request))[0];
    const revisionTimestampStrings = [];
    let counter = 1;
    for (const entry of revisions) {
        const fullName = entry.name;
        const timestamp = entry.createTime;
        if (fullName && timestamp) {
            // Get the revision name
            const nameSplit = fullName.split('/');
            const revisionName = nameSplit[nameSplit.length - 1];
            // Format the timestamp by first converting seconds/nanos to milliseconds, then using `new Date()`
            const milliseconds = Number((_j = timestamp.seconds) !== null && _j !== void 0 ? _j : 0) * 1000;
            const timestampString = new Date(milliseconds).toISOString().replace('T', ' ').replace('Z', '').slice(0, -4); // Chop off the milliseconds, which will always be .000
            revisionTimestampStrings.push(`\`${revisionName}\` Deployed on ${timestampString}`);
        }
        // Stop iterating once we reach MAX_REVISIONS
        counter += 1;
        if (counter > MAX_REVISIONS) {
            break;
        }
    }
    return revisionTimestampStrings;
});
exports.getRecentRevisions = getRecentRevisions;
/**
 * Generate the insights file
 * @param insightsFilePath path to the insights file
 * @param isDryRun whether or not this is a dry run
 * @param config Cloud run service configuration
 * @param service
 * @param location
 * @param project
 * @param revisions a string array of recent revisions
 */
const generateInsightsFile = (insightsFilePath, isDryRun, config, service, location, project, revisions) => {
    var _a, _b, _c, _d, _e, _f;
    const lines = [];
    // Header
    lines.push('# Flare Insights');
    lines.push('\n_Autogenerated file from `cloud-run flare`_  ');
    if (isDryRun) {
        lines.push('_This command was run in dry mode._');
    }
    // Cloud Run Service Configuration
    lines.push('\n## Cloud Run Service Configuration');
    lines.push(`**Service Name**: \`${service}\`  `);
    lines.push(`**Location**: \`${location}\`  `);
    lines.push(`**Project**: \`${project}\`  `);
    const description = config.description;
    if (description && description.length > 0) {
        lines.push(`**Description**: \`${description}\`  `);
    }
    lines.push(`**URI**: \`${(_a = config.uri) !== null && _a !== void 0 ? _a : ''}\``);
    // Environment variables
    const containers = (_c = (_b = config.template) === null || _b === void 0 ? void 0 : _b.containers) !== null && _c !== void 0 ? _c : [];
    for (const container of containers) {
        // We want to separate environment variables by container if there are multiple containers
        // We can use the container image to uniquely identify each container
        lines.push(`\n**Environment Variables** (${(_d = container.image) !== null && _d !== void 0 ? _d : 'unknown image'}):`);
        const envVars = new Map();
        for (const envVar of (_e = container.env) !== null && _e !== void 0 ? _e : []) {
            const name = envVar.name;
            const value = envVar.value;
            if (name && value) {
                envVars.set(name, value);
            }
        }
        if (envVars.size === 0) {
            lines.push('- No environment variables found.');
        }
        for (const [key, value] of envVars) {
            lines.push(`- \`${key}\`: \`${value}\``);
        }
    }
    // Labels
    lines.push('\n**Labels**:');
    const labels = (_f = config.labels) !== null && _f !== void 0 ? _f : {};
    const entries = Object.entries(labels);
    if (entries.length === 0) {
        lines.push('- No labels found.');
    }
    for (const [key, value] of entries) {
        lines.push(`- \`${key}\`: \`${value}\``);
    }
    // Recent revisions
    if (revisions.length > 0) {
        lines.push('\n**Recent Revisions**:');
        for (const revision of revisions) {
            lines.push(`- ${revision}`);
        }
    }
    // CLI Insights
    lines.push('\n ## CLI');
    lines.push(`**Run Location**: \`${process_1.default.cwd()}\`  `);
    lines.push(`**CLI Version**: \`${version_1.version}\`  `);
    const timeString = new Date().toISOString().replace('T', ' ').replace('Z', '') + ' UTC';
    lines.push(`**Timestamp**: \`${timeString}\`  `);
    (0, fs_2.writeFile)(insightsFilePath, lines.join('\n'));
};
exports.generateInsightsFile = generateInsightsFile;
//# sourceMappingURL=flare.js.map