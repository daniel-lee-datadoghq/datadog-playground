"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstrumentCommand = void 0;
const client_cloudwatch_logs_1 = require("@aws-sdk/client-cloudwatch-logs");
const client_lambda_1 = require("@aws-sdk/client-lambda");
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const constants_1 = require("../../constants");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const instrument_helpers_1 = require("../../helpers/git/instrument-helpers");
const prompt_1 = require("../../helpers/prompt");
const helperRenderer = __importStar(require("../../helpers/renderer"));
const utils_1 = require("../../helpers/utils");
const constants_2 = require("./constants");
const commons_1 = require("./functions/commons");
const instrument_1 = require("./functions/instrument");
const prompt_2 = require("./prompt");
const commonRenderer = __importStar(require("./renderers/common-renderer"));
const instrumentRenderer = __importStar(require("./renderers/instrument-uninstrument-renderer"));
class InstrumentCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.apmFlushDeadline = clipanion_1.Option.String('--apm-flush-deadline');
        this.appsecEnabled = clipanion_1.Option.Boolean('--appsec', false);
        this.captureLambdaPayload = clipanion_1.Option.String('--capture-lambda-payload,--captureLambdaPayload');
        this.configPath = clipanion_1.Option.String('--config');
        this.dryRun = clipanion_1.Option.Boolean('-d,--dry,--dry-run', false);
        this.environment = clipanion_1.Option.String('--env');
        this.extensionVersion = clipanion_1.Option.String('-e,--extension-version,--extensionVersion');
        this.extraTags = clipanion_1.Option.String('--extra-tags,--extraTags');
        this.flushMetricsToLogs = clipanion_1.Option.String('--flush-metrics-to-logs,--flushMetricsToLogs');
        this.forwarder = clipanion_1.Option.String('--forwarder');
        this.functions = clipanion_1.Option.Array('-f,--function', []);
        this.interactive = clipanion_1.Option.Boolean('-i,--interactive', false);
        this.layerAWSAccount = clipanion_1.Option.String('-a,--layer-account,--layerAccount', { hidden: true });
        this.layerVersion = clipanion_1.Option.String('-v,--layer-version,--layerVersion');
        this.logging = clipanion_1.Option.String('--logging');
        this.logLevel = clipanion_1.Option.String('--log-level,--logLevel');
        this.mergeXrayTraces = clipanion_1.Option.String('--merge-xray-traces,--mergeXrayTraces');
        this.profile = clipanion_1.Option.String('--profile');
        this.regExPattern = clipanion_1.Option.String('--functions-regex,--functionsRegex');
        this.region = clipanion_1.Option.String('-r,--region');
        this.service = clipanion_1.Option.String('--service');
        this.sourceCodeIntegration = clipanion_1.Option.Boolean('-s,--source-code-integration,--sourceCodeIntegration', true);
        this.uploadGitMetadata = clipanion_1.Option.Boolean('-u,--upload-git-metadata,--uploadGitMetadata', true);
        this.tracing = clipanion_1.Option.String('--tracing');
        this.version = clipanion_1.Option.String('--version');
        this.llmobs = clipanion_1.Option.String('--llmobs');
        this.config = {
            functions: [],
            tracing: 'true',
            logging: 'true',
        };
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.lambdaFips = clipanion_1.Option.Boolean('--lambda-fips', false);
        this.fipsConfig = {
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
    }
    execute() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.fipsConfig.fips, this.fipsIgnoreError || this.fipsConfig.fipsIgnoreError);
            this.context.stdout.write(instrumentRenderer.renderLambdaHeader(Object.getPrototypeOf(this), this.dryRun));
            const lambdaConfig = { lambda: this.config };
            this.config = (yield (0, utils_1.resolveConfigFromFile)(lambdaConfig, { configPath: this.configPath, defaultConfigPaths: utils_1.DEFAULT_CONFIG_PATHS })).lambda;
            const profile = (_a = this.profile) !== null && _a !== void 0 ? _a : this.config.profile;
            if (profile) {
                try {
                    this.credentials = yield (0, commons_1.getAWSProfileCredentials)(profile);
                }
                catch (err) {
                    this.context.stdout.write(helperRenderer.renderError(err));
                    return 1;
                }
            }
            let hasSpecifiedFunctions = this.functions.length !== 0 || this.config.functions.length !== 0;
            if (this.interactive) {
                try {
                    const credentials = yield (0, commons_1.getAWSCredentials)();
                    if (credentials === undefined) {
                        this.context.stdout.write(commonRenderer.renderNoAWSCredentialsFound());
                        yield (0, prompt_2.requestAWSCredentials)();
                    }
                    else {
                        this.credentials = credentials;
                    }
                    // Always ask for region since the user may
                    // not want to use the default, nonetheless,
                    // we do not ask if `-r|--region` is provided.
                    if (this.region === undefined && this.config.region === undefined) {
                        this.context.stdout.write(instrumentRenderer.renderConfigureAWSRegion());
                        yield (0, prompt_2.requestAWSRegion)(process.env[constants_2.AWS_DEFAULT_REGION_ENV_VAR]);
                    }
                    if ((0, commons_1.isMissingDatadogEnvVars)()) {
                        this.context.stdout.write(instrumentRenderer.renderConfigureDatadog());
                        yield (0, prompt_2.requestDatadogEnvVars)();
                    }
                }
                catch (err) {
                    this.context.stdout.write(helperRenderer.renderError(err));
                    return 1;
                }
                const region = (_c = (_b = this.region) !== null && _b !== void 0 ? _b : this.config.region) !== null && _c !== void 0 ? _c : process.env[constants_2.AWS_DEFAULT_REGION_ENV_VAR];
                this.region = region;
                // If user doesn't specify functions, allow them
                // to select from all of the functions from the
                // requested region.
                if (!hasSpecifiedFunctions) {
                    const spinner = instrumentRenderer.fetchingFunctionsSpinner();
                    try {
                        const lambdaClientConfig = {
                            region,
                            credentials: this.credentials,
                            retryStrategy: constants_2.EXPONENTIAL_BACKOFF_RETRY_STRATEGY,
                        };
                        const lambdaClient = new client_lambda_1.LambdaClient(lambdaClientConfig);
                        spinner.start();
                        const functionNames = (_d = (yield (0, commons_1.getAllLambdaFunctionConfigs)(lambdaClient)).map((config) => config.FunctionName).sort()) !== null && _d !== void 0 ? _d : [];
                        if (functionNames.length === 0) {
                            this.context.stdout.write(instrumentRenderer.renderCouldntFindLambdaFunctionsInRegionError());
                            return 1;
                        }
                        spinner.succeed(instrumentRenderer.renderFetchedLambdaFunctions(functionNames.length));
                        const functions = yield (0, prompt_2.requestFunctionSelection)(functionNames);
                        this.functions = functions;
                    }
                    catch (err) {
                        spinner.fail(instrumentRenderer.renderFailedFetchingLambdaFunctions());
                        this.context.stdout.write(instrumentRenderer.renderCouldntFetchLambdaFunctionsError(err));
                        return 1;
                    }
                }
                try {
                    yield (0, prompt_2.requestEnvServiceVersion)();
                }
                catch (err) {
                    this.context.stdout.write(helperRenderer.renderError(`Grabbing env, service, and version values from user. ${err}`));
                    return 1;
                }
                this.setEnvServiceVersion();
            }
            const settings = this.getSettings();
            if (settings === undefined) {
                return 1;
            }
            hasSpecifiedFunctions = this.functions.length !== 0 || this.config.functions.length !== 0;
            const hasSpecifiedRegExPattern = this.regExPattern !== undefined && this.regExPattern !== '';
            if (!hasSpecifiedFunctions && !hasSpecifiedRegExPattern) {
                this.context.stdout.write(instrumentRenderer.renderNoFunctionsSpecifiedError(Object.getPrototypeOf(this)));
                return 1;
            }
            if (settings.extensionVersion && settings.forwarderARN) {
                this.context.stdout.write(instrumentRenderer.renderExtensionAndForwarderOptionsBothSetError());
                return 1;
            }
            if (this.sourceCodeIntegration) {
                settings.extraTags = yield (0, instrument_helpers_1.handleSourceCodeIntegration)(this.context, this.uploadGitMetadata, settings.extraTags);
            }
            const configGroups = [];
            if (hasSpecifiedRegExPattern) {
                if (hasSpecifiedFunctions) {
                    this.context.stdout.write(instrumentRenderer.renderFunctionsAndFunctionsRegexOptionsBothSetError(this.functions.length !== 0));
                    return 1;
                }
                if (this.regExPattern.match(':')) {
                    this.context.stdout.write(instrumentRenderer.renderRegexSetWithARNError());
                    return 1;
                }
                const region = (_f = (_e = this.region) !== null && _e !== void 0 ? _e : this.config.region) !== null && _f !== void 0 ? _f : process.env[constants_2.AWS_DEFAULT_REGION_ENV_VAR];
                if (!region) {
                    this.context.stdout.write(commonRenderer.renderNoDefaultRegionSpecifiedError());
                    return 1;
                }
                const spinner = instrumentRenderer.fetchingFunctionsSpinner();
                try {
                    const cloudWatchLogsClient = new client_cloudwatch_logs_1.CloudWatchLogsClient({
                        region,
                        retryStrategy: constants_2.EXPONENTIAL_BACKOFF_RETRY_STRATEGY,
                    });
                    const lambdaClientConfig = {
                        region,
                        credentials: this.credentials,
                        retryStrategy: constants_2.EXPONENTIAL_BACKOFF_RETRY_STRATEGY,
                    };
                    const lambdaClient = new client_lambda_1.LambdaClient(lambdaClientConfig);
                    spinner.start();
                    const configs = yield (0, instrument_1.getInstrumentedFunctionConfigsFromRegEx)(lambdaClient, cloudWatchLogsClient, region, this.regExPattern, settings);
                    spinner.succeed(instrumentRenderer.renderFetchedLambdaFunctions(configs.length));
                    configGroups.push({ configs, lambdaClient, cloudWatchLogsClient, region });
                }
                catch (err) {
                    spinner.fail(instrumentRenderer.renderFailedFetchingLambdaFunctions());
                    this.context.stdout.write(instrumentRenderer.renderCouldntFetchLambdaFunctionsError(err));
                    return 1;
                }
            }
            else {
                let functionGroups;
                try {
                    const region = (_h = (_g = this.region) !== null && _g !== void 0 ? _g : this.config.region) !== null && _h !== void 0 ? _h : process.env[constants_2.AWS_DEFAULT_REGION_ENV_VAR];
                    functionGroups = (0, commons_1.collectFunctionsByRegion)(this.functions.length !== 0 ? this.functions : this.config.functions, region);
                }
                catch (err) {
                    this.context.stdout.write(instrumentRenderer.renderCouldntGroupFunctionsError(err));
                    return 1;
                }
                for (const [region, functionList] of Object.entries(functionGroups)) {
                    const spinner = instrumentRenderer.fetchingFunctionsConfigSpinner(region);
                    spinner.start();
                    const lambdaClientConfig = {
                        region,
                        credentials: this.credentials,
                        retryStrategy: constants_2.EXPONENTIAL_BACKOFF_RETRY_STRATEGY,
                    };
                    const lambdaClient = new client_lambda_1.LambdaClient(lambdaClientConfig);
                    const cloudWatchLogsClient = new client_cloudwatch_logs_1.CloudWatchLogsClient({
                        region,
                        retryStrategy: constants_2.EXPONENTIAL_BACKOFF_RETRY_STRATEGY,
                    });
                    try {
                        const configs = yield (0, instrument_1.getInstrumentedFunctionConfigs)(lambdaClient, cloudWatchLogsClient, region, functionList, settings);
                        configGroups.push({ configs, lambdaClient, cloudWatchLogsClient, region });
                        spinner.succeed(instrumentRenderer.renderFetchedLambdaConfigurationsFromRegion(region, configs.length));
                    }
                    catch (err) {
                        spinner.fail(instrumentRenderer.renderFailedFetchingLambdaConfigurationsFromRegion(region));
                        this.context.stdout.write(instrumentRenderer.renderCouldntFetchLambdaFunctionsError(err));
                        return 1;
                    }
                }
            }
            const configList = configGroups.map((group) => group.configs).reduce((a, b) => a.concat(b));
            if (!(0, commons_1.checkRuntimeTypesAreUniform)(configList)) {
                throw Error('Detected Lambda functions using different runtimes. Please only instrument batches of functions that share a similar runtime');
            }
            this.printPlannedActions(configList);
            if (this.dryRun || configList.length === 0) {
                return 0;
            }
            const willUpdate = (0, commons_1.willUpdateFunctionConfigs)(configList);
            if (this.interactive && willUpdate) {
                this.context.stdout.write(instrumentRenderer.renderConfirmationNeededSoftWarning());
                const isConfirmed = yield (0, prompt_1.requestConfirmation)('Do you want to apply the changes?');
                if (!isConfirmed) {
                    return 0;
                }
                this.context.stdout.write(instrumentRenderer.renderInstrumentingFunctionsSoftWarning());
            }
            if (willUpdate) {
                try {
                    yield (0, commons_1.handleLambdaFunctionUpdates)(configGroups, this.context.stdout);
                }
                catch (_j) {
                    return 1;
                }
            }
            return 0;
        });
    }
    getSettings() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        const layerVersionStr = (_a = this.layerVersion) !== null && _a !== void 0 ? _a : this.config.layerVersion;
        const extensionVersionStr = (_b = this.extensionVersion) !== null && _b !== void 0 ? _b : this.config.extensionVersion;
        const layerAWSAccount = (_c = this.layerAWSAccount) !== null && _c !== void 0 ? _c : this.config.layerAWSAccount;
        const forwarderARN = (_d = this.forwarder) !== null && _d !== void 0 ? _d : this.config.forwarder;
        let layerVersion;
        if (layerVersionStr !== undefined) {
            layerVersion = parseInt(layerVersionStr, 10);
        }
        if (Number.isNaN(layerVersion)) {
            this.context.stdout.write(instrumentRenderer.renderInvalidLayerVersionError(layerVersion === null || layerVersion === void 0 ? void 0 : layerVersion.toString()));
            return;
        }
        let extensionVersion;
        if (extensionVersionStr !== undefined) {
            extensionVersion = parseInt(extensionVersionStr, 10);
        }
        if (Number.isNaN(extensionVersion)) {
            this.context.stdout.write(instrumentRenderer.renderInvalidExtensionVersionError(extensionVersion === null || extensionVersion === void 0 ? void 0 : extensionVersion.toString()));
            return;
        }
        const stringBooleansMap = {
            captureLambdaPayload: (_e = this.captureLambdaPayload) !== null && _e !== void 0 ? _e : this.config.captureLambdaPayload,
            flushMetricsToLogs: (_f = this.flushMetricsToLogs) !== null && _f !== void 0 ? _f : this.config.flushMetricsToLogs,
            logging: (_g = this.logging) !== null && _g !== void 0 ? _g : this.config.logging,
            mergeXrayTraces: (_h = this.mergeXrayTraces) !== null && _h !== void 0 ? _h : this.config.mergeXrayTraces,
            tracing: (_j = this.tracing) !== null && _j !== void 0 ? _j : this.config.tracing,
        };
        for (const [stringBoolean, value] of Object.entries(stringBooleansMap)) {
            if (!['true', 'false', undefined].includes(value === null || value === void 0 ? void 0 : value.toString().toLowerCase())) {
                this.context.stdout.write(instrumentRenderer.renderInvalidStringBooleanSpecifiedError(stringBoolean));
                return;
            }
        }
        const captureLambdaPayload = (0, commons_1.coerceBoolean)(false, this.captureLambdaPayload, this.config.captureLambdaPayload);
        const flushMetricsToLogs = (0, commons_1.coerceBoolean)(true, this.flushMetricsToLogs, this.config.flushMetricsToLogs);
        const loggingEnabled = (0, commons_1.coerceBoolean)(true, this.logging, this.config.logging);
        const mergeXrayTraces = (0, commons_1.coerceBoolean)(false, this.mergeXrayTraces, this.config.mergeXrayTraces);
        const tracingEnabled = (0, commons_1.coerceBoolean)(true, this.tracing, this.config.tracing);
        const interactive = (0, commons_1.coerceBoolean)(false, this.interactive, this.config.interactive);
        const logLevel = (_k = this.logLevel) !== null && _k !== void 0 ? _k : this.config.logLevel;
        const apmFlushDeadline = (_l = this.apmFlushDeadline) !== null && _l !== void 0 ? _l : this.config.apmFlushDeadline;
        const appsecEnabled = (_m = this.appsecEnabled) !== null && _m !== void 0 ? _m : this.config.appsecEnabled;
        const service = (_o = this.service) !== null && _o !== void 0 ? _o : this.config.service;
        const environment = (_p = this.environment) !== null && _p !== void 0 ? _p : this.config.environment;
        const version = (_q = this.version) !== null && _q !== void 0 ? _q : this.config.version;
        const llmobsMlApp = (_r = this.llmobs) !== null && _r !== void 0 ? _r : this.config.llmobs;
        const tagsMap = {
            environment,
            service,
            version,
        };
        const tagsMissing = [];
        for (const [tag, value] of Object.entries(tagsMap)) {
            if (!value) {
                tagsMissing.push(tag);
            }
        }
        if (tagsMissing.length > 0) {
            this.context.stdout.write(instrumentRenderer.renderTagsNotConfiguredWarning(tagsMissing));
        }
        const extraTags = (_t = (_s = this.extraTags) === null || _s === void 0 ? void 0 : _s.toLowerCase()) !== null && _t !== void 0 ? _t : (_u = this.config.extraTags) === null || _u === void 0 ? void 0 : _u.toLowerCase();
        if (extraTags && !(0, commons_1.sentenceMatchesRegEx)(extraTags, constants_1.EXTRA_TAGS_REG_EXP)) {
            this.context.stdout.write(instrumentRenderer.renderExtraTagsDontComplyError());
            return;
        }
        return {
            apmFlushDeadline,
            appsecEnabled,
            captureLambdaPayload,
            environment,
            extensionVersion,
            extraTags,
            lambdaFips: this.lambdaFips,
            flushMetricsToLogs,
            forwarderARN,
            interactive,
            layerAWSAccount,
            layerVersion,
            loggingEnabled,
            logLevel,
            mergeXrayTraces,
            service,
            tracingEnabled,
            version,
            llmobsMlApp,
        };
    }
    printPlannedActions(configs) {
        const willUpdate = (0, commons_1.willUpdateFunctionConfigs)(configs);
        if (!willUpdate) {
            this.context.stdout.write(instrumentRenderer.renderNoUpdatesApplied(this.dryRun));
            return;
        }
        this.context.stdout.write(instrumentRenderer.renderInstrumentInStagingFirst());
        this.context.stdout.write(instrumentRenderer.renderFunctionsToBeUpdated());
        for (const config of configs) {
            this.context.stdout.write(`\t- ${chalk_1.default.bold(config.functionARN)}\n`);
            // Later, we should inform which layer is the latest.
            if (this.interactive) {
                if (!this.extensionVersion || !this.extensionVersion) {
                    this.context.stdout.write(instrumentRenderer.renderEnsureToLockLayerVersionsWarning());
                }
            }
        }
        this.context.stdout.write(instrumentRenderer.renderWillApplyUpdates(this.dryRun));
        for (const config of configs) {
            if (config.updateFunctionConfigurationCommandInput) {
                const maskedConfig = (0, commons_1.maskConfig)(config.updateFunctionConfigurationCommandInput);
                this.context.stdout.write(`UpdateFunctionConfiguration -> ${config.functionARN}\n${JSON.stringify(maskedConfig, undefined, 2)}\n`);
            }
            const { logGroupConfiguration, tagConfiguration } = config;
            if (tagConfiguration === null || tagConfiguration === void 0 ? void 0 : tagConfiguration.tagResourceCommandInput) {
                this.context.stdout.write(`TagResource -> ${tagConfiguration.tagResourceCommandInput.Resource}\n${JSON.stringify(tagConfiguration.tagResourceCommandInput.Tags, undefined, 2)}\n`);
            }
            if (logGroupConfiguration === null || logGroupConfiguration === void 0 ? void 0 : logGroupConfiguration.createLogGroupCommandInput) {
                this.context.stdout.write(`CreateLogGroup -> ${logGroupConfiguration.logGroupName}\n${JSON.stringify(logGroupConfiguration.createLogGroupCommandInput, undefined, 2)}\n`);
            }
            if (logGroupConfiguration === null || logGroupConfiguration === void 0 ? void 0 : logGroupConfiguration.deleteSubscriptionFilterCommandInput) {
                this.context.stdout.write(`DeleteSubscriptionFilter -> ${logGroupConfiguration.logGroupName}\n${JSON.stringify(logGroupConfiguration.deleteSubscriptionFilterCommandInput, undefined, 2)}\n`);
            }
            if (logGroupConfiguration === null || logGroupConfiguration === void 0 ? void 0 : logGroupConfiguration.putSubscriptionFilterCommandInput) {
                this.context.stdout.write(`PutSubscriptionFilter -> ${logGroupConfiguration.logGroupName}\n${JSON.stringify(logGroupConfiguration.putSubscriptionFilterCommandInput, undefined, 2)}\n`);
            }
        }
    }
    setEnvServiceVersion() {
        this.environment = process.env[constants_1.ENVIRONMENT_ENV_VAR] || undefined;
        this.service = process.env[constants_1.SERVICE_ENV_VAR] || undefined;
        this.version = process.env[constants_1.VERSION_ENV_VAR] || undefined;
    }
}
exports.InstrumentCommand = InstrumentCommand;
InstrumentCommand.paths = [['lambda', 'instrument']];
InstrumentCommand.usage = clipanion_1.Command.Usage({
    category: 'Serverless',
    description: 'Apply Datadog instrumentation to a Lambda.',
});
//# sourceMappingURL=instrument.js.map