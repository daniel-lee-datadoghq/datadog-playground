"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchServiceConfigs = exports.generateConfigDiff = exports.checkAuthentication = void 0;
const chalk_1 = __importDefault(require("chalk"));
const jest_diff_1 = require("jest-diff");
const renderer_1 = require("./renderer");
/**
 * Check if the user is authenticated with GCP.
 * @returns true if the user is authenticated, false otherwise
 */
const checkAuthentication = () => __awaiter(void 0, void 0, void 0, function* () {
    // TODO: remove this in favor of `await import()` when google-auth-library ESM/CJS issues are fixed
    const { GoogleAuth } = require('google-auth-library');
    const auth = new GoogleAuth();
    try {
        yield auth.getApplicationDefault();
        return true;
    }
    catch (_) {
        return false;
    }
});
exports.checkAuthentication = checkAuthentication;
/**
 * Recursively sort object keys to ensure consistent ordering
 */
const sortObjectKeys = (obj) => {
    if (!obj) {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map(sortObjectKeys);
    }
    if (typeof obj === 'object') {
        const sorted = {};
        Object.keys(obj)
            .sort()
            .forEach((key) => {
            sorted[key] = sortObjectKeys(obj[key]);
        });
        return sorted;
    }
    return obj;
};
/**
 * Obfuscate sensitive values in a line if it contains a key with "_KEY"
 */
const obfuscateSensitiveValues = (line) => {
    // Match hex strings of 16, 32, or 64 characters (common API key/token lengths)
    return line
        .replace(/("[0-9a-fA-F]{16}"|"[0-9a-fA-F]{32}"|"[0-9a-fA-F]{64}")/g, '"***"')
        .replace(/('[0-9a-fA-F]{16}'|'[0-9a-fA-F]{32}'|'[0-9a-fA-F]{64}')/g, "'***'");
};
/**
 * Generate a git diff-style comparison between two configurations
 * TODO(@nhulston): update Lambda and AAS instrument to show this diff
 * @param original The original configuration object
 * @param updated The updated configuration object
 * @returns A formatted diff string with colors
 */
const generateConfigDiff = (original, updated) => {
    // Sort keys consistently before comparison
    const sortedOriginal = sortObjectKeys(original);
    const sortedUpdated = sortObjectKeys(updated);
    const originalJson = JSON.stringify(sortedOriginal, undefined, 2);
    const updatedJson = JSON.stringify(sortedUpdated, undefined, 2);
    const obfuscatedOriginal = originalJson.split('\n').map(obfuscateSensitiveValues).join('\n');
    const obfuscatedUpdated = updatedJson.split('\n').map(obfuscateSensitiveValues).join('\n');
    const configDiff = (0, jest_diff_1.diff)(obfuscatedOriginal, obfuscatedUpdated, {
        aColor: chalk_1.default.red,
        bColor: chalk_1.default.green,
        omitAnnotationLines: true,
    });
    if (!configDiff || configDiff.includes('no visual difference')) {
        return chalk_1.default.gray('No changes detected.');
    }
    return configDiff;
};
exports.generateConfigDiff = generateConfigDiff;
const fetchServiceConfigs = (client, project, region, services) => __awaiter(void 0, void 0, void 0, function* () {
    const existingServiceConfigs = [];
    for (const serviceName of services) {
        const servicePath = client.servicePath(project, region, serviceName);
        const existingService = yield (0, renderer_1.withSpinner)(`Fetching configuration for ${chalk_1.default.bold(serviceName)}...`, () => __awaiter(void 0, void 0, void 0, function* () {
            try {
                const [serv] = yield client.getService({ name: servicePath });
                return serv;
            }
            catch (error) {
                throw new Error(`Service ${serviceName} not found in project ${project}, region ${region}.\n\nNo services were instrumented.\n`);
            }
        }), `Fetched service configuration for ${chalk_1.default.bold(serviceName)}`);
        existingServiceConfigs.push(existingService);
    }
    return existingServiceConfigs;
});
exports.fetchServiceConfigs = fetchServiceConfigs;
//# sourceMappingURL=utils.js.map