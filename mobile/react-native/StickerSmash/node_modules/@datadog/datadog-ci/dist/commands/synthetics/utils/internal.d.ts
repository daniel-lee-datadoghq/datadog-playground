import { BaseResult, BasicAuthCredentials, BrowserServerResult, CookiesObject, ExecutionRule, LocalTriggerConfig, MobileTestWithOverride, Result, ResultInBatch, ResultInBatchSkippedBySelectiveRerun, RetryConfig, ServerConfigOverride, ServerResult, Test, TestMissing, TestPayload, TestSkipped, TestWithOverride, TriggerConfig, UserConfigOverride } from '../interfaces';
export declare const wait: (duration: number) => Promise<unknown>;
export declare const getOverriddenExecutionRule: (test?: Test, testOverrides?: UserConfigOverride) => ExecutionRule | undefined;
export declare const hasResultPassed: (result: ResultInBatch, isUnhealthy: boolean, hasTimedOut: boolean, options: {
    failOnCriticalErrors?: boolean;
    failOnTimeout?: boolean;
}) => boolean;
/**
 * Whether the result is of type {@link BaseResult}, i.e. it wasn't skipped.
 */
export declare const isBaseResult: (result: Result) => result is BaseResult;
/**
 * Whether the result has a defined {@link BaseResult.result} property.
 *
 * This property would be undefined if the server result isn't available when polling for it,
 * which is a known latency issue. We call such result an incomplete result.
 */
export declare const hasDefinedResult: (result: Result) => result is BaseResult & {
    result: ServerResult;
};
/**
 * When the test is configured to be retried and the first attempt fails, `retries` is set to `0`
 * and the result is kept `in_progress` until the final result is received.
 */
export declare const isNonFinalResult: (result: ResultInBatch) => result is import("../interfaces").BaseResultInBatch & {
    retries: number;
    status: 'in_progress';
};
export declare const isTimedOutRetry: (retries: number | null, maxRetries: number | null, timedOut: boolean | null) => boolean;
export declare const isLocalTriggerConfig: (triggerConfig?: TriggerConfig) => triggerConfig is LocalTriggerConfig;
export declare const isBrowserServerResult: (serverResult: ServerResult) => serverResult is BrowserServerResult;
export declare const getTriggerConfigPublicId: (triggerConfig: TriggerConfig) => string | undefined;
export declare const LOCAL_TEST_DEFINITION_PUBLIC_ID_PLACEHOLDER = "local";
export declare const getPublicIdOrPlaceholder: (test: Test | TestPayload | {
    public_id?: string;
}) => string;
export declare const isResultInBatchSkippedBySelectiveRerun: (result: ResultInBatch) => result is ResultInBatchSkippedBySelectiveRerun;
export declare const isMobileTestWithOverride: (item: TestMissing | TestSkipped | TestWithOverride) => item is MobileTestWithOverride;
export declare const getResultIdOrLinkedResultId: (result: ResultInBatch) => string;
export declare const toExecutionRule: (env: string | undefined) => ExecutionRule | undefined;
type AccumulatorBaseConfigOverride = Omit<UserConfigOverride, 'retry' | 'basicAuth' | 'cookies' | 'setCookies' | 'mobileApplicationVersion' | 'mobileApplicationVersionFilePath'> & {
    retry?: Partial<RetryConfig>;
    basicAuth?: Partial<BasicAuthCredentials>;
    cookies?: Partial<CookiesObject>;
    setCookies?: Partial<CookiesObject>;
};
type TestOverrideValueType = boolean | number | string | string[] | ExecutionRule;
type ValidTestOverrideValueTypeName = 'boolean' | 'number' | 'string' | 'string[]' | 'ExecutionRule';
export declare const parseOverrideValue: (value: string, type: ValidTestOverrideValueTypeName) => TestOverrideValueType;
export declare const validateAndParseOverrides: (overrides: string[] | undefined) => AccumulatorBaseConfigOverride;
export declare const getBasePayload: (test: Test, testOverrides?: UserConfigOverride) => ServerConfigOverride;
export {};
