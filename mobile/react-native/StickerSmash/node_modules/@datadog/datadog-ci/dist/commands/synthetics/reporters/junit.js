"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JUnitReporter = exports.getDefaultSuiteStats = exports.getDefaultTestCaseStats = void 0;
const fs_1 = __importDefault(require("fs"));
const chalk_1 = __importDefault(require("chalk"));
const upath_1 = __importDefault(require("upath"));
const xml2js_1 = require("xml2js");
const interfaces_1 = require("../interfaces");
const internal_1 = require("../utils/internal");
const public_1 = require("../utils/public");
const renderApiError = (errorCode, errorMessage) => {
    if (errorCode === 'INCORRECT_ASSERTION') {
        try {
            const assertionsErrors = JSON.parse(errorMessage);
            const output = [`- ${(0, public_1.pluralize)('Assertion', assertionsErrors.length)} failed:`];
            output.push(...assertionsErrors.map((error) => {
                const expected = error.target;
                const actual = error.actual;
                return `▶ ${error.type} ${public_1.readableOperation[error.operator]} ${expected}. Actual: ${actual}`;
            }));
            return output.join('\n    ');
        }
        catch (e) {
            // JSON parsing failed, do nothing to return the raw error
        }
    }
    return `  [${errorCode}] - ${errorMessage}`;
};
const renderSelectiveRerun = (selectiveRerun) => {
    if (!selectiveRerun) {
        return;
    }
    const { decision, reason } = selectiveRerun;
    if ('linked_result_id' in selectiveRerun) {
        return `decision:${decision},reason:${reason},linked_result_id:${selectiveRerun.linked_result_id}`;
    }
    return `decision:${decision},reason:${reason}`;
};
const getResultIdentification = (test, id, location, device, resultTimedOut) => {
    if (location || device || resultTimedOut) {
        return `${test.name} - ${id} - ${location}${device}${resultTimedOut}`;
    }
    return `${test.name} - ${id}`;
};
const getDefaultTestCaseStats = () => ({
    steps_allowfailures: 0,
    steps_count: 0,
    steps_errors: 0,
    steps_failures: 0,
    steps_skipped: 0,
    steps_warnings: 0,
});
exports.getDefaultTestCaseStats = getDefaultTestCaseStats;
const getDefaultSuiteStats = () => ({
    errors: 0,
    failures: 0,
    skipped: 0,
    tests: 0,
});
exports.getDefaultSuiteStats = getDefaultSuiteStats;
class JUnitReporter {
    constructor({ context, jUnitReport, runName }) {
        this.write = context.stdout.write.bind(context.stdout);
        this.destination = jUnitReport;
        if (!this.destination.endsWith('.xml')) {
            this.destination += '.xml';
        }
        this.builder = new xml2js_1.Builder();
        this.json = {
            testsuites: {
                $: {
                    batch_id: '',
                    batch_url: '',
                    name: runName || 'Undefined run',
                    tests_critical_error: 0,
                    tests_failed: 0,
                    tests_failed_non_blocking: 0,
                    tests_not_authorized: 0,
                    tests_not_found: 0,
                    tests_passed: 0,
                    tests_skipped: 0,
                    tests_timed_out: 0,
                },
                testsuite: [],
            },
        };
    }
    resultEnd(result, baseUrl, batchId) {
        var _a, _b, _c;
        if (result.isNonFinal) {
            // To avoid any client code badly handling non-final results in JUnit reports,
            // we don't pollute those reports with intermediate results, as they are retried anyway.
            return;
        }
        const suite = this.getSuiteByName(result.test.suite);
        const testCase = this.getTestCase(result, baseUrl, batchId);
        if ((0, public_1.isResultSkippedBySelectiveRerun)(result)) {
            return this.addTestCaseToSuite(suite, testCase);
        }
        // Errors and failures cannot co-exist: GitLab will always choose failures over errors.
        // The icon in the Status column will depend on this choice, and only the list of what is chosen will be displayed in the "System output".
        const errorOrFailure = result.executionRule === interfaces_1.ExecutionRule.NON_BLOCKING
            ? testCase.error // ❗️
            : testCase.failure; // ❌
        if ((0, internal_1.hasDefinedResult)(result) && 'steps' in result.result) {
            if (result.test.type === 'browser') {
                // It's a browser test.
                const steps = result.result.steps;
                for (const step of steps) {
                    const { allowedErrors, browserErrors, errors, warnings } = this.getBrowserTestErrors(step);
                    testCase.allowed_error.push(...allowedErrors);
                    testCase.browser_error.push(...browserErrors);
                    errorOrFailure.push(...errors);
                    testCase.warning.push(...warnings);
                }
            }
            else if (result.test.type === 'api') {
                // It's a multistep test.
                const steps = result.result.steps;
                for (const step of steps) {
                    const { allowedErrors, errors } = this.getMultiStepTestErrors(step);
                    testCase.allowed_error.push(...allowedErrors);
                    errorOrFailure.push(...errors);
                }
            }
        }
        else {
            // It's an api test.
            const { errors } = this.getApiTestErrors(result);
            errorOrFailure.push(...errors);
        }
        if (result.timedOut) {
            // Timeout errors are manually reported by the CLI at the test level.
            errorOrFailure.push({
                $: { type: 'timeout' },
                _: String((_c = (_b = (_a = result.result) === null || _a === void 0 ? void 0 : _a.failure) === null || _b === void 0 ? void 0 : _b.message) !== null && _c !== void 0 ? _c : 'The batch timed out before receiving the result.'),
            });
        }
        else if (errorOrFailure.length === 0 && (0, internal_1.hasDefinedResult)(result) && result.result.failure) {
            // Fall back to any failure reported at the test level if nothing was reported at the step level.
            errorOrFailure.push({
                $: { type: 'test_failure' },
                _: `[${result.result.failure.code}] - ${result.result.failure.message}`,
            });
        }
        this.addTestCaseToSuite(suite, testCase);
    }
    runEnd(summary, baseUrl) {
        Object.assign(this.json.testsuites.$, {
            tests_critical_error: summary.criticalErrors,
            tests_failed: summary.failed,
            tests_failed_non_blocking: summary.failedNonBlocking,
            tests_not_authorized: summary.testsNotAuthorized.size,
            tests_not_found: summary.testsNotFound.size,
            tests_passed: summary.passed,
            tests_skipped: summary.skipped,
            tests_timed_out: summary.timedOut,
        });
        this.json.testsuites.$.batch_id = summary.batchId;
        this.json.testsuites.$.batch_url = (0, public_1.getBatchUrl)(baseUrl, summary.batchId);
        // Write the file
        try {
            const xml = this.builder.buildObject(this.json);
            fs_1.default.mkdirSync(upath_1.default.dirname(this.destination), { recursive: true });
            fs_1.default.writeFileSync(this.destination, xml, 'utf8');
            this.write(`\n✅ Created a jUnit report at ${chalk_1.default.bold.green(this.destination)}\n`);
        }
        catch (e) {
            this.write(`\n❌ Couldn't write the report to ${chalk_1.default.bold.green(this.destination)}:\n${e.toString()}\n`);
        }
    }
    // Handle skipped tests (`resultEnd()` is not called for them since they don't have a result).
    testTrigger(test, testId, executionRule, testOverrides) {
        if (executionRule !== interfaces_1.ExecutionRule.SKIPPED) {
            return;
        }
        const suite = this.getSuiteByName(test.suite);
        const testCase = this.getSkippedTestCase(test);
        testCase.skipped.push('This test was skipped because of its execution rule configuration in Datadog');
        this.addTestCaseToSuite(suite, testCase);
    }
    addTestCaseToSuite(suite, testCase) {
        suite.$ = {
            errors: suite.$.errors + testCase.error.length,
            failures: suite.$.failures + testCase.failure.length,
            name: suite.$.name,
            skipped: suite.$.skipped + testCase.skipped.length,
            tests: suite.$.tests + 1,
        };
        suite.testcase.push(testCase);
    }
    getApiStepStats(step) {
        // TODO use more granular result based on step.assertionResults
        let allowfailures = 0;
        let skipped = 0;
        if ('allow_failure' in step) {
            allowfailures += step.allow_failure ? 1 : 0;
        }
        if ('status' in step) {
            skipped += step.status === 'skipped' ? 1 : 0;
        }
        return {
            steps_allowfailures: allowfailures,
            steps_count: 1,
            steps_errors: step.status === 'failed' ? 1 : 0,
            steps_failures: step.status === 'failed' ? 1 : 0,
            steps_skipped: skipped,
            steps_warnings: 0,
        };
    }
    getApiTestErrors(result) {
        const errors = [];
        if ((0, internal_1.hasDefinedResult)(result) && result.result.failure) {
            const xmlError = {
                $: { type: result.result.failure.code, step: result.test.name },
                _: renderApiError(result.result.failure.code, result.result.failure.message),
            };
            errors.push(xmlError);
        }
        return { errors };
    }
    getBrowserStepStats(step) {
        const errors = step.browser_errors ? step.browser_errors.length : 0;
        return {
            steps_allowfailures: step.allow_failure ? 1 : 0,
            steps_count: step.sub_test_step_details ? step.sub_test_step_details.length : 1,
            steps_errors: errors + (step.failure ? 1 : 0),
            steps_failures: step.failure ? 1 : 0,
            steps_skipped: step.status === 'skipped' ? 1 : 0,
            steps_warnings: step.warnings ? step.warnings.length : 0,
        };
    }
    getBrowserTestErrors(step) {
        var _a, _b;
        const allowedErrors = [];
        const browserErrors = [];
        const errors = [];
        const warnings = [];
        if ((_a = step.browser_errors) === null || _a === void 0 ? void 0 : _a.length) {
            browserErrors.push(...step.browser_errors.map((e) => ({
                $: { type: e.type, name: e.name, step: step.description },
                _: e.description,
            })));
        }
        if (step.failure) {
            const xmlError = {
                $: { type: 'assertion', step: step.description, allowFailure: `${step.allow_failure}` },
                _: step.failure.message,
            };
            if (step.allow_failure) {
                allowedErrors.push(xmlError);
            }
            else {
                errors.push(xmlError);
            }
        }
        if ((_b = step.warnings) === null || _b === void 0 ? void 0 : _b.length) {
            warnings.push(...step.warnings.map((w) => ({
                $: { type: w.type, step: step.description },
                _: w.message,
            })));
        }
        return { allowedErrors, browserErrors, errors, warnings };
    }
    getMultiStepTestErrors(step) {
        const allowedErrors = [];
        const errors = [];
        if (step.failure) {
            const xmlError = {
                $: { type: step.failure.code, step: step.name, allowFailure: `${step.allow_failure}` },
                _: renderApiError(step.failure.code, step.failure.message),
            };
            if (step.allow_failure) {
                allowedErrors.push(xmlError);
            }
            else {
                errors.push(xmlError);
            }
        }
        return { allowedErrors, errors };
    }
    getSkippedTestCase(test) {
        var _a, _b;
        const publicId = (0, internal_1.getPublicIdOrPlaceholder)(test);
        const id = `id: ${publicId}`;
        const resultIdentification = `${test.name} - ${id} (skipped)`;
        return {
            $: Object.assign({ classname: test.suite, file: test.suite, name: resultIdentification, time: 0, timestamp: new Date().toISOString() }, (0, exports.getDefaultTestCaseStats)()),
            allowed_error: [],
            browser_error: [],
            error: [],
            failure: [],
            properties: {
                property: [
                    { $: { name: 'check_id', value: publicId } },
                    { $: { name: 'execution_rule', value: (_a = test.options.ci) === null || _a === void 0 ? void 0 : _a.executionRule } },
                    { $: { name: 'message', value: test.message } },
                    ...('monitor_id' in test ? [{ $: { name: 'monitor_id', value: test.monitor_id } }] : []),
                    { $: { name: 'public_id', value: publicId } },
                    ...('status' in test ? [{ $: { name: 'status', value: test.status } }] : []),
                    { $: { name: 'tags', value: ((_b = test.tags) !== null && _b !== void 0 ? _b : []).join(',') } },
                    { $: { name: 'type', value: test.type } },
                ].filter((prop) => prop.$.value !== undefined),
            },
            skipped: [],
            warning: [],
        };
    }
    getSuiteByName(suiteName = 'Undefined suite') {
        const existingSuite = this.json.testsuites.testsuite.find((element) => element.$.name === suiteName);
        if (!existingSuite) {
            const suite = {
                $: Object.assign({ name: suiteName }, (0, exports.getDefaultSuiteStats)()),
                testcase: [],
            };
            this.json.testsuites.testsuite.push(suite);
            return suite;
        }
        return existingSuite;
    }
    getTestCase(result, baseUrl, batchId) {
        var _a, _b;
        const test = result.test;
        const resultOutcome = (0, public_1.getResultOutcome)(result);
        const resultUrl = (0, public_1.getResultUrl)(baseUrl, test, result.resultId, batchId);
        const passed = public_1.PASSED_RESULT_OUTCOMES.includes(resultOutcome);
        const publicId = (0, internal_1.getPublicIdOrPlaceholder)(test);
        const id = `id: ${publicId}`;
        const location = (0, internal_1.isBaseResult)(result) ? `location: ${result.location}` : '';
        const device = (0, internal_1.hasDefinedResult)(result) && (0, public_1.isDeviceIdSet)(result) ? ` - device: ${result.device.id}` : '';
        const resultTimedOut = result.timedOut ? ` - result id: ${result.resultId} (not yet received)` : '';
        // This has to identify results, otherwise GitLab will only show the last result with the same name.
        const resultIdentification = getResultIdentification(test, id, location, device, resultTimedOut);
        return {
            $: Object.assign({ classname: test.suite, file: test.suite, name: resultIdentification, time: (0, internal_1.isBaseResult)(result) ? result.duration / 1000 : 0, timestamp: (0, internal_1.hasDefinedResult)(result)
                    ? new Date(result.result.finished_at).toISOString()
                    : new Date().toISOString() }, this.getTestCaseStats(result)),
            allowed_error: [],
            browser_error: [],
            error: [],
            failure: [],
            properties: {
                property: [
                    { $: { name: 'check_id', value: publicId } },
                    ...((0, internal_1.hasDefinedResult)(result) && (0, public_1.isDeviceIdSet)(result)
                        ? [
                            { $: { name: 'device', value: result.device.id } },
                            { $: { name: 'width', value: result.device.resolution.width } },
                            { $: { name: 'height', value: result.device.resolution.height } },
                        ]
                        : []),
                    { $: { name: 'execution_rule', value: (_a = test.options.ci) === null || _a === void 0 ? void 0 : _a.executionRule } },
                    { $: { name: 'location', value: (0, internal_1.isBaseResult)(result) && result.location } },
                    { $: { name: 'message', value: test.message } },
                    ...('monitor_id' in test ? [{ $: { name: 'monitor_id', value: test.monitor_id } }] : []),
                    { $: { name: 'passed', value: String(passed) } },
                    { $: { name: 'public_id', value: publicId } },
                    { $: { name: 'result_id', value: result.resultId } },
                    { $: { name: 'initial_result_id', value: result.initialResultId } },
                    { $: { name: 'result_url', value: resultUrl } },
                    { $: { name: 'retries', value: (0, internal_1.isBaseResult)(result) && result.retries } },
                    { $: { name: 'max_retries', value: (0, internal_1.isBaseResult)(result) && result.maxRetries } },
                    { $: { name: 'selective_rerun', value: renderSelectiveRerun(result.selectiveRerun) } },
                    {
                        $: {
                            name: 'start_url',
                            value: (0, internal_1.hasDefinedResult)(result) && 'startUrl' in result.result && result.result.startUrl,
                        },
                    },
                    ...('status' in test ? [{ $: { name: 'status', value: test.status } }] : []),
                    { $: { name: 'tags', value: ((_b = test.tags) !== null && _b !== void 0 ? _b : []).join(',') } },
                    { $: { name: 'timeout', value: String(result.timedOut) } },
                    { $: { name: 'type', value: test.type } },
                ].filter((prop) => prop.$.value !== undefined),
            },
            skipped: [],
            warning: [],
        };
    }
    getTestCaseStats(result) {
        if ((0, public_1.isResultSkippedBySelectiveRerun)(result) || !(0, internal_1.hasDefinedResult)(result)) {
            return (0, exports.getDefaultTestCaseStats)();
        }
        let stepsStats = [];
        if ('steps' in result.result) {
            if (result.test.type === 'browser') {
                // It's a browser test.
                const steps = result.result.steps;
                stepsStats = steps
                    .map((step) => {
                    if (!step.sub_test_step_details) {
                        return [step];
                    }
                    return [step, ...step.sub_test_step_details];
                })
                    .reduce((acc, val) => acc.concat(val), [])
                    .map(this.getBrowserStepStats);
            }
            else if (result.test.type === 'api') {
                // It's an multistep API test
                const steps = result.result.steps;
                stepsStats = steps.map(this.getApiStepStats);
            }
        }
        else {
            // It's an api test
            stepsStats = [this.getApiStepStats(result.result)];
        }
        const stats = (0, exports.getDefaultTestCaseStats)();
        for (const stepStats of stepsStats) {
            stats.steps_count += stepStats.steps_count;
            stats.steps_errors += stepStats.steps_errors;
            stats.steps_failures += stepStats.steps_failures;
            stats.steps_skipped += stepStats.steps_skipped;
            stats.steps_allowfailures += stepStats.steps_allowfailures;
            stats.steps_warnings += stepStats.steps_warnings;
        }
        return stats;
    }
}
exports.JUnitReporter = JUnitReporter;
//# sourceMappingURL=junit.js.map