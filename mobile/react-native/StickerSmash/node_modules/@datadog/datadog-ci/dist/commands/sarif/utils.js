"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getServiceFromSarifTool = exports.SERVICE_THIRD_PARTY_ANALYZER = exports.SERVICE_DATADOG_ANALYZER_SECRETS_ONLY = exports.SERVICE_DATADOG_ANALYZER_SA_ONLY = exports.SERVICE_DATADOG_ANALYZER = exports.TAG_DATADOG_TYPE_TYPE_SECRET = exports.TAG_DATADOG_TYPE_TYPE_STATIC = exports.getBaseIntakeUrl = void 0;
const fs_1 = __importDefault(require("fs"));
const getBaseIntakeUrl = () => {
    if (process.env.DATADOG_SITE || process.env.DD_SITE) {
        return `https://cicodescan-intake.${process.env.DATADOG_SITE || process.env.DD_SITE}`;
    }
    return 'https://cicodescan-intake.datadoghq.com';
};
exports.getBaseIntakeUrl = getBaseIntakeUrl;
exports.TAG_DATADOG_TYPE_TYPE_STATIC = 'DATADOG_RULE_TYPE:STATIC_ANALYSIS';
exports.TAG_DATADOG_TYPE_TYPE_SECRET = 'DATADOG_RULE_TYPE:SECRET';
exports.SERVICE_DATADOG_ANALYZER = 'datadog-analyzer';
exports.SERVICE_DATADOG_ANALYZER_SA_ONLY = 'datadog-analyzer-sa-only';
exports.SERVICE_DATADOG_ANALYZER_SECRETS_ONLY = 'datadog-analyzer-secrets-only';
exports.SERVICE_THIRD_PARTY_ANALYZER = 'third-party-analyzer';
/**
 * Define the service and env based on the SARIF contents reports
 *  - if the report is produced by the datadog static analyzer, we look if the report
 *    contains only static analysis or secrets errors and change service
 *  - if the report is produced by a third party tool, we report it as is and cannot
 *    infer the nature of the results. We still try to get the first tool from the runs.
 *
 *  The objective of this function is to make sure that if a user uploads one report
 *  for static analysis only and one report for secrets only, they will have a different
 *  service and env for each report so that they are not discarded later in our backend.
 *
 * @param filePath
 */
const getServiceFromSarifTool = (filePath) => {
    let otherTool = exports.SERVICE_THIRD_PARTY_ANALYZER;
    const ruleTypes = new Set();
    try {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const report = JSON.parse(String(fs_1.default.readFileSync(filePath)));
        if ('runs' in report) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            for (const run of report['runs']) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                if ('tool' in run && 'driver' in run['tool'] && 'rules' in run['tool']['driver']) {
                    for (const rule of run['tool']['driver']['rules']) {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        if ('properties' in rule && 'tags' in rule['properties']) {
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                            for (const tag of rule['properties']['tags']) {
                                // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access
                                if (tag.includes('DATADOG_RULE_TYPE')) {
                                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                                    ruleTypes.add(tag);
                                }
                            }
                        }
                    }
                }
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment
        otherTool = report['runs'][0]['tool']['driver']['name'];
    }
    catch (error) {
        // ignore
    }
    if (ruleTypes.has(exports.TAG_DATADOG_TYPE_TYPE_STATIC) && ruleTypes.has(exports.TAG_DATADOG_TYPE_TYPE_SECRET)) {
        return exports.SERVICE_DATADOG_ANALYZER;
    }
    if (ruleTypes.has(exports.TAG_DATADOG_TYPE_TYPE_STATIC) && !ruleTypes.has(exports.TAG_DATADOG_TYPE_TYPE_SECRET)) {
        return exports.SERVICE_DATADOG_ANALYZER_SA_ONLY;
    }
    if (!ruleTypes.has(exports.TAG_DATADOG_TYPE_TYPE_STATIC) && ruleTypes.has(exports.TAG_DATADOG_TYPE_TYPE_SECRET)) {
        return exports.SERVICE_DATADOG_ANALYZER_SECRETS_ONLY;
    }
    return otherTool;
};
exports.getServiceFromSarifTool = getServiceFromSarifTool;
//# sourceMappingURL=utils.js.map