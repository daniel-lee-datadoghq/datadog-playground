"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SendDeploymentEvent = void 0;
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const simple_git_1 = __importDefault(require("simple-git"));
const t = __importStar(require("typanion"));
const constants_1 = require("../../constants");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const get_git_data_1 = require("../../helpers/git/get-git-data");
const logger_1 = require("../../helpers/logger");
const retry_1 = require("../../helpers/retry");
const api_1 = require("./api");
const renderer_1 = require("./renderer");
const nonRetriableErrorCodes = [400, 403];
class SendDeploymentEvent extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.serviceParam = clipanion_1.Option.String('--service', { env: 'DD_SERVICE' });
        this.env = clipanion_1.Option.String('--env', { env: 'DD_ENV' });
        this.startedAt = clipanion_1.Option.String('--started-at', {
            required: true,
            validator: t.isDate(),
            description: 'In Unix seconds or ISO8601 (Examples: 1699960648, 2023-11-14T11:17:28Z)',
        });
        this.finishedAt = clipanion_1.Option.String('--finished-at', {
            validator: t.isDate(),
            description: 'In Unix seconds or ISO8601 (Examples: 1699961048, 2023-11-14T11:24:08Z)',
        });
        this.version = clipanion_1.Option.String('--version', {
            description: 'The version of the service being deployed',
        });
        this.gitRepoURL = clipanion_1.Option.String('--git-repository-url', {
            description: 'Example: https://github.com/DataDog/datadog-ci.git',
        });
        this.gitCommitSHA = clipanion_1.Option.String('--git-commit-sha', {
            description: 'Example: 102836a25f5477e571c73d489b3f0f183687068e',
        });
        this.skipGit = clipanion_1.Option.Boolean('--skip-git', false, {
            description: 'Disables sending git URL and SHA. Change Lead Time will not be available',
        });
        this.team = clipanion_1.Option.String('--team', {
            description: 'The team responsible for the deployment',
        });
        this.customTags = clipanion_1.Option.Array('--custom-tags', {
            description: 'Custom tags to add to the deployment event in the format key:value, max 100 tags per deployment event',
        });
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.verbose = clipanion_1.Option.Boolean('--verbose', false, { hidden: true });
        this.dryRun = clipanion_1.Option.Boolean('--dry-run', false);
        this.config = {
            apiKey: process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
        this.logger = new logger_1.Logger((s) => this.context.stdout.write(s), logger_1.LogLevel.INFO);
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.config.fips, this.fipsIgnoreError || this.config.fipsIgnoreError);
            this.logger.setLogLevel(this.verbose ? logger_1.LogLevel.DEBUG : logger_1.LogLevel.INFO);
            this.logger.setShouldIncludeTime(this.verbose);
            if (this.serviceParam) {
                this.service = this.serviceParam;
            }
            else {
                this.logger.error('Missing service. It must be provided with --service or the DD_SERVICE env var');
                return 1;
            }
            if (this.startedAt > (this.finishedAt || new Date())) {
                this.logger.error('--started-at cannot be after --finished-at');
                return 1;
            }
            if (this.skipGit) {
                this.gitInfo = undefined;
            }
            else if (this.gitRepoURL && this.gitCommitSHA) {
                this.gitInfo = { repoURL: this.gitRepoURL, commitSHA: this.gitCommitSHA };
            }
            else {
                this.gitInfo = yield this.getGitInfo();
                this.logger.warn((0, renderer_1.renderGitWarning)(this.gitInfo));
            }
            const api = this.getApiHelper();
            yield this.sendDeploymentEvent(api, this.buildDeploymentEvent());
            if (!this.dryRun) {
                this.logger.info((0, renderer_1.renderSuccessfulRequest)(this.service));
            }
        });
    }
    getGitInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const git = (0, simple_git_1.default)({
                baseDir: process.cwd(),
                binary: 'git',
                // We are invoking at most 5 git commands at the same time.
                maxConcurrentProcesses: 5,
            });
            const [repoURL, commitSHA] = yield Promise.all([(0, get_git_data_1.gitRepositoryURL)(git), (0, get_git_data_1.gitHash)(git)]);
            return { repoURL, commitSHA };
        });
    }
    getApiHelper() {
        if (!this.config.apiKey) {
            this.logger.error(`Neither ${chalk_1.default.red.bold('DATADOG_API_KEY')} nor ${chalk_1.default.red.bold('DD_API_KEY')} is in your environment.`);
            throw new Error('API key is missing');
        }
        return (0, api_1.apiConstructor)(this.config.apiKey);
    }
    buildDeploymentEvent() {
        const deployment = {
            service: this.service,
            startedAt: this.startedAt,
            finishedAt: this.finishedAt || new Date(),
        };
        if (this.env) {
            deployment.env = this.env;
        }
        if (this.gitInfo) {
            deployment.git = this.gitInfo;
        }
        if (this.version) {
            deployment.version = this.version;
        }
        if (this.team) {
            deployment.team = this.team;
        }
        if (this.customTags) {
            deployment.customTags = this.customTags;
        }
        return deployment;
    }
    sendDeploymentEvent(api, deployment) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.dryRun) {
                this.logger.info((0, renderer_1.renderDryRun)(deployment));
                return;
            }
            try {
                this.logger.info((0, renderer_1.renderRequest)(this.service));
                yield (0, retry_1.retryRequest)(() => api.sendDeploymentEvent(deployment), {
                    onRetry: (e, attempt) => {
                        this.logger.warn((0, renderer_1.renderRetriedRequest)(this.service, e, attempt));
                    },
                    retries: 5,
                });
            }
            catch (error) {
                this.logger.error((0, renderer_1.renderFailedRequest)(this.service, error));
                if (error.response) {
                    // If it's an axios error
                    if (!nonRetriableErrorCodes.includes(error.response.status)) {
                        return;
                    }
                }
                throw error;
            }
        });
    }
}
exports.SendDeploymentEvent = SendDeploymentEvent;
SendDeploymentEvent.paths = [['dora', 'deployment']];
SendDeploymentEvent.usage = clipanion_1.Command.Usage({
    category: 'CI Visibility',
    description: 'Send a new Deployment event for DORA Metrics to Datadog.',
    details: `
    This command sends details to Datadog about a deployment of a service.\n
    See README for more details.
    `,
    examples: [
        [
            'Send a DORA deployment event for a service to the prod environment',
            'datadog-ci dora deployment --service my-service --env prod \\\n' +
                '    --started-at 1699960648 --finished-at 1699961048 \\\n' +
                '    --git-repository-url https://github.com/my-organization/my-repository \\\n' +
                '    --git-commit-sha 102836a25f5477e571c73d489b3f0f183687068e \\\n' +
                '    --version 1.0.0',
        ],
        [
            'Send a DORA deployment event with automatically extracted Git info (for deployments triggered from CI in the same repository as the application). The deployment is assumed to target the current HEAD commit',
            'datadog-ci dora deployment --service my-service --started-at $deploy_start --finished-at `date +%s`',
        ],
        [
            'Send a DORA deployment event to the datadoghq.eu site',
            'DD_SITE=datadoghq.eu datadog-ci dora deployment --service my-service --started-at $deploy_start',
        ],
        [
            'Send a DORA deployment event without git info. Change Lead Time is not available without Git info. The deployment finished-at is set to the current time',
            'datadog-ci dora deployment --service my-service --started-at $deploy_start --skip-git',
        ],
        [
            'Send a DORA deployment event providing the service name and env through environment vars',
            'DD_SERVICE=my-service DD_ENV=prod datadog-ci dora deployment --started-at $deploy_start',
        ],
    ],
});
//# sourceMappingURL=deployment.js.map