"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.maskConfig = exports.willUpdateFunctionConfigs = exports.handleLambdaFunctionUpdates = exports.updateFunctionConfiguration = exports.updateLambdaFunctionConfig = exports.sentenceMatchesRegEx = exports.isLayerRuntime = exports.isSupportedRuntime = exports.getRegion = exports.getLambdaFunctionConfig = exports.getLayers = exports.getLayerNameWithVersion = exports.getLayerArn = exports.getLambdaFunctionConfigs = exports.getLambdaFunctionConfigsFromRegex = exports.checkRuntimeTypesAreUniform = exports.getAllLambdaFunctionConfigs = exports.isMissingDatadogEnvVars = exports.isMissingAnyDatadogApiKeyEnvVar = exports.getAWSCredentials = exports.getAWSProfileCredentials = exports.getAWSFileCredentialsParams = exports.findLatestLayerVersion = exports.collectFunctionsByRegion = exports.coerceBoolean = exports.addLayerArn = void 0;
const client_lambda_1 = require("@aws-sdk/client-lambda");
const credential_providers_1 = require("@aws-sdk/credential-providers");
const property_provider_1 = require("@smithy/property-provider");
const inquirer_1 = __importDefault(require("inquirer"));
const constants_1 = require("../../../constants");
const helpersRenderer = __importStar(require("../../../helpers/renderer"));
const utils_1 = require("../../../helpers/utils");
const validation_1 = require("../../../helpers/validation");
const constants_2 = require("../constants");
const loggroup_1 = require("../loggroup");
const prompt_1 = require("../prompt");
const instrumentRenderer = __importStar(require("../renderers/instrument-uninstrument-renderer"));
const tags_1 = require("../tags");
/**
 * Returns an array of merged layer ARNs if given a Full Layer ARN,
 * if not, it justs returns the layer ARNs provided.
 *
 * @param fullLayerARN a complete layer ARN.
 * @param partialLayerARN a partial layer ARN.
 * @param layerARNs an array of layer ARNs.
 * @returns an array of layer ARNs.
 */
const addLayerArn = (fullLayerArn, previousLayerName, layerARNs) => {
    if (fullLayerArn) {
        if (!layerARNs.includes(fullLayerArn)) {
            // Remove any other versions of the layer
            layerARNs = [...layerARNs.filter((layer) => !layer.includes(previousLayerName)), fullLayerArn];
        }
    }
    return layerARNs;
};
exports.addLayerArn = addLayerArn;
/**
 * Returns a coerced boolean given string booleans or booleans in
 * an spread array. Every other value will be ignored.
 *
 * @param fallback default value if none of the provided `values` comply.
 * @param values an spread array of string booleans or booleans.
 * @returns a coerced boolean.
 */
const coerceBoolean = (fallback, ...values) => {
    for (const value of values) {
        switch (typeof value) {
            case 'boolean':
                return value;
            case 'string':
                if (value.toString().toLowerCase() === 'true') {
                    return true;
                }
                else if (value.toString().toLowerCase() === 'false') {
                    return false;
                }
                break;
            default:
                continue;
        }
    }
    return fallback;
};
exports.coerceBoolean = coerceBoolean;
/**
 * Returns an array of functions grouped by its region, it
 * throws an error if there are functions without a region.
 *
 * @param functions an array of strings comprised by
 * Functions ARNs, Partial ARNs, or Function Names.
 * @param defaultRegion a fallback region
 * @returns an array of functions grouped by region
 */
const collectFunctionsByRegion = (functions, defaultRegion) => {
    var _a;
    const groups = {};
    const regionless = [];
    for (const func of functions) {
        const region = (_a = (0, exports.getRegion)(func)) !== null && _a !== void 0 ? _a : defaultRegion;
        if (region === undefined) {
            regionless.push(func);
            continue;
        }
        if (groups[region] === undefined) {
            groups[region] = [];
        }
        const group = groups[region];
        group.push(func);
    }
    if (regionless.length > 0) {
        throw Error(`No default region specified for ${JSON.stringify(regionless)}. Use -r, --region, or use a full functionARN\n`);
    }
    return groups;
};
exports.collectFunctionsByRegion = collectFunctionsByRegion;
/**
 * Given a layer runtime, return its latest version.
 *
 * @param runtime the runtime of the layer.
 * @param region the region where the layer is stored.
 * @returns the latest version of the layer to find.
 */
const findLatestLayerVersion = (layer, region) => __awaiter(void 0, void 0, void 0, function* () {
    let latestVersion = 0;
    let searchStep = latestVersion > 0 ? 1 : 100;
    let layerVersion = latestVersion + searchStep;
    const account = region.startsWith('us-gov') ? constants_2.GOVCLOUD_LAYER_AWS_ACCOUNT : constants_2.DEFAULT_LAYER_AWS_ACCOUNT;
    const layerName = constants_2.LAYER_LOOKUP[layer];
    let foundLatestVersion = false;
    const lambdaClient = new client_lambda_1.LambdaClient({ region, retryStrategy: constants_2.EXPONENTIAL_BACKOFF_RETRY_STRATEGY });
    while (!foundLatestVersion) {
        try {
            // Search next version
            const command = new client_lambda_1.GetLayerVersionCommand({
                LayerName: `arn:aws:lambda:${region}:${account}:layer:${layerName}`,
                VersionNumber: layerVersion,
            });
            yield lambdaClient.send(command);
            latestVersion = layerVersion;
            // Increase layer version
            layerVersion += searchStep;
        }
        catch (_a) {
            // Search step is too big, reset target to previous version
            // with a smaller search step
            if (searchStep > 1) {
                layerVersion -= searchStep;
                searchStep /= 10;
                layerVersion += searchStep;
            }
            else {
                // Search step is 1, current version was not found.
                // It is likely that the last checked is the latest.
                // Check the next version to be certain, since
                // current version could've been deleted by accident.
                try {
                    layerVersion += searchStep;
                    const command = new client_lambda_1.GetLayerVersionCommand({
                        LayerName: `arn:aws:lambda:${region}:${account}:layer:${layerName}`,
                        VersionNumber: layerVersion,
                    });
                    yield lambdaClient.send(command);
                    latestVersion = layerVersion;
                    // Continue the search if the next version does exist (unlikely event)
                    layerVersion += searchStep;
                }
                catch (_b) {
                    // The next version doesn't exist either, so the previous version is indeed the latest
                    foundLatestVersion = true;
                }
            }
        }
    }
    return latestVersion;
});
exports.findLatestLayerVersion = findLatestLayerVersion;
const getAWSFileCredentialsParams = (profile) => {
    const init = { profile };
    if (process.env[constants_2.AWS_SHARED_CREDENTIALS_FILE_ENV_VAR] !== undefined) {
        init.filepath = process.env[constants_2.AWS_SHARED_CREDENTIALS_FILE_ENV_VAR];
    }
    // If provided profile is enforced by MFA and a session
    // token is not set we must request for the MFA token.
    init.mfaCodeProvider = (mfaSerial) => __awaiter(void 0, void 0, void 0, function* () {
        const answer = yield inquirer_1.default.prompt((0, prompt_1.awsProfileQuestion)(mfaSerial));
        return answer.AWS_MFA;
    });
    return init;
};
exports.getAWSFileCredentialsParams = getAWSFileCredentialsParams;
/**
 * Returns the loaded AWS Credentials from the given profile.
 *
 * Note: the AWS SDK loads credentials automatically in
 * node environments.
 *
 * @param {string} profile the AWS Credentials profile
 * @returns {AwsCredentialIdentity} credentials object.
 */
const getAWSProfileCredentials = (profile) => __awaiter(void 0, void 0, void 0, function* () {
    const init = (0, exports.getAWSFileCredentialsParams)(profile);
    try {
        const credentialsProvider = (0, credential_providers_1.fromIni)(init);
        const credentials = yield credentialsProvider();
        return credentials;
    }
    catch (err) {
        if (err instanceof Error) {
            throw Error(`Couldn't set AWS profile credentials. ${err.message}`);
        }
    }
});
exports.getAWSProfileCredentials = getAWSProfileCredentials;
const getAWSCredentials = () => __awaiter(void 0, void 0, void 0, function* () {
    const provider = (0, credential_providers_1.fromNodeProviderChain)();
    try {
        const credentials = yield provider();
        return credentials;
    }
    catch (err) {
        if (err instanceof Error) {
            if (err.name === property_provider_1.CredentialsProviderError.name) {
                return undefined;
            }
            throw Error(`Couldn't fetch AWS credentials. ${err.message}`);
        }
    }
});
exports.getAWSCredentials = getAWSCredentials;
const isMissingAnyDatadogApiKeyEnvVar = () => !(process.env[constants_1.CI_API_KEY_ENV_VAR] ||
    process.env[constants_1.API_KEY_ENV_VAR] ||
    process.env[constants_2.CI_KMS_API_KEY_ENV_VAR] ||
    process.env[constants_2.CI_API_KEY_SECRET_ARN_ENV_VAR]);
exports.isMissingAnyDatadogApiKeyEnvVar = isMissingAnyDatadogApiKeyEnvVar;
const isMissingDatadogEnvVars = () => !(0, validation_1.isValidDatadogSite)(process.env[constants_1.CI_SITE_ENV_VAR]) || (0, exports.isMissingAnyDatadogApiKeyEnvVar)();
exports.isMissingDatadogEnvVars = isMissingDatadogEnvVars;
const getAllLambdaFunctionConfigs = (lambdaClient) => __awaiter(void 0, void 0, void 0, function* () { return (0, exports.getLambdaFunctionConfigsFromRegex)(lambdaClient, '.'); });
exports.getAllLambdaFunctionConfigs = getAllLambdaFunctionConfigs;
// Returns false if not all runtimes are of the same RuntimeType across multiple functions
const checkRuntimeTypesAreUniform = (configList) => configList
    .map((item) => item.lambdaConfig.Runtime)
    .every((runtime) => constants_2.RUNTIME_LOOKUP[runtime] === constants_2.RUNTIME_LOOKUP[configList[0].lambdaConfig.Runtime]);
exports.checkRuntimeTypesAreUniform = checkRuntimeTypesAreUniform;
/**
 * Given a Lambda instance and a regular expression,
 * returns all the Function Configurations that match.
 *
 * @param lambda an instance of Lambda from aws-sdk.
 * @param pattern a regular expression
 * @returns an array of Lambda FunctionConfiguration's that match the pattern above.
 */
const getLambdaFunctionConfigsFromRegex = (lambdaClient, pattern) => __awaiter(void 0, void 0, void 0, function* () {
    var _c;
    const regEx = new RegExp(pattern);
    const matchedFunctions = [];
    let response;
    let nextMarker;
    while (true) {
        const command = new client_lambda_1.ListFunctionsCommand({ Marker: nextMarker });
        response = yield lambdaClient.send(command);
        (_c = response.Functions) === null || _c === void 0 ? void 0 : _c.map((fn) => { var _a; return ((_a = fn.FunctionName) === null || _a === void 0 ? void 0 : _a.match(regEx)) && matchedFunctions.push(fn); });
        nextMarker = response.NextMarker;
        if (!nextMarker) {
            break;
        }
    }
    return matchedFunctions;
});
exports.getLambdaFunctionConfigsFromRegex = getLambdaFunctionConfigsFromRegex;
/**
 * Given a Lambda instance and an array of Lambda names,
 * return all the Lambda Function Configurations.
 *
 * @param lambda an instance of Lambda from aws-sdk.
 * @param functionARNs an array of strings comprised by
 * Functions ARNs, Partial ARNs, or Function Names.
 * @returns an array of Lambda FunctionConfiguration's.
 */
const getLambdaFunctionConfigs = (lambdaClient, functionARNs) => {
    const promises = functionARNs.map((fn) => (0, exports.getLambdaFunctionConfig)(lambdaClient, fn));
    return Promise.all(promises);
};
exports.getLambdaFunctionConfigs = getLambdaFunctionConfigs;
/**
 * Returns the correct ARN of a **Specific Runtime Layer** given its configuration, region,
 * and settings (optional).
 *
 * @param config a Lambda FunctionConfiguration.
 * @param layer a Lambda layer.
 * @param region a region where the layer is hosted.
 * @param settings instrumentation settings, mainly used to change the AWS account that contains the Layer.
 * @returns the ARN of a **Specific Runtime Layer** with the correct region, account, architecture, and name.
 */
const getLayerArn = (config, layer, region, settings) => {
    var _a, _b;
    let layerName = constants_2.LAYER_LOOKUP[layer];
    if (constants_2.ARM_LAYERS.includes(layer) && ((_a = config.Architectures) === null || _a === void 0 ? void 0 : _a.includes(constants_2.ARM64_ARCHITECTURE))) {
        layerName += constants_2.ARM_LAYER_SUFFIX;
    }
    if (settings === null || settings === void 0 ? void 0 : settings.lambdaFips) {
        layerName += '-FIPS';
    }
    const account = (_b = settings === null || settings === void 0 ? void 0 : settings.layerAWSAccount) !== null && _b !== void 0 ? _b : constants_2.DEFAULT_LAYER_AWS_ACCOUNT;
    const isGovCloud = region.startsWith('us-gov');
    if (isGovCloud) {
        return `arn:aws-us-gov:lambda:${region}:${constants_2.GOVCLOUD_LAYER_AWS_ACCOUNT}:layer:${layerName}`;
    }
    return `arn:aws:lambda:${region}:${account}:layer:${layerName}`;
};
exports.getLayerArn = getLayerArn;
const getLayerNameWithVersion = (layerArn) => {
    const [, , , , , , name, version] = layerArn.split(':');
    return name && version ? `${name}:${version}` : undefined;
};
exports.getLayerNameWithVersion = getLayerNameWithVersion;
const getLayers = (config) => { var _a; return ((_a = config.Layers) !== null && _a !== void 0 ? _a : []).map((layer) => layer.Arn); };
exports.getLayers = getLayers;
/**
 * Call the aws-sdk Lambda api to get a Function given
 * an ARN and then return its Configuration.
 *
 * @param lambdaClient an instance of LambdaClient.
 * @param functionARN a string, can be Function ARN, Partial ARN, or a Function Name.
 * @returns the Lambda FunctionConfiguration of the given ARN.
 */
const getLambdaFunctionConfig = (lambdaClient, functionARN) => __awaiter(void 0, void 0, void 0, function* () {
    const params = {
        FunctionName: functionARN,
    };
    const command = new client_lambda_1.GetFunctionCommand(params);
    const response = yield lambdaClient.send(command);
    // AWS typescript API is slightly mistyped, adds undefineds where
    // there shouldn't be.
    const config = response.Configuration;
    return config;
});
exports.getLambdaFunctionConfig = getLambdaFunctionConfig;
/**
 * Given a Function ARN, return its region by splitting the string,
 * can return undefined if it doesn't exist.
 *
 * @param functionARN a string, can be Function ARN, Partial ARN, or a Function Name.
 * @returns the region of an ARN.
 */
const getRegion = (functionARN) => {
    const [, , , region] = functionARN.split(':');
    return region === undefined || region === '*' ? undefined : region;
};
exports.getRegion = getRegion;
/**
 * Returns whether the runtime given is supported by the Datadog CI Lambda.
 *
 * @param runtime a string representing a Lambda FunctionConfiguration Runtime.
 * @returns if a runtime is supported.
 */
const isSupportedRuntime = (runtime) => runtime !== undefined && constants_2.RUNTIME_LOOKUP[runtime] !== undefined;
exports.isSupportedRuntime = isSupportedRuntime;
const isLayerRuntime = (runtime) => constants_2.LAYER_LOOKUP[runtime] !== undefined;
exports.isLayerRuntime = isLayerRuntime;
const sentenceMatchesRegEx = (sentence, regex) => sentence.match(regex);
exports.sentenceMatchesRegEx = sentenceMatchesRegEx;
const updateLambdaFunctionConfig = (lambdaClient, cloudWatchLogsClient, config) => __awaiter(void 0, void 0, void 0, function* () {
    if (config.updateFunctionConfigurationCommandInput !== undefined) {
        yield (0, exports.updateFunctionConfiguration)(lambdaClient, config.updateFunctionConfigurationCommandInput);
    }
    if (config.logGroupConfiguration !== undefined) {
        yield (0, loggroup_1.applyLogGroupConfig)(cloudWatchLogsClient, config.logGroupConfiguration);
    }
    if (config.tagConfiguration !== undefined) {
        yield (0, tags_1.applyTagConfig)(lambdaClient, config.tagConfiguration);
    }
});
exports.updateLambdaFunctionConfig = updateLambdaFunctionConfig;
const updateFunctionConfiguration = (client, input) => __awaiter(void 0, void 0, void 0, function* () {
    const command = new client_lambda_1.UpdateFunctionConfigurationCommand(input);
    yield client.send(command);
});
exports.updateFunctionConfiguration = updateFunctionConfiguration;
const handleLambdaFunctionUpdates = (configGroups, stdout) => __awaiter(void 0, void 0, void 0, function* () {
    let totalFunctions = 0;
    let totalFailedUpdates = 0;
    for (const group of configGroups) {
        const spinner = instrumentRenderer.updatingFunctionsConfigFromRegionSpinner(group.region, group.configs.length);
        spinner.start();
        const failedUpdates = [];
        for (const config of group.configs) {
            totalFunctions += 1;
            try {
                yield (0, exports.updateLambdaFunctionConfig)(group.lambdaClient, group.cloudWatchLogsClient, config);
            }
            catch (err) {
                failedUpdates.push({ functionARN: config.functionARN, error: err });
                totalFailedUpdates += 1;
            }
        }
        if (failedUpdates.length === group.configs.length) {
            spinner.fail(instrumentRenderer.renderFailedUpdatingEveryLambdaFunctionFromRegion(group.region));
        }
        else if (failedUpdates.length > 0) {
            spinner.warn(instrumentRenderer.renderUpdatedLambdaFunctionsFromRegion(group.region, group.configs.length - failedUpdates.length));
        }
        for (const failedUpdate of failedUpdates) {
            stdout.write(instrumentRenderer.renderFailedUpdatingLambdaFunction(failedUpdate.functionARN, failedUpdate.error));
        }
        if (failedUpdates.length === 0) {
            spinner.succeed(instrumentRenderer.renderUpdatedLambdaFunctionsFromRegion(group.region, group.configs.length));
        }
    }
    if (totalFunctions === totalFailedUpdates) {
        stdout.write(instrumentRenderer.renderFail(instrumentRenderer.renderFailedUpdatingEveryLambdaFunction()));
        throw Error();
    }
    if (totalFailedUpdates > 0) {
        stdout.write(helpersRenderer.renderSoftWarning(instrumentRenderer.renderUpdatedLambdaFunctions(totalFunctions - totalFailedUpdates)));
    }
    if (!totalFailedUpdates) {
        stdout.write(instrumentRenderer.renderSuccess(instrumentRenderer.renderUpdatedLambdaFunctions(totalFunctions)));
    }
});
exports.handleLambdaFunctionUpdates = handleLambdaFunctionUpdates;
const willUpdateFunctionConfigs = (configs) => {
    var _a, _b, _c;
    let willUpdate = false;
    for (const config of configs) {
        if (config.updateFunctionConfigurationCommandInput !== undefined ||
            ((_a = config.logGroupConfiguration) === null || _a === void 0 ? void 0 : _a.createLogGroupCommandInput) !== undefined ||
            ((_b = config.logGroupConfiguration) === null || _b === void 0 ? void 0 : _b.deleteSubscriptionFilterCommandInput) !== undefined ||
            ((_c = config.logGroupConfiguration) === null || _c === void 0 ? void 0 : _c.putSubscriptionFilterCommandInput) !== undefined ||
            (config === null || config === void 0 ? void 0 : config.tagConfiguration) !== undefined) {
            willUpdate = true;
            break;
        }
    }
    return willUpdate;
};
exports.willUpdateFunctionConfigs = willUpdateFunctionConfigs;
/**
 * Masks environment variables in a Lambda function configuration.
 * Makes a copy as to not modify the config in place.
 * @param config
 * @returns masked config
 */
const maskConfig = (config) => {
    var _a;
    // We stringify and parse again to make a deep copy
    const configCopy = JSON.parse(JSON.stringify(config));
    const vars = (_a = configCopy.Environment) === null || _a === void 0 ? void 0 : _a.Variables;
    if (!vars) {
        return configCopy;
    }
    for (const key in vars) {
        if (!constants_2.SKIP_MASKING_LAMBDA_ENV_VARS.has(key)) {
            vars[key] = (0, utils_1.maskString)(vars[key]);
        }
    }
    return configCopy;
};
exports.maskConfig = maskConfig;
//# sourceMappingURL=commons.js.map