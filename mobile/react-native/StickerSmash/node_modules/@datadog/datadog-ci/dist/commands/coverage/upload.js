"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UploadCodeCoverageReportCommand = void 0;
const os_1 = __importDefault(require("os"));
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const upath_1 = __importDefault(require("upath"));
const constants_1 = require("../../constants");
const ci_1 = require("../../helpers/ci");
const env_1 = require("../../helpers/env");
const file_finder_1 = require("../../helpers/file-finder");
const fips_1 = require("../../helpers/fips");
const format_git_span_data_1 = require("../../helpers/git/format-git-span-data");
const glob_1 = require("../../helpers/glob");
const id_1 = __importDefault(require("../../helpers/id"));
const logger_1 = require("../../helpers/logger");
const retry_1 = require("../../helpers/retry");
const tags_1 = require("../../helpers/tags");
const user_provided_git_1 = require("../../helpers/user-provided-git");
const utils_1 = require("../../helpers/utils");
const git_metadata_1 = require("../git-metadata");
const git_1 = require("../git-metadata/git");
const gitdb_1 = require("../git-metadata/gitdb");
const api_1 = require("../junit/api");
const api_2 = require("./api");
const renderer_1 = require("./renderer");
const utils_2 = require("./utils");
const TRACE_ID_HTTP_HEADER = 'x-datadog-trace-id';
const PARENT_ID_HTTP_HEADER = 'x-datadog-parent-id';
const errorCodesStopUpload = [400, 403];
const MAX_REPORTS_PER_REQUEST = 8; // backend supports 10 attachments, to keep the logic simple we subtract 2: for PR diff and commit diff
class UploadCodeCoverageReportCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.reportPaths = clipanion_1.Option.Rest({ required: 1 });
        this.verbose = clipanion_1.Option.Boolean('--verbose', false);
        this.dryRun = clipanion_1.Option.Boolean('--dry-run', false);
        this.measures = clipanion_1.Option.Array('--measures');
        this.tags = clipanion_1.Option.Array('--tags');
        this.format = clipanion_1.Option.String('--format');
        this.uploadGitDiff = clipanion_1.Option.Boolean('--upload-git-diff', true);
        this.skipGitMetadataUpload = clipanion_1.Option.Boolean('--skip-git-metadata-upload', false);
        this.gitRepositoryURL = clipanion_1.Option.String('--git-repository-url');
        this.basePath = clipanion_1.Option.String('--base-path');
        this.ignoredPaths = clipanion_1.Option.String('--ignored-paths');
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.config = {
            apiKey: process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
            env: process.env.DD_ENV,
            envVarTags: process.env.DD_TAGS,
            envVarMeasures: process.env.DD_MEASURES,
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
        this.logger = new logger_1.Logger((s) => this.context.stdout.write(s), logger_1.LogLevel.INFO);
        this.git = undefined;
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.config.fips, this.fipsIgnoreError || this.config.fipsIgnoreError);
            this.logger.setLogLevel(this.verbose ? logger_1.LogLevel.DEBUG : logger_1.LogLevel.INFO);
            this.logger.setShouldIncludeTime(this.verbose);
            if (!this.reportPaths.length) {
                this.context.stderr.write('Positional arguments must be provided\n');
                return 1;
            }
            if (this.format && !(0, utils_2.isCoverageFormat)(this.format)) {
                this.context.stderr.write(`Unsupported format: ${this.format}, supported values are [${utils_2.coverageFormats.join(', ')}]\n`);
                return 1;
            }
            const isGitRepository = yield (0, git_metadata_1.isGitRepo)();
            if (isGitRepository) {
                this.git = yield (0, git_1.newSimpleGit)();
            }
            if (!this.skipGitMetadataUpload) {
                if (isGitRepository) {
                    const traceId = (0, id_1.default)();
                    const requestBuilder = (0, utils_1.getRequestBuilder)({
                        baseUrl: api_1.apiUrl,
                        apiKey: this.config.apiKey,
                        headers: new Map([
                            [TRACE_ID_HTTP_HEADER, traceId],
                            [PARENT_ID_HTTP_HEADER, traceId],
                        ]),
                    });
                    try {
                        this.logger.info(`${this.dryRun ? '[DRYRUN] ' : ''}Syncing git metadata...`);
                        let elapsed = 0;
                        if (!this.dryRun) {
                            elapsed = yield (0, utils_1.timedExecAsync)(this.uploadToGitDB.bind(this), { requestBuilder });
                        }
                        this.logger.info((0, renderer_1.renderSuccessfulGitDBSync)(this.dryRun, elapsed));
                    }
                    catch (err) {
                        this.logger.info((0, renderer_1.renderFailedGitDBSync)(err));
                    }
                }
                else {
                    this.logger.info(`${this.dryRun ? '[DRYRUN] ' : ''}Not syncing git metadata (not a git repo)`);
                }
            }
            else {
                this.logger.debug('Not syncing git metadata (skip git upload flag detected)');
            }
            yield this.uploadCodeCoverageReports();
        });
    }
    uploadToGitDB(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.git) {
                return;
            }
            yield (0, gitdb_1.uploadToGitDB)(this.logger, opts.requestBuilder, this.git, this.dryRun, this.gitRepositoryURL);
        });
    }
    uploadCodeCoverageReports() {
        return __awaiter(this, void 0, void 0, function* () {
            // Normalizing the report paths to resolve .. and .
            this.reportPaths = this.reportPaths.map((reportPath) => upath_1.default.normalize(reportPath));
            this.logger.info((0, renderer_1.renderCommandInfo)(this.reportPaths, this.dryRun));
            const spanTags = yield this.getSpanTags();
            const api = this.getApiHelper();
            const payloads = yield this.generatePayloads(spanTags);
            let fileCount = 0;
            const initialTime = new Date().getTime();
            for (const payload of payloads) {
                fileCount += payload.paths.length;
                yield this.uploadCodeCoverageReport(api, payload);
            }
            const totalTimeSeconds = (Date.now() - initialTime) / 1000;
            this.logger.info((0, renderer_1.renderSuccessfulUpload)(this.dryRun, fileCount, totalTimeSeconds));
            if (!this.dryRun) {
                this.context.stdout.write((0, renderer_1.renderSuccessfulUploadCommand)(spanTags));
            }
        });
    }
    getApiHelper() {
        if (!this.config.apiKey) {
            this.logger.error(`Neither ${chalk_1.default.red.bold('DATADOG_API_KEY')} nor ${chalk_1.default.red.bold('DD_API_KEY')} is in your environment.`);
            throw new Error('API key is missing');
        }
        return (0, api_2.apiConstructor)(api_2.intakeUrl, this.config.apiKey);
    }
    generatePayloads(spanTags) {
        return __awaiter(this, void 0, void 0, function* () {
            const customTags = this.getCustomTags();
            const customMeasures = this.getCustomMeasures();
            if (!!customTags['resolved']) {
                throw new Error('"resolved" is a reserved tag name, please avoid using it in your custom tags');
            }
            const commitDiff = yield this.getCommitDiff(spanTags);
            const prDiff = yield this.getPrDiff(spanTags);
            const reports = this.getMatchingCoverageReportFilesByFormat();
            let payloads = [];
            if (Object.keys(reports).length) {
                payloads = Object.entries(reports).flatMap(([format, paths]) => {
                    const numChunks = Math.ceil(paths.length / MAX_REPORTS_PER_REQUEST);
                    return Array.from({ length: numChunks }, (_, i) => ({
                        format,
                        basePath: this.basePath,
                        paths: paths.slice(i * MAX_REPORTS_PER_REQUEST, (i + 1) * MAX_REPORTS_PER_REQUEST),
                        spanTags,
                        customTags,
                        customMeasures,
                        hostname: os_1.default.hostname(),
                        commitDiff,
                        prDiff,
                    }));
                });
            }
            return payloads;
        });
    }
    getPrDiff(spanTags) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.uploadGitDiff || !this.git) {
                return undefined;
            }
            try {
                const pr = yield this.getHeadAndBase(spanTags);
                if (!pr.headSha || !pr.baseSha) {
                    return undefined;
                }
                return yield (0, git_1.getGitDiff)(this.git, pr.baseSha, pr.headSha);
            }
            catch (e) {
                this.logger.debug(`Error while trying to calculate PR diff: ${e}`);
                return undefined;
            }
        });
    }
    getHeadAndBase(spanTags) {
        return __awaiter(this, void 0, void 0, function* () {
            const headSha = spanTags[tags_1.GIT_HEAD_SHA] || spanTags[tags_1.GIT_SHA];
            if (!headSha) {
                return {};
            }
            if (!this.git) {
                return {};
            }
            const baseSha = spanTags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH_SHA] || spanTags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA];
            if (baseSha) {
                // GitHub incorrectly reports base SHA as the head of the target branch
                // doing a merge-base allows us to get the real base SHA
                // (and if the base SHA was reported correctly, merge-base will not alter it)
                const mergeBase = yield (0, git_1.getMergeBase)(this.git, baseSha, headSha);
                return { headSha, baseSha: mergeBase };
            }
            const baseBranch = spanTags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH];
            if (baseBranch) {
                const mergeBase = yield (0, git_1.getMergeBase)(this.git, baseBranch, headSha);
                return { headSha, baseSha: mergeBase };
            }
            return {};
        });
    }
    getCommitDiff(spanTags) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.uploadGitDiff) {
                return undefined;
            }
            const commit = spanTags[tags_1.GIT_HEAD_SHA] || spanTags[tags_1.GIT_SHA];
            if (!commit) {
                return undefined;
            }
            if (!this.git) {
                return undefined;
            }
            try {
                return yield (0, git_1.getGitDiff)(this.git, commit + '^', commit);
            }
            catch (e) {
                this.logger.debug(`Error while trying to calculate commit diff: ${e}`);
                return undefined;
            }
        });
    }
    getSpanTags() {
        return __awaiter(this, void 0, void 0, function* () {
            const ciSpanTags = (0, ci_1.getCISpanTags)();
            const gitSpanTags = yield (0, format_git_span_data_1.getGitMetadata)();
            const userGitSpanTags = (0, user_provided_git_1.getUserGitSpanTags)();
            const spanTags = Object.assign(Object.assign(Object.assign(Object.assign({}, gitSpanTags), ciSpanTags), userGitSpanTags), (this.config.env ? { env: this.config.env } : {}));
            if (!spanTags[tags_1.GIT_REPOSITORY_URL]) {
                throw new Error('git repository URL is missing');
            }
            if (!spanTags[tags_1.GIT_SHA]) {
                throw new Error('git commit SHA is missing');
            }
            return spanTags;
        });
    }
    getCustomTags() {
        const envVarTags = this.config.envVarTags ? (0, tags_1.parseTags)(this.config.envVarTags.split(',')) : {};
        const cliTags = this.tags ? (0, tags_1.parseTags)(this.tags) : {};
        return Object.assign(Object.assign({}, cliTags), envVarTags);
    }
    getCustomMeasures() {
        const envVarMeasures = this.config.envVarMeasures ? (0, tags_1.parseMetrics)(this.config.envVarMeasures.split(',')) : {};
        const cliMeasures = this.measures ? (0, tags_1.parseMetrics)(this.measures) : {};
        return Object.assign(Object.assign({}, cliMeasures), envVarMeasures);
    }
    getMatchingCoverageReportFilesByFormat() {
        return (0, file_finder_1.partitionFiles)(this.reportPaths || ['.'], (0, glob_1.parsePathsList)(this.ignoredPaths), this.getCoverageReportFormat.bind(this));
    }
    getCoverageReportFormat(filePath, strict) {
        const format = (0, utils_2.toCoverageFormat)(this.format) || (0, utils_2.detectFormat)(filePath);
        if (!format) {
            if (strict) {
                this.context.stdout.write((0, renderer_1.renderInvalidFile)(filePath, `format could not be detected`));
            }
            return undefined;
        }
        const validationError = (0, utils_2.validateCoverageReport)(filePath, format);
        if (validationError) {
            this.context.stdout.write((0, renderer_1.renderInvalidFile)(filePath, validationError));
            return undefined;
        }
        return format;
    }
    uploadCodeCoverageReport(api, codeCoverageReport) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.dryRun) {
                this.logger.info((0, renderer_1.renderDryRunUpload)(codeCoverageReport));
                return;
            }
            try {
                this.logger.info((0, renderer_1.renderUpload)(codeCoverageReport));
                yield (0, retry_1.retryRequest)(() => api.uploadCodeCoverageReport(codeCoverageReport), {
                    onRetry: (e, attempt) => {
                        this.context.stderr.write((0, renderer_1.renderRetriedUpload)(codeCoverageReport, e.message, attempt));
                    },
                    retries: 5,
                });
            }
            catch (error) {
                this.context.stderr.write((0, renderer_1.renderFailedUpload)(codeCoverageReport, error));
                if (error.response) {
                    // If it's an axios error
                    if (!errorCodesStopUpload.includes(error.response.status)) {
                        // And a status code that should not stop the whole upload, just return
                        return;
                    }
                }
                throw error;
            }
        });
    }
}
exports.UploadCodeCoverageReportCommand = UploadCodeCoverageReportCommand;
UploadCodeCoverageReportCommand.paths = [['coverage', 'upload']];
UploadCodeCoverageReportCommand.usage = clipanion_1.Command.Usage({
    category: 'CI Visibility',
    description: 'Upload code coverage reports files to Datadog.',
    details: `
      This command will upload code coverage report files to Datadog.\n
      See README for details.
    `,
    examples: [
        ['Upload all code coverage report files in current directory and its subfolders', 'datadog-ci coverage upload .'],
        [
            'Upload all code coverage report files in current directory and its subfolders, ignoring src/ignored-module-a and src/ignored-module-b',
            'datadog-ci coverage upload --ignored-paths src/ignored-module-a,src/ignored-module-b .',
        ],
        [
            'Upload all code coverage report files in src/unit-test-coverage and src/acceptance-test-coverage',
            'datadog-ci coverage upload src/unit-test-coverage src/acceptance-test-coverage',
        ],
        [
            'Upload all XML code coverage report files in /coverage/ folders, ignoring src/ignored-module-a',
            'datadog-ci coverage upload **/coverage/*.xml --ignored-paths src/ignored-module-a',
        ],
        [
            'Upload all code coverage report files in current directory and add extra tags globally',
            'datadog-ci coverage upload --tags key1:value1 --tags key2:value2 .',
        ],
        [
            'Upload all code coverage report files in current directory and add extra measures globally',
            'datadog-ci coverage upload --measures key1:123 --measures key2:321 .',
        ],
        [
            'Upload all code coverage report files in current directory to the datadoghq.eu site',
            'DD_SITE=datadoghq.eu datadog-ci coverage upload .',
        ],
        [
            'Upload all code coverage report files in current directory with extra verbosity',
            'datadog-ci coverage upload --verbose .',
        ],
    ],
});
//# sourceMappingURL=upload.js.map