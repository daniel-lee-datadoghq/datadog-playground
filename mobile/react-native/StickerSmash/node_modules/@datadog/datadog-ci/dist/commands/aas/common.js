"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseResourceId = exports.formatError = exports.collectAsyncIterator = exports.isLinuxContainer = exports.isDotnet = exports.isWindows = exports.getEnvVars = exports.parseEnvVars = exports.AasCommand = exports.AAS_DD_SETTING_NAMES = exports.SIDECAR_PORT = exports.SIDECAR_IMAGE = exports.SIDECAR_CONTAINER_NAME = void 0;
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const constants_1 = require("../../constants");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const renderer_1 = require("../../helpers/renderer");
const utils_1 = require("../../helpers/utils");
exports.SIDECAR_CONTAINER_NAME = 'datadog-sidecar';
exports.SIDECAR_IMAGE = 'index.docker.io/datadog/serverless-init:latest';
exports.SIDECAR_PORT = '8126';
// Path to tracing libraries, copied within the Docker file
const DD_DOTNET_TRACER_HOME = '/home/site/wwwroot/datadog';
// Where tracer logs are stored
const DD_TRACE_LOG_DIRECTORY = '/home/LogFiles/dotnet';
// Instructs the .NET CLR that profiling should be enabled
const CORECLR_ENABLE_PROFILING = '1';
// Profiler GUID
const CORECLR_PROFILER = '{846F5F1C-F9AE-4B07-969E-05C26BC060D8}';
// The profiler binary that the .NET CLR loads into memory, which contains the GUID
const CORECLR_PROFILER_PATH = '/home/site/wwwroot/datadog/linux-x64/Datadog.Trace.ClrProfiler.Native.so';
const CORECLR_PROFILER_PATH_MUSL = '/home/site/wwwroot/datadog/linux-musl-x64/Datadog.Trace.ClrProfiler.Native.so';
const ENV_VAR_REGEX = /^([\w.]+)=(.*)$/;
exports.AAS_DD_SETTING_NAMES = [
    'DD_API_KEY',
    'DD_SITE',
    'DD_AAS_INSTANCE_LOGGING_ENABLED',
    'DD_SERVICE',
    'DD_ENV',
    'DD_VERSION',
    'DD_SERVERLESS_LOG_PATH',
    'DD_DOTNET_TRACER_HOME',
    'DD_TRACE_LOG_DIRECTORY',
    'CORECLR_ENABLE_PROFILING',
    'CORECLR_PROFILER',
    'CORECLR_PROFILER_PATH',
    'DD_TAGS',
];
class AasCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.dryRun = clipanion_1.Option.Boolean('-d,--dry-run', false, {
            description: 'Run the command in dry-run mode, without making any changes',
        });
        this.subscriptionId = clipanion_1.Option.String('-s,--subscription-id', {
            description: 'Azure Subscription ID containing the App Service',
        });
        this.resourceGroup = clipanion_1.Option.String('-g,--resource-group', {
            description: 'Name of the Azure Resource Group containing the App Service',
        });
        this.aasName = clipanion_1.Option.String('-n,--name', {
            description: 'Name of the Azure App Service to instrument',
        });
        this.resourceIds = clipanion_1.Option.Array('-r,--resource-id', {
            description: 'Full Azure resource IDs to instrument, eg "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Web/sites/{aasName}"',
        });
        this.envVars = clipanion_1.Option.Array('-e,--env-vars', {
            description: 'Additional environment variables to set for the App Service. Can specify multiple in the form `--env-vars VAR1=VALUE1 --env-vars VAR2=VALUE2`.',
        });
        this.configPath = clipanion_1.Option.String('--config', {
            description: 'Path to the configuration file',
        });
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.fipsConfig = {
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
    }
    get dryRunPrefix() {
        return this.dryRun ? renderer_1.dryRunTag + ' ' : '';
    }
    get additionalConfig() {
        return {};
    }
    enableFips() {
        (0, fips_1.enableFips)(this.fips || this.fipsConfig.fips, this.fipsIgnoreError || this.fipsConfig.fipsIgnoreError);
    }
    ensureConfig() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const config = (yield (0, utils_1.resolveConfigFromFile)({
                aas: Object.assign({ subscriptionId: this.subscriptionId, resourceGroup: this.resourceGroup, aasName: this.aasName, envVars: this.envVars }, this.additionalConfig),
            }, {
                configPath: this.configPath,
                defaultConfigPaths: utils_1.DEFAULT_CONFIG_PATHS,
            })).aas;
            const appServices = {};
            const errors = [];
            if (process.env.DD_API_KEY === undefined) {
                errors.push('DD_API_KEY environment variable is required');
            }
            // Validate that envVars, if provided, are in the format 'key=value'
            if ((_a = config.envVars) === null || _a === void 0 ? void 0 : _a.some((e) => !ENV_VAR_REGEX.test(e))) {
                errors.push('All envVars must be in the format `KEY=VALUE`');
            }
            // Validate that extraTags, if provided, comply with the expected format
            if (config.extraTags && !config.extraTags.match(constants_1.EXTRA_TAGS_REG_EXP)) {
                errors.push('Extra tags do not comply with the <key>:<value> array.');
            }
            // Validate musl setting
            if (config.isMusl && !config.isDotnet) {
                errors.push('--musl can only be set if --dotnet is also set, as it is only relevant for containerized .NET applications.');
            }
            const specifiedSiteArgs = [config.subscriptionId, config.resourceGroup, config.aasName];
            // all or none of the site args should be specified
            if (!(specifiedSiteArgs.every((arg) => arg) || specifiedSiteArgs.every((arg) => !arg))) {
                errors.push('--subscription-id, --resource-group, and --name must be specified together or not at all');
            }
            else if (specifiedSiteArgs.every((arg) => arg)) {
                appServices[config.subscriptionId] = { [config.resourceGroup]: [config.aasName] };
            }
            if ((_b = this.resourceIds) === null || _b === void 0 ? void 0 : _b.length) {
                for (const resourceId of this.resourceIds) {
                    const parsed = (0, exports.parseResourceId)(resourceId);
                    if (parsed) {
                        const { subscriptionId, resourceGroup, name } = parsed;
                        if (!appServices[subscriptionId]) {
                            appServices[subscriptionId] = {};
                        }
                        if (!appServices[subscriptionId][resourceGroup]) {
                            appServices[subscriptionId][resourceGroup] = [];
                        }
                        appServices[subscriptionId][resourceGroup].push(name);
                    }
                    else {
                        errors.push(`Invalid AAS resource ID: ${resourceId}`);
                    }
                }
            }
            if (!((_c = this.resourceIds) === null || _c === void 0 ? void 0 : _c.length) && specifiedSiteArgs.every((arg) => !arg)) {
                errors.push('No App Services specified to instrument');
            }
            return [appServices, config, errors];
        });
    }
    ensureAzureAuth(cred) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield cred.getToken('https://management.azure.com/.default');
            }
            catch (error) {
                this.context.stdout.write((0, renderer_1.renderSoftWarning)(`Failed to authenticate with Azure: ${error.name}\n\nPlease ensure that you have the Azure CLI installed (https://aka.ms/azure-cli) and have run ${chalk_1.default.bold('az login')} to authenticate.\n`));
                return false;
            }
            return true;
        });
    }
    ensureLinux(site) {
        if ((0, exports.isWindows)(site)) {
            this.context.stdout.write((0, renderer_1.renderSoftWarning)(`Unable to instrument ${site.name}. Only Linux-based Azure App Services are currently supported.
Please see the documentation for information on
how to instrument Windows-based App Services:
https://docs.datadoghq.com/serverless/azure_app_services/azure_app_services_windows`));
            return false;
        }
        return true;
    }
}
exports.AasCommand = AasCommand;
const parseEnvVars = (envVars) => {
    const result = {};
    envVars === null || envVars === void 0 ? void 0 : envVars.forEach((e) => {
        const match = e.match(ENV_VAR_REGEX);
        if (match) {
            const [, key, value] = match;
            result[key] = value;
        }
    });
    return result;
};
exports.parseEnvVars = parseEnvVars;
const getEnvVars = (config) => {
    var _a, _b;
    let envVars = Object.assign({ DD_API_KEY: process.env.DD_API_KEY, DD_SITE: (_a = process.env.DD_SITE) !== null && _a !== void 0 ? _a : constants_1.DATADOG_SITE_US1, DD_AAS_INSTANCE_LOGGING_ENABLED: ((_b = config.isInstanceLoggingEnabled) !== null && _b !== void 0 ? _b : false).toString() }, (0, exports.parseEnvVars)(config.envVars));
    if (config.service) {
        envVars.DD_SERVICE = config.service;
    }
    if (config.environment) {
        envVars.DD_ENV = config.environment;
    }
    if (config.version) {
        envVars.DD_VERSION = config.version;
    }
    if (config.logPath) {
        envVars.DD_SERVERLESS_LOG_PATH = config.logPath;
    }
    if (config.extraTags) {
        envVars.DD_TAGS = config.extraTags;
    }
    if (config.isDotnet) {
        envVars = Object.assign(Object.assign({}, envVars), { DD_DOTNET_TRACER_HOME,
            DD_TRACE_LOG_DIRECTORY,
            CORECLR_ENABLE_PROFILING,
            CORECLR_PROFILER, CORECLR_PROFILER_PATH: config.isMusl ? CORECLR_PROFILER_PATH_MUSL : CORECLR_PROFILER_PATH });
    }
    return envVars;
};
exports.getEnvVars = getEnvVars;
const isWindows = (site) => {
    var _a;
    if (!site.kind) {
        // search for windowsFxVersion in siteConfig if there is no kind
        return !!((_a = site.siteConfig) === null || _a === void 0 ? void 0 : _a.windowsFxVersion);
    }
    return site.kind.includes('windows');
};
exports.isWindows = isWindows;
const isDotnet = (site) => {
    var _a, _b;
    return ((!!((_a = site.siteConfig) === null || _a === void 0 ? void 0 : _a.linuxFxVersion) && site.siteConfig.linuxFxVersion.toLowerCase().startsWith('dotnet')) ||
        (!!((_b = site.siteConfig) === null || _b === void 0 ? void 0 : _b.windowsFxVersion) && site.siteConfig.windowsFxVersion.toLowerCase().startsWith('dotnet')));
};
exports.isDotnet = isDotnet;
const isLinuxContainer = (site) => {
    var _a;
    return !!((_a = site.siteConfig) === null || _a === void 0 ? void 0 : _a.linuxFxVersion) && site.siteConfig.linuxFxVersion.toLowerCase() === 'sitecontainers';
};
exports.isLinuxContainer = isLinuxContainer;
const collectAsyncIterator = (it) => { var _a, it_1, it_1_1; return __awaiter(void 0, void 0, void 0, function* () {
    var _b, e_1, _c, _d;
    const arr = [];
    try {
        for (_a = true, it_1 = __asyncValues(it); it_1_1 = yield it_1.next(), _b = it_1_1.done, !_b; _a = true) {
            _d = it_1_1.value;
            _a = false;
            const x = _d;
            arr.push(x);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (!_a && !_b && (_c = it_1.return)) yield _c.call(it_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return arr;
}); };
exports.collectAsyncIterator = collectAsyncIterator;
/**
 * Formats an error (usually an Azure RestError) object into a string for display.
 */
// no-dd-sa:typescript-best-practices/no-explicit-any
const formatError = (error) => {
    var _a, _b, _c;
    const errorType = (_a = error.code) !== null && _a !== void 0 ? _a : error.name;
    const errorMessage = (_c = (_b = error.details) === null || _b === void 0 ? void 0 : _b.message) !== null && _c !== void 0 ? _c : error.message;
    return `${errorType}: ${errorMessage}`;
};
exports.formatError = formatError;
const parseResourceId = (resourceId) => {
    const match = resourceId.match(/^\/subscriptions\/([^/]+)\/resourceGroups\/([^/]+)\/providers\/Microsoft\.Web\/sites\/([^/]+)$/i);
    if (match) {
        const [, subscriptionId, resourceGroup, name] = match;
        return { subscriptionId, resourceGroup, name };
    }
};
exports.parseResourceId = parseResourceId;
//# sourceMappingURL=common.js.map