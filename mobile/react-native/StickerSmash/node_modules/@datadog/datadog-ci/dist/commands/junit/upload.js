"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UploadJUnitXMLCommand = void 0;
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const fast_xml_parser_1 = require("fast-xml-parser");
const t = __importStar(require("typanion"));
const upath_1 = __importDefault(require("upath"));
const constants_1 = require("../../constants");
const ci_1 = require("../../helpers/ci");
const concurrency_1 = require("../../helpers/concurrency");
const env_1 = require("../../helpers/env");
const file_finder_1 = require("../../helpers/file-finder");
const fips_1 = require("../../helpers/fips");
const format_git_span_data_1 = require("../../helpers/git/format-git-span-data");
const glob_1 = require("../../helpers/glob");
const id_1 = __importDefault(require("../../helpers/id"));
const logger_1 = require("../../helpers/logger");
const retry_1 = require("../../helpers/retry");
const tags_1 = require("../../helpers/tags");
const user_provided_git_1 = require("../../helpers/user-provided-git");
const utils_1 = require("../../helpers/utils");
const validation = __importStar(require("../../helpers/validation"));
const git_metadata_1 = require("../git-metadata");
const git_1 = require("../git-metadata/git");
const gitdb_1 = require("../git-metadata/gitdb");
const api_1 = require("./api");
const renderer_1 = require("./renderer");
const TRACE_ID_HTTP_HEADER = 'x-datadog-trace-id';
const PARENT_ID_HTTP_HEADER = 'x-datadog-parent-id';
const errorCodesStopUpload = [400, 403];
const isJunitXmlReport = (file) => {
    if (upath_1.default.extname(file) !== '.xml') {
        return false;
    }
    const filename = upath_1.default.basename(file);
    return (filename.includes('junit') || // *junit*.xml
        filename.includes('test') || // *test*.xml
        filename.includes('TEST-') // *TEST-*.xml
    );
};
const validateXml = (xmlFilePath) => {
    const xmlFileContentString = String(fs_1.default.readFileSync(xmlFilePath));
    const validationOutput = fast_xml_parser_1.XMLValidator.validate(xmlFileContentString);
    if (validationOutput !== true) {
        return validationOutput.err.msg;
    }
    const xmlParser = new fast_xml_parser_1.XMLParser();
    const xmlFileJSON = xmlParser.parse(String(xmlFileContentString));
    if (!('testsuites' in xmlFileJSON) && !('testsuite' in xmlFileJSON)) {
        return 'Neither <testsuites> nor <testsuite> are the root tag.';
    }
    else if (!xmlFileJSON.testsuite && !xmlFileJSON.testsuites) {
        return 'The junit report file is empty, there are no <testcase> elements.';
    }
    return undefined;
};
class UploadJUnitXMLCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.basePaths = clipanion_1.Option.Rest({ required: 1 });
        this.verbose = clipanion_1.Option.Boolean('--verbose', false);
        this.dryRun = clipanion_1.Option.Boolean('--dry-run', false);
        this.env = clipanion_1.Option.String('--env');
        this.logs = clipanion_1.Option.String('--logs', 'false', {
            env: 'DD_CIVISIBILITY_LOGS_ENABLED',
            tolerateBoolean: true,
            validator: t.isBoolean(),
        });
        this.maxConcurrency = clipanion_1.Option.String('--max-concurrency', '20', { validator: validation.isInteger() });
        this.measures = clipanion_1.Option.Array('--measures');
        this.service = clipanion_1.Option.String('--service', { env: 'DD_SERVICE' });
        this.tags = clipanion_1.Option.Array('--tags');
        this.reportTags = clipanion_1.Option.Array('--report-tags');
        this.reportMeasures = clipanion_1.Option.Array('--report-measures');
        this.rawXPathTags = clipanion_1.Option.Array('--xpath-tag');
        this.gitRepositoryURL = clipanion_1.Option.String('--git-repository-url');
        this.skipGitMetadataUpload = clipanion_1.Option.String('--skip-git-metadata-upload', 'false', {
            validator: t.isBoolean(),
            tolerateBoolean: true,
        });
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.automaticReportsDiscovery = clipanion_1.Option.String('--auto-discovery', 'false', {
            validator: t.isBoolean(),
            tolerateBoolean: true,
        });
        this.ignoredPaths = clipanion_1.Option.String('--ignored-paths');
        this.config = {
            apiKey: process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
            env: process.env.DD_ENV,
            envVarTags: process.env.DD_TAGS,
            envVarMetrics: process.env.DD_METRICS,
            envVarMeasures: process.env.DD_MEASURES,
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
        this.logger = new logger_1.Logger((s) => this.context.stdout.write(s), logger_1.LogLevel.INFO);
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.config.fips, this.fipsIgnoreError || this.config.fipsIgnoreError);
            this.logger.setLogLevel(this.verbose ? logger_1.LogLevel.DEBUG : logger_1.LogLevel.INFO);
            this.logger.setShouldIncludeTime(this.verbose);
            if (!this.basePaths || !this.basePaths.length) {
                this.context.stderr.write('Missing basePath\n');
                return 1;
            }
            if (!this.config.env) {
                this.config.env = this.env;
            }
            if (this.rawXPathTags) {
                this.xpathTags = this.parseXPathTags(this.rawXPathTags);
                if (Object.keys(this.xpathTags).length !== this.rawXPathTags.length) {
                    return 1;
                }
            }
            const api = this.getApiHelper();
            // Normalizing the basePath to resolve .. and .
            this.basePaths = this.basePaths.map((basePath) => upath_1.default.normalize(basePath));
            this.logger.info((0, renderer_1.renderCommandInfo)(this.basePaths, this.service, this.maxConcurrency, this.dryRun));
            const spanTags = yield this.getSpanTags();
            const customTags = this.getCustomTags();
            const customMeasures = this.getCustomMeasures();
            const reportTags = this.getReportTags();
            const reportMeasures = this.getReportMeasures();
            const payloads = yield this.getMatchingJUnitXMLFiles(spanTags, customTags, customMeasures, reportTags, reportMeasures);
            const upload = (p) => this.uploadJUnitXML(api, p);
            const initialTime = new Date().getTime();
            yield (0, concurrency_1.doWithMaxConcurrency)(this.maxConcurrency, payloads, upload);
            const totalTimeSeconds = (Date.now() - initialTime) / 1000;
            this.logger.info((0, renderer_1.renderSuccessfulUpload)(this.dryRun, payloads.length, totalTimeSeconds));
            if (!this.skipGitMetadataUpload) {
                if (yield (0, git_metadata_1.isGitRepo)()) {
                    const traceId = (0, id_1.default)();
                    const requestBuilder = (0, utils_1.getRequestBuilder)({
                        baseUrl: api_1.apiUrl,
                        apiKey: this.config.apiKey,
                        headers: new Map([
                            [TRACE_ID_HTTP_HEADER, traceId],
                            [PARENT_ID_HTTP_HEADER, traceId],
                        ]),
                    });
                    try {
                        this.logger.info(`${this.dryRun ? '[DRYRUN] ' : ''}Syncing git metadata...`);
                        let elapsed = 0;
                        if (!this.dryRun) {
                            elapsed = yield (0, utils_1.timedExecAsync)(this.uploadToGitDB.bind(this), { requestBuilder });
                        }
                        this.logger.info((0, renderer_1.renderSuccessfulGitDBSync)(this.dryRun, elapsed));
                    }
                    catch (err) {
                        this.logger.info((0, renderer_1.renderFailedGitDBSync)(err));
                    }
                }
                else {
                    this.logger.info(`${this.dryRun ? '[DRYRUN] ' : ''}Not syncing git metadata (not a git repo)`);
                }
            }
            else {
                this.logger.debug('Not syncing git metadata (skip git upload flag detected)');
            }
            if (!this.dryRun) {
                this.context.stdout.write((0, renderer_1.renderSuccessfulCommand)(spanTags, this.service, this.config.env));
            }
        });
    }
    uploadToGitDB(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, gitdb_1.uploadToGitDB)(this.logger, opts.requestBuilder, yield (0, git_1.newSimpleGit)(), this.dryRun, this.gitRepositoryURL);
        });
    }
    getApiHelper() {
        if (!this.config.apiKey) {
            this.logger.error(`Neither ${chalk_1.default.red.bold('DATADOG_API_KEY')} nor ${chalk_1.default.red.bold('DD_API_KEY')} is in your environment.`);
            throw new Error('API key is missing');
        }
        return (0, api_1.apiConstructor)(api_1.intakeUrl, this.config.apiKey);
    }
    parseXPathTags(rawXPathTags) {
        return rawXPathTags.reduce((xpathTags, rawExpression) => {
            const index = rawExpression.indexOf('=');
            if (index === -1) {
                this.context.stderr.write('Invalid xpath-tag: missing =. Value must be <tag>=<xpath-expression>\n');
                return xpathTags;
            }
            const tagName = rawExpression.substring(0, index);
            const xPath = rawExpression.substring(index + 1);
            xpathTags[tagName] = xPath;
            return xpathTags;
        }, {});
    }
    getMatchingJUnitXMLFiles(spanTags, customTags, customMeasures, reportTags, reportMeasures) {
        return __awaiter(this, void 0, void 0, function* () {
            let basePaths;
            let searchFoldersRecursively;
            let filterFile;
            if (this.automaticReportsDiscovery) {
                basePaths = this.basePaths || ['.'];
                searchFoldersRecursively = true;
                filterFile = isJunitXmlReport;
            }
            else {
                // maintaining legacy matching logic for backward compatibility
                basePaths = this.basePaths || [];
                searchFoldersRecursively = false;
                filterFile = (file) => upath_1.default.extname(file) === '.xml';
            }
            const validUniqueFiles = (0, file_finder_1.findFiles)(basePaths, searchFoldersRecursively, (0, glob_1.parsePathsList)(this.ignoredPaths), filterFile, validateXml, (filePath, errorMessage) => this.context.stdout.write((0, renderer_1.renderInvalidFile)(filePath, errorMessage)));
            return validUniqueFiles.map((jUnitXMLFilePath) => ({
                hostname: os_1.default.hostname(),
                logsEnabled: this.logs,
                xpathTags: this.xpathTags,
                spanTags,
                customTags,
                customMeasures,
                reportTags,
                reportMeasures,
                xmlPath: jUnitXMLFilePath,
            }));
        });
    }
    getSpanTags() {
        return __awaiter(this, void 0, void 0, function* () {
            const ciSpanTags = (0, ci_1.getCISpanTags)();
            const gitSpanTags = yield (0, format_git_span_data_1.getGitMetadata)();
            const userGitSpanTags = (0, user_provided_git_1.getUserGitSpanTags)();
            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, gitSpanTags), ciSpanTags), userGitSpanTags), (this.config.env ? { env: this.config.env } : {})), { service: this.service });
        });
    }
    getCustomTags() {
        const envVarTags = this.config.envVarTags ? (0, tags_1.parseTags)(this.config.envVarTags.split(',')) : {};
        const cliTags = this.tags ? (0, tags_1.parseTags)(this.tags) : {};
        return Object.assign(Object.assign({}, cliTags), envVarTags);
    }
    getCustomMeasures() {
        const envVarMetrics = this.config.envVarMetrics ? (0, tags_1.parseMetrics)(this.config.envVarMetrics.split(',')) : {};
        const envVarMeasures = this.config.envVarMeasures ? (0, tags_1.parseMetrics)(this.config.envVarMeasures.split(',')) : {};
        const cliMeasures = this.measures ? (0, tags_1.parseMetrics)(this.measures) : {};
        return Object.assign(Object.assign(Object.assign({}, cliMeasures), envVarMetrics), envVarMeasures);
    }
    getReportTags() {
        return this.reportTags ? (0, tags_1.parseTags)(this.reportTags) : {};
    }
    getReportMeasures() {
        const cliMeasures = this.reportMeasures ? (0, tags_1.parseMetrics)(this.reportMeasures) : {};
        return Object.assign({}, cliMeasures);
    }
    uploadJUnitXML(api, jUnitXML) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.dryRun) {
                this.logger.info((0, renderer_1.renderDryRunUpload)(jUnitXML));
                return;
            }
            try {
                this.logger.info((0, renderer_1.renderUpload)(jUnitXML));
                yield (0, retry_1.retryRequest)(() => api.uploadJUnitXML(jUnitXML), {
                    onRetry: (e, attempt) => {
                        this.context.stderr.write((0, renderer_1.renderRetriedUpload)(jUnitXML, e.message, attempt));
                    },
                    retries: 5,
                });
            }
            catch (error) {
                this.context.stderr.write((0, renderer_1.renderFailedUpload)(jUnitXML, error));
                if (error.response) {
                    // If it's an axios error
                    if (!errorCodesStopUpload.includes(error.response.status)) {
                        // And a status code that should not stop the whole upload, just return
                        return;
                    }
                }
                throw error;
            }
        });
    }
}
exports.UploadJUnitXMLCommand = UploadJUnitXMLCommand;
UploadJUnitXMLCommand.paths = [['junit', 'upload']];
UploadJUnitXMLCommand.usage = clipanion_1.Command.Usage({
    category: 'CI Visibility',
    description: 'Upload jUnit XML test reports files to Datadog.',
    details: `
      This command will upload to jUnit XML test reports files to Datadog.\n
      See README for details.
    `,
    examples: [
        ['Upload all jUnit XML test report files in current directory', 'datadog-ci junit upload --service my-service .'],
        [
            'Discover and upload all jUnit XML test report files doing recursive search in current directory',
            'datadog-ci junit upload --service my-service --auto-discovery .',
        ],
        [
            'Discover and upload all jUnit XML test report files doing recursive search in current directory, ignoring src/ignored-module-a and src/ignored-module-b',
            'datadog-ci junit upload --service my-service --ignored-paths src/ignored-module-a,src/ignored-module-b --auto-discovery .',
        ],
        [
            'Upload all jUnit XML test report files in src/unit-test-reports and src/acceptance-test-reports',
            'datadog-ci junit upload --service my-service src/unit-test-reports src/acceptance-test-reports',
        ],
        [
            'Upload all jUnit XML test report files in current directory and add extra tags globally',
            'datadog-ci junit upload --service my-service --tags key1:value1 --tags key2:value2 .',
        ],
        [
            'Upload all jUnit XML test report files in current directory and add extra measures globally',
            'datadog-ci junit upload --service my-service --measures key1:123 --measures key2:321 .',
        ],
        [
            'Upload all jUnit XML test report files in current directory to the datadoghq.eu site',
            'DD_SITE=datadoghq.eu datadog-ci junit upload --service my-service .',
        ],
        [
            'Upload all jUnit XML test report files in current directory while also collecting logs',
            'datadog-ci junit upload --service my-service --logs .',
        ],
        [
            'Upload all jUnit XML test report files in current directory customizing test suite with xpath',
            'datadog-ci junit upload --service my-service --xpath-tag test.suite=/testcase/@classname .',
        ],
        [
            'Upload all jUnit XML test report files in current directory adding a custom tag from property with xpath',
            "datadog-ci junit upload --service my-service --xpath-tag custom_tag=/testcase/..//property[@name='property-name'] .",
        ],
        [
            'Upload all jUnit XML test report files in current directory with extra verbosity',
            'datadog-ci junit upload --verbose --service my-service .',
        ],
    ],
});
//# sourceMappingURL=upload.js.map