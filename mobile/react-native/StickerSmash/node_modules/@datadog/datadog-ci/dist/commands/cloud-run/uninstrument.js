"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UninstrumentCommand = void 0;
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const constants_1 = require("../../constants");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const renderer_1 = require("../../helpers/renderer");
const constants_2 = require("./constants");
const prompt_1 = require("./prompt");
const renderer_2 = require("./renderer");
const utils_1 = require("./utils");
// XXX temporary workaround for @google-cloud/run ESM/CJS module issues
const { ServicesClient } = require('@google-cloud/run');
class UninstrumentCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.dryRun = clipanion_1.Option.Boolean('-d,--dry,--dry-run', false);
        this.project = clipanion_1.Option.String('-p,--project', {
            description: 'GCP project ID',
        });
        this.services = clipanion_1.Option.Array('-s,--service,--services', [], {
            description: 'Cloud Run service(s) to instrument',
        });
        this.interactive = clipanion_1.Option.Boolean('-i,--interactive', false, {
            description: 'Prompt for flags one at a time',
        });
        this.region = clipanion_1.Option.String('-r,--region', {
            description: 'GCP region your service(s) are deployed in',
        });
        this.sidecarName = clipanion_1.Option.String('--sidecar-name', constants_2.DEFAULT_SIDECAR_NAME, {
            description: `The name of the sidecar container to remove. Specify if you have a different sidecar name. Defaults to '${constants_2.DEFAULT_SIDECAR_NAME}'`,
        });
        this.sharedVolumeName = clipanion_1.Option.String('--shared-volume-name', constants_2.DEFAULT_VOLUME_NAME, {
            description: `The name of the shared volume to remove. Specify if you have a different shared volume name. Defaults to '${constants_2.DEFAULT_VOLUME_NAME}'`,
        });
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.fipsConfig = {
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.fipsConfig.fips, this.fipsIgnoreError || this.fipsConfig.fipsIgnoreError);
            this.context.stdout.write(`\n${(0, renderer_2.dryRunPrefix)(this.dryRun)}üê∂ ${chalk_1.default.bold('Uninstrumenting Cloud Run service(s)')}\n\n`);
            if (this.interactive) {
                if (!this.project) {
                    this.project = yield (0, prompt_1.requestGCPProject)();
                }
                if (!this.region) {
                    this.region = yield (0, prompt_1.requestGCPRegion)();
                }
                if (this.services.length === 0) {
                    const serviceName = yield (0, prompt_1.requestServiceName)();
                    this.services = [serviceName];
                }
            }
            // Validate required variables
            if (!this.project) {
                this.context.stdout.write(chalk_1.default.yellow('Invalid or missing project. Please use the --project flag.\n'));
            }
            if (this.services.length === 0) {
                this.context.stdout.write(chalk_1.default.yellow('Invalid or missing service(s). Please use the --service flag.\n'));
            }
            if (!this.region) {
                this.context.stdout.write(chalk_1.default.yellow('Invalid or missing region. Please use the --region flag.\n'));
            }
            if (!this.project || !this.services || !this.services.length || !this.region) {
                return 1;
            }
            this.context.stdout.write(chalk_1.default.green('‚úî Required flags verified\n'));
            // Verify GCP credentials
            this.context.stdout.write(chalk_1.default.bold('\nüîë Verifying GCP credentials...\n'));
            const authenticated = yield (0, utils_1.checkAuthentication)();
            if (!authenticated) {
                this.context.stderr.write((0, renderer_2.renderAuthenticationInstructions)());
                return 1;
            }
            this.context.stdout.write(chalk_1.default.green('‚úî GCP credentials verified!\n\n'));
            // Instrument services with sidecar
            try {
                yield this.uninstrumentSidecar(this.project, this.services, this.region);
            }
            catch (error) {
                this.context.stderr.write((0, renderer_2.dryRunPrefix)(this.dryRun) + (0, renderer_1.renderError)(`Uninstrumentation failed: ${error}\n`));
                return 1;
            }
            if (!this.dryRun) {
                this.context.stdout.write('\n‚úÖ Cloud Run uninstrumentation completed successfully!\n');
            }
            return 0;
        });
    }
    uninstrumentSidecar(project, services, region) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = new ServicesClient();
            this.context.stdout.write(chalk_1.default.bold(`\n${(0, renderer_2.dryRunPrefix)(this.dryRun)}‚¨áÔ∏è Fetching existing service configurations from Cloud Run...\n`));
            const existingServiceConfigs = yield (0, utils_1.fetchServiceConfigs)(client, project, region, services);
            this.context.stdout.write(chalk_1.default.bold(`\n${(0, renderer_2.dryRunPrefix)(this.dryRun)}üöÄ Uninstrumenting Cloud Run services with sidecar...\n`));
            for (let i = 0; i < existingServiceConfigs.length; i++) {
                const serviceConfig = existingServiceConfigs[i];
                const serviceName = services[i];
                try {
                    yield this.uninstrumentService(client, serviceConfig, serviceName);
                }
                catch (error) {
                    this.context.stderr.write((0, renderer_2.dryRunPrefix)(this.dryRun) + (0, renderer_1.renderError)(`Failed to instrument service ${serviceName}: ${error}\n`));
                    throw error;
                }
            }
        });
    }
    uninstrumentService(client, existingService, serviceName) {
        return __awaiter(this, void 0, void 0, function* () {
            const updatedService = this.createUninstrumentedServiceConfig(existingService);
            this.context.stdout.write((0, utils_1.generateConfigDiff)(existingService, updatedService));
            if (this.dryRun) {
                this.context.stdout.write(`\n\n${(0, renderer_2.dryRunPrefix)(this.dryRun)}Would have updated service ${chalk_1.default.bold(serviceName)} with the above changes.\n`);
                return;
            }
            else if (this.interactive) {
                const confirmed = yield (0, prompt_1.requestConfirmation)('\nDo you want to apply the changes?');
                if (!confirmed) {
                    throw new Error('Uninstrumentation cancelled by user.');
                }
            }
            yield (0, renderer_2.withSpinner)(`Uninstrumenting service ${chalk_1.default.bold(serviceName)}...`, () => __awaiter(this, void 0, void 0, function* () {
                const [operation] = yield client.updateService({
                    service: updatedService,
                });
                yield operation.promise();
            }), `Uninstrumented service ${chalk_1.default.bold(serviceName)}`);
        });
    }
    createUninstrumentedServiceConfig(service) {
        const template = service.template || {};
        const containers = template.containers || [];
        const volumes = template.volumes || [];
        let updatedContainers = containers.filter((c) => c.name !== this.sidecarName);
        const updatedVolumes = volumes.filter((v) => v.name !== this.sharedVolumeName);
        if (updatedContainers.length === containers.length) {
            this.context.stdout.write((0, renderer_1.renderSoftWarning)(`Sidecar container '${this.sidecarName}' not found, so no container was removed. Specify the container name with --sidecar-name.
`));
        }
        if (updatedVolumes.length === volumes.length) {
            this.context.stdout.write((0, renderer_1.renderSoftWarning)(`Shared volume '${this.sharedVolumeName}' not found, so no shared volume was removed. Specify the shared volume name with --shared-volume-name.
`));
        }
        updatedContainers = updatedContainers.map((c) => this.updateAppContainer(c));
        return Object.assign(Object.assign({}, service), { template: Object.assign(Object.assign({}, template), { containers: updatedContainers, volumes: updatedVolumes, 
                // Let GCR generate the next revision name
                revision: undefined }) });
    }
    // Remove volume mount and add required env vars
    updateAppContainer(appContainer) {
        const existingVolumeMounts = appContainer.volumeMounts || [];
        const updatedVolumeMounts = existingVolumeMounts.filter((v) => v.name !== this.sharedVolumeName);
        const existingEnvVars = appContainer.env || [];
        // Remove env vars beginning with DD_
        const updatedEnvVars = existingEnvVars.filter((v) => !v.name.startsWith('DD_'));
        return Object.assign(Object.assign({}, appContainer), { volumeMounts: updatedVolumeMounts, env: updatedEnvVars });
    }
}
exports.UninstrumentCommand = UninstrumentCommand;
UninstrumentCommand.paths = [['cloud-run', 'uninstrument']];
UninstrumentCommand.usage = clipanion_1.Command.Usage({
    category: 'Serverless',
    description: 'Revert Datadog instrumentation in a Cloud Run app.',
});
//# sourceMappingURL=uninstrument.js.map