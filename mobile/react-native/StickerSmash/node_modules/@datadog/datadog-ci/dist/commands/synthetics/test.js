"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeLocalTestDefinition = exports.getTestAndOverrideConfig = exports.getTestsToTrigger = exports.getTestsFromSearchQuery = exports.getTestConfigs = exports.DEFAULT_TEST_CONFIG_FILES_GLOB = exports.MAX_TESTS_TO_TRIGGER = void 0;
const chalk_1 = __importDefault(require("chalk"));
const api_1 = require("./api");
const errors_1 = require("./errors");
const interfaces_1 = require("./interfaces");
const mobile_1 = require("./mobile");
const internal_1 = require("./utils/internal");
const public_1 = require("./utils/public");
exports.MAX_TESTS_TO_TRIGGER = 1000;
exports.DEFAULT_TEST_CONFIG_FILES_GLOB = '{,!(node_modules)/**/}*.synthetics.json';
const getTestConfigs = (config, reporter, suites = []) => __awaiter(void 0, void 0, void 0, function* () {
    const files = [...config.files];
    // Only auto-discover with the default glob when the user **doesn't give any clue** about which tests to run.
    // If they give any clue (e.g. `publicIds`) without explicitly passing `files`,
    // they might be running the command from their home folder so we shouldn't auto-discover for performance reasons.
    if (config.publicIds.length === 0 &&
        files.length === 0 &&
        suites.length === 0 &&
        'testSearchQuery' in config &&
        !config.testSearchQuery) {
        files.push(exports.DEFAULT_TEST_CONFIG_FILES_GLOB);
    }
    const suitesFromFiles = (yield Promise.all(files.map((glob) => (0, public_1.getSuites)(glob, reporter))))
        .reduce((acc, val) => acc.concat(val), [])
        .filter((suite) => !!suite.content.tests);
    suites.push(...suitesFromFiles);
    const testConfigs = suites
        .map((suite) => suite.content.tests.map((test) => {
        var _a;
        return Object.assign({ testOverrides: test.testOverrides, suite: suite.name }, ((0, internal_1.isLocalTriggerConfig)(test)
            ? { localTestDefinition: (0, exports.normalizeLocalTestDefinition)(test.localTestDefinition) }
            : { id: (_a = (0, public_1.normalizePublicId)(test.id)) !== null && _a !== void 0 ? _a : '' }));
    }))
        .reduce((acc, suiteTests) => acc.concat(suiteTests), []);
    return testConfigs;
});
exports.getTestConfigs = getTestConfigs;
const getTestsFromSearchQuery = (api, config) => __awaiter(void 0, void 0, void 0, function* () {
    const { defaultTestOverrides, testSearchQuery } = config;
    // Empty search queries are not allowed.
    if (!testSearchQuery) {
        return [];
    }
    const testSearchResults = yield api.searchTests(testSearchQuery);
    return testSearchResults.tests.map((test) => ({
        testOverrides: defaultTestOverrides !== null && defaultTestOverrides !== void 0 ? defaultTestOverrides : {},
        id: test.public_id,
        suite: `Query: ${testSearchQuery}`,
    }));
});
exports.getTestsFromSearchQuery = getTestsFromSearchQuery;
const getTestsToTrigger = (api, triggerConfigs, reporter, triggerFromSearch, failOnMissingTests, isTunnelEnabled) => __awaiter(void 0, void 0, void 0, function* () {
    const errorMessages = [];
    // When too many tests are triggered, if fetched from a search query: simply trim them and show a warning,
    // otherwise: retrieve them and fail later if still exceeding without skipped/missing tests.
    if (triggerFromSearch && triggerConfigs.length > exports.MAX_TESTS_TO_TRIGGER) {
        const testsCount = triggerConfigs.length;
        triggerConfigs.splice(exports.MAX_TESTS_TO_TRIGGER);
        const maxTests = chalk_1.default.bold(exports.MAX_TESTS_TO_TRIGGER);
        errorMessages.push(chalk_1.default.yellow(`The search query returned ${testsCount} tests, only the first ${maxTests} will be triggered.\n`));
    }
    const initialSummary = (0, public_1.createInitialSummary)();
    const testsAndConfigsOverride = yield Promise.all(triggerConfigs.map((triggerConfig) => (0, exports.getTestAndOverrideConfig)(api, triggerConfig, reporter, initialSummary, isTunnelEnabled)));
    yield (0, mobile_1.uploadMobileApplicationsAndUpdateOverrideConfigs)(api, triggerConfigs, testsAndConfigsOverride.filter(internal_1.isMobileTestWithOverride));
    const overriddenTestsToTrigger = [];
    const waitedTests = [];
    testsAndConfigsOverride.forEach((item) => {
        if ('errorMessage' in item) {
            errorMessages.push(item.errorMessage);
        }
        if ('overriddenConfig' in item) {
            overriddenTestsToTrigger.push(item.overriddenConfig);
        }
        if ('test' in item) {
            waitedTests.push(item.test);
        }
    });
    // Display errors at the end of all tests for better visibility.
    reporter.initErrors(errorMessages);
    if (failOnMissingTests && initialSummary.testsNotFound.size > 0) {
        const testsNotFoundListStr = chalk_1.default.gray([...initialSummary.testsNotFound].join(', '));
        throw new errors_1.CiError('MISSING_TESTS', testsNotFoundListStr);
    }
    if (failOnMissingTests && initialSummary.testsNotAuthorized.size > 0) {
        const testsNotAuthorizedListStr = chalk_1.default.gray([...initialSummary.testsNotAuthorized].join(', '));
        throw new errors_1.CiError('UNAUTHORIZED_TESTS', testsNotAuthorizedListStr);
    }
    if (!overriddenTestsToTrigger.length) {
        throw new errors_1.CiError('NO_TESTS_TO_RUN');
    }
    else if (overriddenTestsToTrigger.length > exports.MAX_TESTS_TO_TRIGGER) {
        throw new errors_1.CriticalError('TOO_MANY_TESTS_TO_TRIGGER', `Cannot trigger more than ${exports.MAX_TESTS_TO_TRIGGER} tests (received ${triggerConfigs.length})`);
    }
    return { tests: waitedTests, overriddenTestsToTrigger, initialSummary };
});
exports.getTestsToTrigger = getTestsToTrigger;
const getTestAndOverrideConfig = (api, triggerConfig, reporter, summary, isTunnelEnabled) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c;
    const publicIdOrPlaceholder = (0, internal_1.getPublicIdOrPlaceholder)({ public_id: (0, internal_1.getTriggerConfigPublicId)(triggerConfig) });
    const normalizedId = (0, public_1.normalizePublicId)(publicIdOrPlaceholder);
    if (!normalizedId) {
        throw new errors_1.CriticalError('INVALID_CONFIG', `No valid public ID found in: \`${publicIdOrPlaceholder}\``);
    }
    const testResult = yield getTest(api, triggerConfig);
    if ('errorMessage' in testResult) {
        if (testResult.errorMessage.includes('Test not found')) {
            summary.testsNotFound.add(normalizedId);
        }
        else if (testResult.errorMessage.includes('Test not authorized')) {
            summary.testsNotAuthorized.add(normalizedId);
        }
        return { errorMessage: testResult.errorMessage };
    }
    const { test } = testResult;
    const overriddenConfig = (0, public_1.makeTestPayload)(test, triggerConfig, normalizedId);
    const testExecutionRule = (_b = (_a = test === null || test === void 0 ? void 0 : test.options) === null || _a === void 0 ? void 0 : _a.ci) === null || _b === void 0 ? void 0 : _b.executionRule;
    const executionRule = overriddenConfig.executionRule || testExecutionRule || interfaces_1.ExecutionRule.BLOCKING;
    reporter.testTrigger(test, normalizedId, executionRule, (_c = triggerConfig.testOverrides) !== null && _c !== void 0 ? _c : {});
    if (executionRule === interfaces_1.ExecutionRule.SKIPPED) {
        summary.skipped++;
        return { overriddenConfig };
    }
    reporter.testWait(test);
    if (isTunnelEnabled && !(0, public_1.isTestSupportedByTunnel)(test)) {
        const details = [`public ID: ${normalizedId}`, `type: ${test.type}`];
        if (test.subtype) {
            details.push(`sub-type: ${test.subtype}`);
        }
        if (test.subtype === 'multi') {
            const unsupportedStepSubTypes = (test.config.steps || [])
                .filter((step) => step.subtype !== 'http')
                .map(({ subtype }) => subtype);
            details.push(`step sub-types: [${unsupportedStepSubTypes.join(', ')}]`);
        }
        throw new errors_1.CriticalError('TUNNEL_NOT_SUPPORTED', `The tunnel is only supported with HTTP API tests and Browser tests (${details.join(', ')}).`);
    }
    return { test, overriddenConfig };
});
exports.getTestAndOverrideConfig = getTestAndOverrideConfig;
const getTest = (api, triggerConfig) => __awaiter(void 0, void 0, void 0, function* () {
    var _d;
    if ((0, internal_1.isLocalTriggerConfig)(triggerConfig)) {
        const test = Object.assign(Object.assign({}, triggerConfig.localTestDefinition), { suite: triggerConfig.suite });
        return { test };
    }
    const { id: publicId, suite } = triggerConfig;
    try {
        const test = Object.assign(Object.assign({}, (yield api.getTest(publicId))), { suite });
        return { test };
    }
    catch (error) {
        if ((0, api_1.isNotFoundError)(error)) {
            const errorMessage = (0, api_1.formatBackendErrors)(error);
            return { errorMessage: `[${chalk_1.default.bold.dim(publicId)}] ${chalk_1.default.yellow.bold('Test not found')}: ${errorMessage}` };
        }
        if ((0, api_1.isForbiddenError)(error)) {
            const errorMessage = (0, api_1.formatBackendErrors)(error);
            return { errorMessage: `[${chalk_1.default.bold.dim(publicId)}] ${chalk_1.default.red.bold('Test not authorized')}: ${errorMessage}` };
        }
        throw new api_1.EndpointError(`Failed to get test: ${(0, api_1.formatBackendErrors)(error)}\n`, (_d = error.response) === null || _d === void 0 ? void 0 : _d.status);
    }
});
const normalizeLocalTestDefinition = (localTestDefinition) => {
    // Support links here too for QoL and consistency with `RemoteTriggerConfig.id`
    const publicId = localTestDefinition.public_id && (0, public_1.normalizePublicId)(localTestDefinition.public_id);
    return Object.assign(Object.assign({}, localTestDefinition), { public_id: publicId });
};
exports.normalizeLocalTestDefinition = normalizeLocalTestDefinition;
//# sourceMappingURL=test.js.map