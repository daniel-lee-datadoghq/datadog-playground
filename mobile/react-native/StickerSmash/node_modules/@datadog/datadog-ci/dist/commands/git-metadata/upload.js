"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UploadCommand = void 0;
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const constants_1 = require("../../constants");
const apikey_1 = require("../../helpers/apikey");
const env_1 = require("../../helpers/env");
const errors_1 = require("../../helpers/errors");
const fips_1 = require("../../helpers/fips");
const formatting_1 = require("../../helpers/formatting");
const logger_1 = require("../../helpers/logger");
const metrics_1 = require("../../helpers/metrics");
const upload_1 = require("../../helpers/upload");
const utils_1 = require("../../helpers/utils");
const version_1 = require("../../helpers/version");
const api_1 = require("./api");
const git_1 = require("./git");
const gitdb_1 = require("./gitdb");
const library_1 = require("./library");
const renderer_1 = require("./renderer");
class UploadCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b, _c;
        super(...arguments);
        this.repositoryURL = clipanion_1.Option.String('--repository-url');
        this.dryRun = clipanion_1.Option.Boolean('--dry-run', false);
        this.verbose = clipanion_1.Option.Boolean('--verbose', false);
        this.noGitSync = clipanion_1.Option.Boolean('--no-gitsync', false);
        this.directory = clipanion_1.Option.String('--directory', '');
        this.cliVersion = version_1.version;
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.config = {
            apiKey: (_a = process.env.DATADOG_API_KEY) !== null && _a !== void 0 ? _a : process.env.DD_API_KEY,
            fips: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
            fipsIgnoreError: (_c = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _c !== void 0 ? _c : false,
        };
        this.logger = new logger_1.Logger((s) => {
            this.context.stdout.write(s);
        }, logger_1.LogLevel.INFO);
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            const initialTime = Date.now();
            (0, fips_1.enableFips)(this.fips || this.config.fips, this.fipsIgnoreError || this.config.fipsIgnoreError);
            if (this.verbose) {
                this.logger = new logger_1.Logger((s) => {
                    this.context.stdout.write(s);
                }, logger_1.LogLevel.DEBUG);
            }
            if (this.dryRun) {
                this.logger.warn((0, renderer_1.renderDryRunWarning)());
            }
            if (this.directory) {
                // change working dir
                process.chdir(this.directory);
            }
            if (!this.config.apiKey) {
                this.logger.error((0, renderer_1.renderConfigurationError)(new errors_1.InvalidConfigurationError(`Missing ${chalk_1.default.bold('DD_API_KEY')} in your environment`)));
                return 1;
            }
            const metricsLogger = (0, metrics_1.getMetricsLogger)({
                apiKey: this.config.apiKey,
                datadogSite: api_1.datadogSite,
                defaultTags: [`cli_version:${this.cliVersion}`],
                prefix: 'datadog.ci.report_commits.',
            });
            const apiKeyValidator = (0, apikey_1.newApiKeyValidator)({
                apiKey: this.config.apiKey,
                datadogSite: api_1.datadogSite,
                metricsLogger: metricsLogger.logger,
            });
            const apiRequestBuilder = this.getApiRequestBuilder(this.config.apiKey);
            const srcmapRequestBuilder = this.getSrcmapRequestBuilder(this.config.apiKey);
            let inError = false;
            try {
                this.logger.info('Uploading list of tracked files...');
                const elapsed = yield (0, utils_1.timedExecAsync)(this.uploadToSrcmapTrack.bind(this), {
                    requestBuilder: srcmapRequestBuilder,
                    apiKeyValidator,
                    metricsLogger,
                });
                metricsLogger.logger.increment('sci.success', 1);
                this.logger.info(`${this.dryRun ? '[DRYRUN] ' : ''}Successfully uploaded tracked files in ${elapsed} seconds.`);
            }
            catch (err) {
                this.logger.error(`Failed upload of tracked files: ${err}`);
                inError = true;
            }
            if (!this.noGitSync) {
                try {
                    this.logger.info('Syncing GitDB...');
                    const elapsed = yield (0, utils_1.timedExecAsync)(this.uploadToGitDB.bind(this), {
                        requestBuilder: apiRequestBuilder,
                    });
                    metricsLogger.logger.increment('gitdb.success', 1);
                    this.logger.info(`${this.dryRun ? '[DRYRUN] ' : ''}Successfully synced git DB in ${elapsed} seconds.`);
                }
                catch (err) {
                    this.logger.warn(`Could not write to GitDB: ${err}`);
                }
            }
            try {
                yield metricsLogger.flush();
            }
            catch (err) {
                this.logger.warn(`WARN: ${err}`);
            }
            if (inError) {
                this.logger.error('Command failed. See messages above for more details.');
                return 1;
            }
            this.logger.info((0, renderer_1.renderSuccessfulCommand)((Date.now() - initialTime) / 1000, this.dryRun));
            return 0;
        });
    }
    uploadToGitDB(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, gitdb_1.uploadToGitDB)(this.logger, opts.requestBuilder, yield (0, git_1.newSimpleGit)(), this.dryRun, this.repositoryURL);
        });
    }
    uploadToSrcmapTrack(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const generatePayload = () => __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield (0, git_1.getCommitInfo)(yield (0, git_1.newSimpleGit)(), this.repositoryURL);
                }
                catch (e) {
                    if (e instanceof Error) {
                        this.logger.error((0, renderer_1.renderFailedUpload)(e.message));
                    }
                    throw e;
                }
            });
            const sendPayload = (commit) => __awaiter(this, void 0, void 0, function* () {
                let status;
                if (this.dryRun) {
                    status = upload_1.UploadStatus.Success;
                }
                else {
                    status = yield (0, library_1.uploadRepository)(opts.requestBuilder, this.cliVersion)(commit, {
                        apiKeyValidator: opts.apiKeyValidator,
                        onError: (e) => {
                            this.logger.error((0, renderer_1.renderFailedUpload)(e.message));
                            opts.metricsLogger.logger.increment('sci.failed', 1);
                        },
                        onRetry: (e, attempt) => {
                            this.logger.warn((0, renderer_1.renderRetriedUpload)(e.message, attempt));
                            opts.metricsLogger.logger.increment('sci.retries', 1);
                        },
                        onUpload: () => {
                            return;
                        },
                        retries: 5,
                    });
                }
                if (status !== upload_1.UploadStatus.Success) {
                    this.logger.error(`${formatting_1.ICONS.FAILED} Error uploading commit information.`);
                    throw new Error('Could not upload commit information');
                }
            });
            const payload = yield generatePayload();
            this.logger.info((0, renderer_1.renderCommandInfo)(payload));
            yield sendPayload(payload);
        });
    }
    getSrcmapRequestBuilder(apiKey) {
        return (0, utils_1.getRequestBuilder)({
            apiKey,
            baseUrl: (0, api_1.getBaseIntakeUrl)(),
            headers: new Map([
                ['DD-EVP-ORIGIN', 'datadog-ci_git-metadata'],
                ['DD-EVP-ORIGIN-VERSION', this.cliVersion],
            ]),
            overrideUrl: 'api/v2/srcmap',
        });
    }
    getApiRequestBuilder(apiKey) {
        return (0, utils_1.getRequestBuilder)({
            apiKey,
            baseUrl: 'https://' + api_1.apiHost,
        });
    }
}
exports.UploadCommand = UploadCommand;
UploadCommand.paths = [['git-metadata', 'upload']];
UploadCommand.usage = clipanion_1.Command.Usage({
    category: 'Source Code Integration',
    description: 'Report the current commit details to Datadog.',
    details: `
      This command will upload the commit details to Datadog in order to create links to your repositories inside Datadog's UI.\n
      See README for details.
    `,
    examples: [['Upload the current commit details', 'datadog-ci report-commits upload']],
});
//# sourceMappingURL=upload.js.map