"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UploadCommand = void 0;
const fs_1 = __importDefault(require("fs"));
const clipanion_1 = require("clipanion");
const upath_1 = __importDefault(require("upath"));
const constants_1 = require("../../constants");
const apikey_1 = require("../../helpers/apikey");
const concurrency_1 = require("../../helpers/concurrency");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const format_git_sourcemaps_data_1 = require("../../helpers/git/format-git-sourcemaps-data");
const glob_1 = require("../../helpers/glob");
const metrics_1 = require("../../helpers/metrics");
const upload_1 = require("../../helpers/upload");
const utils_1 = require("../../helpers/utils");
const validation = __importStar(require("../../helpers/validation"));
const validation_1 = require("../../helpers/validation");
const version_1 = require("../../helpers/version");
const dsyms = __importStar(require("../dsyms/upload"));
const utils_2 = require("../dsyms/utils");
const elf = __importStar(require("../elf-symbols/elf"));
const helpers_1 = require("./helpers");
const interfaces_1 = require("./interfaces");
const renderer_1 = require("./renderer");
class UploadCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.disableGit = clipanion_1.Option.Boolean('--disable-git', false);
        this.dryRun = clipanion_1.Option.Boolean('--dry-run', false);
        this.configPath = clipanion_1.Option.String('--config');
        this.maxConcurrency = clipanion_1.Option.String('--max-concurrency', '20', { validator: validation.isInteger() });
        this.repositoryUrl = clipanion_1.Option.String('--repository-url');
        this.symbolsLocation = clipanion_1.Option.String('--symbols-location', undefined);
        this.android = clipanion_1.Option.Boolean('--android', false);
        this.ios = clipanion_1.Option.Boolean('--ios', false);
        this.skipIl2Cpp = clipanion_1.Option.Boolean('--skip-il2cpp', false);
        this.cliVersion = version_1.version;
        this.config = {
            datadogSite: 'datadoghq.com',
        };
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.fipsConfig = {
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.fipsConfig.fips, this.fipsIgnoreError || this.fipsConfig.fipsIgnoreError);
            if (!(yield this.verifyParameters())) {
                return 1;
            }
            const initialTime = Date.now();
            this.context.stdout.write((0, renderer_1.renderCommandInfo)(this.dryRun, this.buildId, this.symbolsLocation));
            this.config = yield (0, utils_1.resolveConfigFromFileAndEnvironment)(this.config, {
                apiKey: process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
                datadogSite: process.env.DATADOG_SITE || process.env.DD_SITE,
            }, {
                configPath: this.configPath,
                defaultConfigPaths: utils_1.DEFAULT_CONFIG_PATHS,
                configFromFileCallback: (configFromFile) => {
                    (0, validation_1.checkAPIKeyOverride)(process.env.DATADOG_API_KEY || process.env.DD_API_KEY, configFromFile.apiKey, this.context.stdout);
                },
            });
            if (!this.disableGit) {
                this.gitData = yield this.getGitMetadata();
            }
            const callResults = [];
            try {
                if (this.ios) {
                    callResults.push(yield this.performDsymUpload());
                }
                else if (this.android) {
                    callResults.push(...(yield this.performSoUpload()));
                }
                if (!this.skipIl2Cpp) {
                    callResults.push(yield this.performIl2CppMappingUpload());
                }
                const totalTime = (Date.now() - initialTime) / 1000;
                this.context.stdout.write((0, renderer_1.renderCommandSummary)(callResults, totalTime, this.dryRun));
            }
            catch (e) {
                this.context.stderr.write((0, renderer_1.renderGeneralizedError)(e));
                return 1;
            }
            return 0;
        });
    }
    getApiKeyValidator(metricsLogger) {
        return (0, apikey_1.newApiKeyValidator)({
            apiKey: this.config.apiKey,
            datadogSite: this.config.datadogSite,
            metricsLogger: metricsLogger.logger,
        });
    }
    getGitDataPayload(gitData) {
        const files = gitData.trackedFilesMatcher.rawTrackedFilesList();
        const repoPayload = {
            data: [
                {
                    files,
                    hash: gitData.hash,
                    repository_url: gitData.remote,
                },
            ],
            version: 1,
        };
        return {
            type: 'string',
            options: { filename: 'repository', contentType: 'application/json' },
            value: JSON.stringify(repoPayload),
        };
    }
    getGitMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield (0, format_git_sourcemaps_data_1.getRepositoryData)(yield (0, format_git_sourcemaps_data_1.newSimpleGit)(), this.repositoryUrl);
            }
            catch (e) {
                this.context.stdout.write((0, renderer_1.renderGitWarning)(e));
            }
            return undefined;
        });
    }
    getMappingMetadata(type, arch) {
        var _a, _b;
        return {
            arch,
            cli_version: this.cliVersion,
            git_commit_sha: (_a = this.gitData) === null || _a === void 0 ? void 0 : _a.hash,
            git_repository_url: (_b = this.gitData) === null || _b === void 0 ? void 0 : _b.remote,
            build_id: this.buildId,
            type,
        };
    }
    getMetricsLogger(tags) {
        const metricsLogger = (0, metrics_1.getMetricsLogger)({
            apiKey: this.config.apiKey,
            datadogSite: this.config.datadogSite,
            defaultTags: [`cli_version:${this.cliVersion}`, 'platform:unity', ...tags],
            prefix: 'datadog.ci.symbols.upload.',
        });
        return metricsLogger;
    }
    performDsymUpload() {
        return __awaiter(this, void 0, void 0, function* () {
            const dsymUploadCommand = ['dsyms', 'upload', this.symbolsLocation];
            dsymUploadCommand.push('--max-concurrency');
            dsymUploadCommand.push(`${this.maxConcurrency}`);
            if (this.dryRun) {
                dsymUploadCommand.push('--dry-run');
            }
            const exitCode = yield (0, utils_1.performSubCommand)(dsyms.UploadCommand, dsymUploadCommand, this.context);
            if (exitCode && exitCode !== 0) {
                return upload_1.UploadStatus.Failure;
            }
            return upload_1.UploadStatus.Success;
        });
    }
    getBuildId() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const buildIdPath = upath_1.default.join(this.symbolsLocation, 'build_id');
            if (!fs_1.default.existsSync(buildIdPath)) {
                this.context.stderr.write((0, renderer_1.renderMissingBuildId)(buildIdPath));
                return 1;
            }
            this.buildId = (_a = fs_1.default.readFileSync(buildIdPath)) === null || _a === void 0 ? void 0 : _a.toString();
            if (!this.buildId) {
                this.context.stderr.write((0, renderer_1.renderMissingBuildId)(buildIdPath));
                return 1;
            }
            return 0;
        });
    }
    performSoUpload() {
        return __awaiter(this, void 0, void 0, function* () {
            const metricsLogger = this.getMetricsLogger(['platform:unity']);
            const apiKeyValidator = this.getApiKeyValidator(metricsLogger);
            const soFiles = (0, glob_1.globSync)((0, utils_1.buildPath)(this.symbolsLocation, '**/*.so'));
            this.context.stdout.write(`${soFiles}`);
            const tmpDirectory = yield (0, utils_2.createUniqueTmpDirectory)();
            const requestBuilder = (0, helpers_1.getUnityRequestBuilder)(this.config.apiKey, this.cliVersion, this.config.datadogSite);
            try {
                const results = yield (0, concurrency_1.doWithMaxConcurrency)(this.maxConcurrency, soFiles, (soFileName) => __awaiter(this, void 0, void 0, function* () {
                    const elfMetadata = yield elf.getElfFileMetadata(soFileName);
                    if (this.dryRun) {
                        this.context.stdout.write(`[DRYRUN] ${(0, renderer_1.renderUpload)(`Symbol File (${elfMetadata.arch})`, soFileName)}`);
                        return upload_1.UploadStatus.Success;
                    }
                    const tempDir = (0, utils_1.buildPath)(tmpDirectory, elfMetadata.arch);
                    const tempFilePath = (0, utils_1.buildPath)(tempDir, upath_1.default.basename(soFileName));
                    if (!fs_1.default.existsSync(tempDir)) {
                        fs_1.default.mkdirSync(tempDir);
                    }
                    yield elf.copyElfDebugInfo(soFileName, tempFilePath, elfMetadata, true);
                    const metadata = this.getMappingMetadata(interfaces_1.TYPE_NDK_SYMBOL_FILE, elfMetadata.arch);
                    const baseFilename = upath_1.default.basename(soFileName);
                    this.context.stdout.write(`[] ${tempFilePath}\n`);
                    const payload = {
                        content: new Map([
                            [
                                'event',
                                {
                                    type: 'string',
                                    value: JSON.stringify(metadata),
                                    options: { filename: 'event', contentType: 'application/json' },
                                },
                            ],
                            [interfaces_1.VALUE_NAME_NDK_SYMBOL_FILE, { type: 'file', path: tempFilePath, options: { filename: baseFilename } }],
                        ]),
                    };
                    if (this.gitData !== undefined) {
                        payload.content.set('repository', this.getGitDataPayload(this.gitData));
                    }
                    return (0, helpers_1.uploadMultipartHelper)(requestBuilder, payload, {
                        apiKeyValidator,
                        onError: (e) => {
                            this.context.stdout.write((0, renderer_1.renderFailedUpload)(soFileName, e.message));
                            metricsLogger.logger.increment('failed', 1);
                        },
                        onRetry: (e, attempts) => {
                            this.context.stdout.write((0, renderer_1.renderRetriedUpload)(soFileName, e.message, attempts));
                            metricsLogger.logger.increment('retries', 1);
                        },
                        onUpload: () => {
                            this.context.stdout.write((0, renderer_1.renderUpload)(`Symbol File (${elfMetadata.arch})`, soFileName));
                        },
                        retries: 5,
                        useGzip: true,
                    });
                }));
                return results;
            }
            catch (error) {
                this.context.stdout.write(`ERROR: ${error}`);
            }
            finally {
                try {
                    yield metricsLogger.flush();
                }
                catch (err) {
                    this.context.stdout.write(`WARN: ${err}\n`);
                }
            }
            return [];
        });
    }
    performIl2CppMappingUpload() {
        return __awaiter(this, void 0, void 0, function* () {
            const il2cppMappingPath = upath_1.default.join(this.symbolsLocation, 'LineNumberMappings.json');
            if (!fs_1.default.existsSync(il2cppMappingPath)) {
                this.context.stderr.write((0, renderer_1.renderMissingIL2CPPMappingFile)(il2cppMappingPath));
                return 1;
            }
            const metricsLogger = this.getMetricsLogger(['platform:unity']);
            const apiKeyValidator = this.getApiKeyValidator(metricsLogger);
            const requestBuilder = (0, helpers_1.getUnityRequestBuilder)(this.config.apiKey, this.cliVersion, this.config.datadogSite);
            if (this.dryRun) {
                this.context.stdout.write(`[DRYRUN] ${(0, renderer_1.renderUpload)('IL2CPP Mapping File', il2cppMappingPath)}`);
                return upload_1.UploadStatus.Skipped;
            }
            const metadata = this.getMappingMetadata(interfaces_1.TYPE_IL2CPP_MAPPING);
            const payload = {
                content: new Map([
                    [
                        'event',
                        {
                            type: 'string',
                            value: JSON.stringify(metadata),
                            options: { filename: 'event', contentType: 'application/json' },
                        },
                    ],
                    [
                        interfaces_1.VALUE_NAME_IL2CPP_MAPPING,
                        { type: 'file', path: il2cppMappingPath, options: { filename: interfaces_1.IL2CPP_MAPPING_FILE_NAME } },
                    ],
                ]),
            };
            if (this.gitData !== undefined) {
                payload.content.set('repository', this.getGitDataPayload(this.gitData));
            }
            const status = yield (0, helpers_1.uploadMultipartHelper)(requestBuilder, payload, {
                apiKeyValidator,
                onError: (e) => {
                    this.context.stdout.write((0, renderer_1.renderFailedUpload)(il2cppMappingPath, e.message));
                    metricsLogger.logger.increment('failed', 1);
                },
                onRetry: (e, attempts) => {
                    this.context.stdout.write((0, renderer_1.renderRetriedUpload)(il2cppMappingPath, e.message, attempts));
                    metricsLogger.logger.increment('retries', 1);
                },
                onUpload: () => {
                    this.context.stdout.write((0, renderer_1.renderUpload)('IL2CPP Mapping File', il2cppMappingPath));
                },
                retries: 5,
                useGzip: true,
            });
            if (status === upload_1.UploadStatus.Success) {
                this.context.stdout.write('IL2CPP Mapping upload finished\n');
            }
            else {
                this.context.stdout.write(`IL2CPP Mapping upload failed\n`);
            }
            return status;
        });
    }
    verifyParameters() {
        return __awaiter(this, void 0, void 0, function* () {
            let parametersOkay = true;
            if (!this.ios && !this.android) {
                this.context.stderr.write((0, renderer_1.renderMustSupplyPlatform)());
                return false;
            }
            if (this.ios && this.android) {
                this.context.stderr.write((0, renderer_1.renderUseOnlyOnePlatform)());
                return false;
            }
            if (this.symbolsLocation === undefined) {
                if (this.ios) {
                    this.symbolsLocation = './datadogSymbols';
                }
                else if (this.android) {
                    this.symbolsLocation = './unityLibrary/symbols';
                }
            }
            if (!this.symbolsLocation) {
                this.context.stderr.write((0, renderer_1.renderArgumentMissingError)('symbols-location'));
                parametersOkay = false;
            }
            else if (!fs_1.default.existsSync(this.symbolsLocation)) {
                this.context.stderr.write((0, renderer_1.renderMissingDir)(this.symbolsLocation));
                return false;
            }
            if (yield this.getBuildId()) {
                parametersOkay = false;
            }
            return parametersOkay;
        });
    }
}
exports.UploadCommand = UploadCommand;
UploadCommand.paths = [['unity-symbols', 'upload']];
UploadCommand.usage = clipanion_1.Command.Usage({
    category: 'RUM',
    description: 'Upload Unity symbol files to Datadog.',
    details: `
            This command will upload all iOS symbol files for Unity applications in order to symbolicate errors and
            crash reports received by Datadog. This includes uploading dSYMs and IL2CPP mapping files.
        `,
    examples: [['Upload all symbol files from the default location', 'datadog-ci unity-symbols upload']],
});
//# sourceMappingURL=upload.js.map