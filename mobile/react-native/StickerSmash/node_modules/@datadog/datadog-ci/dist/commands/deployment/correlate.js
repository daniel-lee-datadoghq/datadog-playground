"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeploymentCorrelateCommand = void 0;
const axios_1 = require("axios");
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const simple_git_1 = __importDefault(require("simple-git"));
const constants_1 = require("../../constants");
const ci_1 = require("../../helpers/ci");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const get_git_data_1 = require("../../helpers/git/get-git-data");
const logger_1 = require("../../helpers/logger");
const retry_1 = require("../../helpers/retry");
const tags_1 = require("../../helpers/tags");
const utils_1 = require("../../helpers/utils");
/**
 * This command collects environment variables and git information to correlate commits from the
 * source code repository to the configuration repository. This allows to connect pipelines triggering
 * changes on the configuration repository to deployments from gitOps CD providers
 */
class DeploymentCorrelateCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.cdProviderParam = clipanion_1.Option.String('--provider');
        this.configurationRepo = clipanion_1.Option.String('--config-repo');
        this.configurationShas = clipanion_1.Option.Array('--config-shas');
        this.dryRun = clipanion_1.Option.Boolean('--dry-run', false);
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.config = {
            apiKey: process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
        this.logger = new logger_1.Logger((s) => this.context.stdout.write(s), logger_1.LogLevel.INFO);
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.config.fips, this.fipsIgnoreError || this.config.fipsIgnoreError);
            if (!this.config.apiKey) {
                this.logger.error(`Neither ${chalk_1.default.red.bold('DATADOG_API_KEY')} nor ${chalk_1.default.red.bold('DD_API_KEY')} is in your environment.`);
                return 1;
            }
            if (!this.cdProviderParam) {
                this.logger.error('Missing CD provider. It must be provided with --provider');
                return 1;
            }
            this.cdProviderParam = this.cdProviderParam.toLowerCase();
            const tags = (0, ci_1.getCISpanTags)() || {};
            if (!this.validateTags(tags)) {
                return 1;
            }
            let envVars = {};
            if (tags[tags_1.CI_ENV_VARS]) {
                envVars = JSON.parse(tags[tags_1.CI_ENV_VARS]);
                delete tags[tags_1.CI_ENV_VARS];
            }
            const ciEnv = Object.assign(Object.assign({}, tags), envVars);
            const git = (0, simple_git_1.default)({
                baseDir: process.cwd(),
                binary: 'git',
                maxConcurrentProcesses: 2, // max 2 git commands at the same time
            });
            if (!this.configurationRepo) {
                this.configurationRepo = yield (0, get_git_data_1.gitRepositoryURL)(git);
            }
            if (this.configurationRepo === undefined || this.configurationRepo === '') {
                this.logger.error('Could not retrieve repository URL, check out a repository or provide it with --config-repo');
                return 1;
            }
            if (!this.configurationShas) {
                this.logger.info('Retrieving local git commits');
                const currentBranch = yield (0, get_git_data_1.gitCurrentBranch)(git);
                if (!currentBranch) {
                    this.logger.error('Could not get current branch');
                    return 1;
                }
                this.configurationShas = yield (0, get_git_data_1.gitLocalCommitShas)(git, currentBranch);
            }
            if (this.configurationShas.length === 0) {
                this.logger.error('Could not retrieve commit SHAs, commit changes and then call this command or provide them with --config-shas');
                return 1;
            }
            yield this.sendCorrelationData(ciEnv[tags_1.CI_PROVIDER_NAME], ciEnv, this.config.apiKey);
        });
    }
    sendCorrelationData(ciProvider, ciEnv, apiKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const correlateEvent = {
                type: 'ci_app_deployment_correlate',
                attributes: {
                    ci_provider: ciProvider,
                    cd_provider: this.cdProviderParam,
                    config_repo_url: this.configurationRepo,
                    config_commit_shas: this.configurationShas,
                    ci_env: ciEnv,
                },
            };
            if (this.dryRun) {
                this.logger.info(`[DRYRUN] Sending correlation event\n data: ` + JSON.stringify(correlateEvent, undefined, 2));
                return;
            }
            const site = process.env.DATADOG_SITE || process.env.DD_SITE || 'datadoghq.com';
            const baseAPIURL = `https://${(0, utils_1.getApiHostForSite)(site)}`;
            const request = (0, utils_1.getRequestBuilder)({ baseUrl: baseAPIURL, apiKey });
            const doRequest = () => request({
                data: {
                    data: correlateEvent,
                },
                method: 'post',
                url: '/api/v2/ci/deployments/correlate',
            });
            try {
                yield (0, retry_1.retryRequest)(doRequest, {
                    maxTimeout: 30000,
                    minTimeout: 5000,
                    onRetry: (e, attempt) => {
                        this.logger.warn(`[attempt ${attempt}] Could not send deployment correlation data. Retrying...: ${e.message}\n`);
                    },
                    retries: 5,
                });
            }
            catch (error) {
                // TODO: use `coerceError()`
                this.handleError(error);
            }
        });
    }
    validateTags(tags) {
        if (!tags[tags_1.GIT_REPOSITORY_URL]) {
            this.logger.error('Could not extract the source code repository URL from the CI environment variables');
            return false;
        }
        if (!tags[tags_1.GIT_SHA]) {
            this.logger.error('Could not extract the commit SHA from the CI environment variables');
            return false;
        }
        return true;
    }
    handleError(error) {
        var _a, _b;
        this.context.stderr.write(`${chalk_1.default.red.bold('[ERROR]')} Could not send deployment correlation data: ${(0, axios_1.isAxiosError)(error)
            ? JSON.stringify({
                status: (_a = error.response) === null || _a === void 0 ? void 0 : _a.status,
                response: (_b = error.response) === null || _b === void 0 ? void 0 : _b.data,
            }, undefined, 2)
            : error.message}\n`);
    }
}
exports.DeploymentCorrelateCommand = DeploymentCorrelateCommand;
DeploymentCorrelateCommand.paths = [['deployment', 'correlate']];
DeploymentCorrelateCommand.usage = clipanion_1.Command.Usage({
    category: 'CI Visibility',
    description: 'Correlate GitOps CD deployments with CI pipelines.',
    details: `
      This command will correlate the pipeline with a GitOps CD deployment.\n
      See README for additional details.
    `,
    examples: [
        ['Correlate an Argo CD deployment', 'datadog-ci deployment correlate --provider argocd'],
        [
            'Correlate ArgoCD deployment manually',
            'datadog-ci deployment correlate --provider argocd --config-repo https://github.com/my-manifests-repo --config-shas 92eb0db6926aaf51b9fb223895b6d8d1c0ff1ff4',
        ],
        [
            'Correlate ArgoCD deployment manually to several commits',
            'datadog-ci deployment correlate --provider argocd --config-repo https://github.com/my-manifests-repo --config-shas 92eb0db6926aaf51b9fb223895b6d8d1c0ff1ff4 --config-shas e996e5c30ba1cb4dc7f634ab4a0a59473741c4de',
        ],
    ],
});
//# sourceMappingURL=correlate.js.map