"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TagCommand = void 0;
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const constants_1 = require("../../constants");
const ci_1 = require("../../helpers/ci");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const retry_1 = require("../../helpers/retry");
const tags_1 = require("../../helpers/tags");
const utils_1 = require("../../helpers/utils");
class TagCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.level = clipanion_1.Option.String('--level');
        this.noFail = clipanion_1.Option.Boolean('--no-fail');
        this.silent = clipanion_1.Option.Boolean('--silent');
        this.tags = clipanion_1.Option.Array('--tags');
        this.tagsFile = clipanion_1.Option.String('--tags-file');
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.config = {
            apiKey: process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
            envVarTags: process.env.DD_TAGS,
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
    }
    setLevel(level) {
        this.level = level;
    }
    setTags(tags) {
        this.tags = tags;
        // When this command is used by another command (e.g. `deployment mark`), the command options are not resolved
        // and are still Clipanion option constructors: `this.tagsFile` is not a valid path.
        delete this.tagsFile;
    }
    setNoFail(noFail) {
        this.noFail = noFail;
    }
    setSilent(silent) {
        this.silent = silent;
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.config.fips, this.fipsIgnoreError || this.config.fipsIgnoreError);
            if (this.level !== 'pipeline' && this.level !== 'job') {
                this.context.stderr.write(`${chalk_1.default.red.bold('[ERROR]')} Level must be one of [pipeline, job]\n`);
                return 1;
            }
            if (this.silent) {
                this.context.stdout.write = () => {
                    return true;
                };
                this.context.stderr.write = () => {
                    return true;
                };
            }
            const [tagsFromFile, valid] = (0, tags_1.parseTagsFile)(this.context, this.tagsFile);
            if (!valid) {
                // we should fail if attempted to read tags from a file and failed
                return 1;
            }
            const tags = Object.assign(Object.assign(Object.assign({}, (this.config.envVarTags ? (0, tags_1.parseTags)(this.config.envVarTags.split(',')) : {})), (this.tags ? (0, tags_1.parseTags)(this.tags) : {})), tagsFromFile);
            if (Object.keys(tags).length === 0) {
                this.context.stderr.write(`${chalk_1.default.red.bold('[ERROR]')} DD_TAGS environment variable, --tags or --tags-file command line argument is required\n`);
                return 1;
            }
            try {
                const { provider, ciEnv } = (0, ci_1.getCIEnv)();
                const exitStatus = yield this.sendTags(ciEnv, this.level === 'pipeline' ? 0 : 1, provider, tags);
                if (exitStatus !== 0 && this.noFail) {
                    this.context.stderr.write(`${chalk_1.default.yellow.bold('[WARNING]')} sending tags failed but continuing due to --no-fail\n`);
                    return 0;
                }
                else if (exitStatus === 0) {
                    this.context.stdout.write('Tags sent\n');
                }
                return exitStatus;
            }
            catch (error) {
                this.context.stderr.write(`${chalk_1.default.red.bold('[ERROR]')} ${error.message}\n`);
                return 1;
            }
        });
    }
    sendTags(ciEnv, level, provider, tags) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.config.apiKey) {
                this.context.stdout.write(`Neither ${chalk_1.default.red.bold('DATADOG_API_KEY')} nor ${chalk_1.default.red.bold('DD_API_KEY')} is in your environment.\n`);
                throw new Error('API key is missing');
            }
            const site = process.env.DATADOG_SITE || process.env.DD_SITE || 'datadoghq.com';
            const baseAPIURL = `https://${(0, utils_1.getApiHostForSite)(site)}`;
            const request = (0, utils_1.getRequestBuilder)({ baseUrl: baseAPIURL, apiKey: this.config.apiKey });
            const doRequest = () => request({
                data: {
                    data: {
                        attributes: {
                            ci_env: ciEnv,
                            ci_level: level,
                            provider,
                            tags,
                        },
                        type: 'ci_custom_tag',
                    },
                },
                method: 'post',
                url: 'api/v2/ci/pipeline/tags',
            });
            try {
                yield (0, retry_1.retryRequest)(doRequest, {
                    maxTimeout: 30000,
                    minTimeout: 5000,
                    onRetry: (e, attempt) => {
                        this.context.stderr.write(chalk_1.default.yellow(`[attempt ${attempt}] Could not send tags. Retrying...: ${e.message}\n`));
                    },
                    retries: 5,
                });
            }
            catch (error) {
                this.handleError(error);
                return 1;
            }
            return 0;
        });
    }
    handleError(error) {
        this.context.stderr.write(`${chalk_1.default.red.bold('[ERROR]')} Could not send tags: ` +
            `${error.response ? JSON.stringify(error.response.data, undefined, 2) : ''}\n`);
    }
}
exports.TagCommand = TagCommand;
TagCommand.paths = [['tag']];
TagCommand.usage = clipanion_1.Command.Usage({
    category: 'CI Visibility',
    description: 'Add tags to a CI Pipeline trace pipeline or job span in Datadog.',
    details: `
            This command when run from a supported CI provider sends an arbitrary set of key:value
            tags to Datadog to include in the CI Visibility traces.
    `,
    examples: [
        ['Add a team tag to the current pipeline', 'datadog-ci tag --level pipeline --tags team:backend'],
        ['Tag the current CI job with the go version', 'datadog-ci tag --level job --tags "go.version:`go version`"'],
        ['Add tags in bulk using a JSON file', 'datadog-ci tag --level job --tags-file my_tags.json'],
    ],
});
//# sourceMappingURL=tag.js.map