"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UninstrumentCommand = void 0;
const client_cloudwatch_logs_1 = require("@aws-sdk/client-cloudwatch-logs");
const client_lambda_1 = require("@aws-sdk/client-lambda");
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const constants_1 = require("../../constants");
const env_1 = require("../../helpers/env");
const fips_1 = require("../../helpers/fips");
const prompt_1 = require("../../helpers/prompt");
const helperRenderer = __importStar(require("../../helpers/renderer"));
const utils_1 = require("../../helpers/utils");
const constants_2 = require("./constants");
const commons_1 = require("./functions/commons");
const uninstrument_1 = require("./functions/uninstrument");
const prompt_2 = require("./prompt");
const commonRenderer = __importStar(require("./renderers/common-renderer"));
const instrumentRenderer = __importStar(require("./renderers/instrument-uninstrument-renderer"));
class UninstrumentCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.configPath = clipanion_1.Option.String('--config');
        this.dryRun = clipanion_1.Option.Boolean('-d,--dry,--dry-run', false);
        this.forwarder = clipanion_1.Option.String('--forwarder');
        this.functions = clipanion_1.Option.Array('-f,--function', []);
        this.interactive = clipanion_1.Option.Boolean('-i,--interactive', false);
        this.profile = clipanion_1.Option.String('--profile');
        this.regExPattern = clipanion_1.Option.String('--functions-regex,--functionsRegex');
        this.region = clipanion_1.Option.String('-r,--region');
        /**
         * Arguments that are not really in use, but to
         * make uninstrumentation easier for the user.
         */
        this.layerVersion = clipanion_1.Option.String('-v,--layer-version,--layerVersion', { hidden: true });
        this.tracing = clipanion_1.Option.String('--tracing', { hidden: true });
        this.logLevel = clipanion_1.Option.String('--log-level,--logLevel', { hidden: true });
        this.service = clipanion_1.Option.String('--service', { hidden: true });
        this.environment = clipanion_1.Option.String('--env', { hidden: true });
        this.version = clipanion_1.Option.String('--version', { hidden: true });
        this.appsecEnabled = clipanion_1.Option.Boolean('--appsec', { hidden: true });
        this.apmFlushDeadline = clipanion_1.Option.String('--apm-flush-deadline', { hidden: true });
        this.extraTags = clipanion_1.Option.String('--extra-tags,--extraTags', { hidden: true });
        this.extensionVersion = clipanion_1.Option.String('-e,--extension-version,--extensionVersion', { hidden: true });
        this.mergeXrayTraces = clipanion_1.Option.String('--merge-xray-traces,--mergeXrayTraces', { hidden: true });
        this.flushMetricsToLogs = clipanion_1.Option.String('--flush-metrics-to-logs,--flushMetricsToLogs', { hidden: true });
        this.captureLambdaPayload = clipanion_1.Option.String('--capture-lambda-payload,--captureLambdaPayload', { hidden: true });
        this.config = {
            functions: [],
            region: process.env[constants_2.AWS_DEFAULT_REGION_ENV_VAR],
        };
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.fipsConfig = {
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
    }
    execute() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.fipsConfig.fips, this.fipsIgnoreError || this.fipsConfig.fipsIgnoreError);
            this.context.stdout.write(instrumentRenderer.renderLambdaHeader(Object.getPrototypeOf(this), this.dryRun));
            const lambdaConfig = { lambda: this.config };
            this.config = (yield (0, utils_1.resolveConfigFromFile)(lambdaConfig, { configPath: this.configPath, defaultConfigPaths: utils_1.DEFAULT_CONFIG_PATHS })).lambda;
            const profile = (_a = this.profile) !== null && _a !== void 0 ? _a : this.config.profile;
            if (profile) {
                try {
                    this.credentials = yield (0, commons_1.getAWSProfileCredentials)(profile);
                }
                catch (err) {
                    this.context.stdout.write(helperRenderer.renderError(err));
                    return 1;
                }
            }
            let hasSpecifiedFunctions = this.functions.length !== 0 || this.config.functions.length !== 0;
            if (this.interactive) {
                try {
                    const credentials = yield (0, commons_1.getAWSCredentials)();
                    if (credentials === undefined) {
                        this.context.stdout.write(commonRenderer.renderNoAWSCredentialsFound());
                        yield (0, prompt_2.requestAWSCredentials)();
                    }
                    else {
                        this.credentials = credentials;
                    }
                }
                catch (err) {
                    this.context.stdout.write(helperRenderer.renderError(err));
                    return 1;
                }
                const region = (_c = (_b = this.region) !== null && _b !== void 0 ? _b : this.config.region) !== null && _c !== void 0 ? _c : process.env[constants_2.AWS_DEFAULT_REGION_ENV_VAR];
                this.region = region;
                if (!hasSpecifiedFunctions) {
                    const spinner = instrumentRenderer.fetchingFunctionsSpinner();
                    try {
                        const lambdaClientConfig = {
                            region,
                            credentials: this.credentials,
                            retryStrategy: constants_2.EXPONENTIAL_BACKOFF_RETRY_STRATEGY,
                        };
                        const lambdaClient = new client_lambda_1.LambdaClient(lambdaClientConfig);
                        spinner.start();
                        const functionNames = (_d = (yield (0, commons_1.getAllLambdaFunctionConfigs)(lambdaClient)).map((config) => config.FunctionName).sort()) !== null && _d !== void 0 ? _d : [];
                        if (functionNames.length === 0) {
                            this.context.stdout.write(instrumentRenderer.renderCouldntFindLambdaFunctionsInRegionError());
                            return 1;
                        }
                        spinner.succeed(instrumentRenderer.renderFetchedLambdaFunctions(functionNames.length));
                        const functions = yield (0, prompt_2.requestFunctionSelection)(functionNames);
                        this.functions = functions;
                    }
                    catch (err) {
                        spinner.fail(instrumentRenderer.renderFailedFetchingLambdaFunctions());
                        this.context.stdout.write(instrumentRenderer.renderCouldntFetchLambdaFunctionsError(err));
                        return 1;
                    }
                }
            }
            hasSpecifiedFunctions = this.functions.length !== 0 || this.config.functions.length !== 0;
            const hasSpecifiedRegExPattern = this.regExPattern !== undefined && this.regExPattern !== '';
            if (!hasSpecifiedFunctions && !hasSpecifiedRegExPattern) {
                this.context.stdout.write(instrumentRenderer.renderNoFunctionsSpecifiedError(Object.getPrototypeOf(this)));
                return 1;
            }
            const configGroups = [];
            // Fetch lambda function configurations that are
            // available to be un-instrumented.
            if (hasSpecifiedRegExPattern) {
                if (hasSpecifiedFunctions) {
                    this.context.stdout.write(instrumentRenderer.renderFunctionsAndFunctionsRegexOptionsBothSetError(this.functions.length !== 0));
                    return 1;
                }
                if (this.regExPattern.match(':')) {
                    this.context.stdout.write(instrumentRenderer.renderRegexSetWithARNError());
                    return 1;
                }
                const region = this.region || this.config.region;
                if (!region) {
                    this.context.stdout.write(commonRenderer.renderNoDefaultRegionSpecifiedError());
                    return 1;
                }
                const spinner = instrumentRenderer.fetchingFunctionsSpinner();
                try {
                    const cloudWatchLogsClient = new client_cloudwatch_logs_1.CloudWatchLogsClient({
                        region,
                        retryStrategy: constants_2.EXPONENTIAL_BACKOFF_RETRY_STRATEGY,
                    });
                    const lambdaClientConfig = {
                        region,
                        credentials: this.credentials,
                        retryStrategy: constants_2.EXPONENTIAL_BACKOFF_RETRY_STRATEGY,
                    };
                    const lambdaClient = new client_lambda_1.LambdaClient(lambdaClientConfig);
                    spinner.start();
                    const configs = yield (0, uninstrument_1.getUninstrumentedFunctionConfigsFromRegEx)(lambdaClient, cloudWatchLogsClient, this.regExPattern, this.forwarder);
                    spinner.succeed(instrumentRenderer.renderFetchedLambdaFunctions(configs.length));
                    configGroups.push({ configs, lambdaClient, cloudWatchLogsClient, region });
                }
                catch (err) {
                    spinner.fail(instrumentRenderer.renderFailedFetchingLambdaFunctions());
                    this.context.stdout.write(instrumentRenderer.renderCouldntFetchLambdaFunctionsError(err));
                    return 1;
                }
            }
            else {
                let functionGroups;
                try {
                    functionGroups = (0, commons_1.collectFunctionsByRegion)(this.functions.length !== 0 ? this.functions : this.config.functions, this.region || this.config.region);
                }
                catch (err) {
                    this.context.stdout.write(instrumentRenderer.renderCouldntGroupFunctionsError(err));
                    return 1;
                }
                for (const [region, functionARNs] of Object.entries(functionGroups)) {
                    const spinner = instrumentRenderer.fetchingFunctionsConfigSpinner(region);
                    spinner.start();
                    const lambdaClientConfig = {
                        region,
                        credentials: this.credentials,
                        retryStrategy: constants_2.EXPONENTIAL_BACKOFF_RETRY_STRATEGY,
                    };
                    const lambdaClient = new client_lambda_1.LambdaClient(lambdaClientConfig);
                    const cloudWatchLogsClient = new client_cloudwatch_logs_1.CloudWatchLogsClient({
                        region,
                        retryStrategy: constants_2.EXPONENTIAL_BACKOFF_RETRY_STRATEGY,
                    });
                    try {
                        const configs = yield (0, uninstrument_1.getUninstrumentedFunctionConfigs)(lambdaClient, cloudWatchLogsClient, functionARNs, this.forwarder);
                        configGroups.push({ configs, lambdaClient, cloudWatchLogsClient, region });
                        spinner.succeed(instrumentRenderer.renderFetchedLambdaConfigurationsFromRegion(region, configs.length));
                    }
                    catch (err) {
                        spinner.fail(instrumentRenderer.renderFailedFetchingLambdaConfigurationsFromRegion(region));
                        this.context.stdout.write(instrumentRenderer.renderCouldntFetchLambdaFunctionsError(err));
                        return 1;
                    }
                }
            }
            const configList = configGroups.map((group) => group.configs).reduce((a, b) => a.concat(b));
            this.printPlannedActions(configList);
            if (this.dryRun || configList.length === 0) {
                return 0;
            }
            const willUpdate = (0, commons_1.willUpdateFunctionConfigs)(configList);
            if (this.interactive && willUpdate) {
                this.context.stdout.write(instrumentRenderer.renderConfirmationNeededSoftWarning());
                const isConfirmed = yield (0, prompt_1.requestConfirmation)('Do you want to apply the changes?');
                if (!isConfirmed) {
                    return 0;
                }
                this.context.stdout.write(instrumentRenderer.renderUninstrumentingFunctionsSoftWarning());
            }
            // Un-instrument functions.
            if (willUpdate) {
                if (willUpdate) {
                    try {
                        yield (0, commons_1.handleLambdaFunctionUpdates)(configGroups, this.context.stdout);
                    }
                    catch (_e) {
                        return 1;
                    }
                }
            }
            return 0;
        });
    }
    printPlannedActions(configs) {
        const willUpdate = (0, commons_1.willUpdateFunctionConfigs)(configs);
        if (!willUpdate) {
            this.context.stdout.write(instrumentRenderer.renderNoUpdatesApplied(this.dryRun));
            return;
        }
        this.context.stdout.write(instrumentRenderer.renderFunctionsToBeUpdated());
        for (const config of configs) {
            this.context.stdout.write(`\t- ${chalk_1.default.bold(config.functionARN)}\n`);
        }
        this.context.stdout.write(instrumentRenderer.renderWillApplyUpdates(this.dryRun));
        for (const config of configs) {
            if (config.updateFunctionConfigurationCommandInput) {
                const maskedConfig = (0, commons_1.maskConfig)(config.updateFunctionConfigurationCommandInput);
                this.context.stdout.write(`UpdateFunctionConfiguration -> ${config.functionARN}\n${JSON.stringify(maskedConfig, undefined, 2)}\n`);
            }
            const { logGroupConfiguration, tagConfiguration } = config;
            if (tagConfiguration === null || tagConfiguration === void 0 ? void 0 : tagConfiguration.untagResourceCommandInput) {
                this.context.stdout.write(`UntagResource -> ${tagConfiguration.untagResourceCommandInput.Resource}\n${JSON.stringify(tagConfiguration.untagResourceCommandInput.TagKeys, undefined, 2)}\n`);
            }
            if (logGroupConfiguration === null || logGroupConfiguration === void 0 ? void 0 : logGroupConfiguration.deleteSubscriptionFilterCommandInput) {
                this.context.stdout.write(`DeleteSubscriptionFilter -> ${logGroupConfiguration.logGroupName}\n${JSON.stringify(logGroupConfiguration.deleteSubscriptionFilterCommandInput, undefined, 2)}\n`);
            }
        }
    }
}
exports.UninstrumentCommand = UninstrumentCommand;
UninstrumentCommand.paths = [['lambda', 'uninstrument']];
UninstrumentCommand.usage = clipanion_1.Command.Usage({
    category: 'Serverless',
    description: 'Revert Datadog instrumentation in a Lambda.',
});
//# sourceMappingURL=uninstrument.js.map