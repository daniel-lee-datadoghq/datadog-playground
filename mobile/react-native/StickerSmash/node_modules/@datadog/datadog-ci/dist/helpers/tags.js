"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSpanTags = exports.getMissingRequiredGitTags = exports.REQUIRED_GIT_TAGS = exports.parseMeasuresFile = exports.parseTagsFile = exports.parseMetrics = exports.parseTags = exports.SERVICE = exports.SBOM_TOOL_GENERATOR_VERSION = exports.SBOM_TOOL_GENERATOR_NAME = exports.PR_NUMBER = exports.GIT_PULL_REQUEST_BASE_BRANCH = exports.GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA = exports.GIT_PULL_REQUEST_BASE_BRANCH_SHA = exports.GIT_HEAD_SHA = exports.GIT_TAG = exports.GIT_SHA = exports.GIT_COMMIT_MESSAGE = exports.GIT_COMMIT_COMMITTER_NAME = exports.GIT_COMMIT_COMMITTER_EMAIL = exports.GIT_COMMIT_COMMITTER_DATE = exports.GIT_COMMIT_AUTHOR_NAME = exports.GIT_COMMIT_AUTHOR_EMAIL = exports.GIT_COMMIT_AUTHOR_DATE = exports.GIT_BRANCH = exports.CI_ENV_VARS = exports.CI_NODE_LABELS = exports.CI_NODE_NAME = exports.CI_STAGE_NAME = exports.CI_JOB_NAME = exports.CI_JOB_URL = exports.GIT_REPOSITORY_URL = exports.CI_WORKSPACE_PATH = exports.CI_PIPELINE_NUMBER = exports.CI_PIPELINE_NAME = exports.CI_PIPELINE_ID = exports.CI_PROVIDER_NAME = exports.CI_PIPELINE_URL = void 0;
// Build
const fs_1 = __importDefault(require("fs"));
const chalk_1 = __importDefault(require("chalk"));
const upath_1 = __importDefault(require("upath"));
const ci_1 = require("./ci");
const format_git_span_data_1 = require("./git/format-git-span-data");
const user_provided_git_1 = require("./user-provided-git");
const utils_1 = require("./utils");
exports.CI_PIPELINE_URL = 'ci.pipeline.url';
exports.CI_PROVIDER_NAME = 'ci.provider.name';
exports.CI_PIPELINE_ID = 'ci.pipeline.id';
exports.CI_PIPELINE_NAME = 'ci.pipeline.name';
exports.CI_PIPELINE_NUMBER = 'ci.pipeline.number';
exports.CI_WORKSPACE_PATH = 'ci.workspace_path';
exports.GIT_REPOSITORY_URL = 'git.repository_url';
exports.CI_JOB_URL = 'ci.job.url';
exports.CI_JOB_NAME = 'ci.job.name';
exports.CI_STAGE_NAME = 'ci.stage.name';
exports.CI_NODE_NAME = 'ci.node.name';
exports.CI_NODE_LABELS = 'ci.node.labels';
exports.CI_ENV_VARS = '_dd.ci.env_vars';
// Git
exports.GIT_BRANCH = 'git.branch';
exports.GIT_COMMIT_AUTHOR_DATE = 'git.commit.author.date';
exports.GIT_COMMIT_AUTHOR_EMAIL = 'git.commit.author.email';
exports.GIT_COMMIT_AUTHOR_NAME = 'git.commit.author.name';
exports.GIT_COMMIT_COMMITTER_DATE = 'git.commit.committer.date';
exports.GIT_COMMIT_COMMITTER_EMAIL = 'git.commit.committer.email';
exports.GIT_COMMIT_COMMITTER_NAME = 'git.commit.committer.name';
exports.GIT_COMMIT_MESSAGE = 'git.commit.message';
exports.GIT_SHA = 'git.commit.sha';
exports.GIT_TAG = 'git.tag';
exports.GIT_HEAD_SHA = 'git.commit.head_sha';
exports.GIT_PULL_REQUEST_BASE_BRANCH_SHA = 'git.pull_request.base_branch_sha';
exports.GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA = 'git.pull_request.base_branch_head_sha';
exports.GIT_PULL_REQUEST_BASE_BRANCH = 'git.pull_request.base_branch';
// PR
exports.PR_NUMBER = 'pr.number';
// Sbom
exports.SBOM_TOOL_GENERATOR_NAME = 'tool.generator.name';
exports.SBOM_TOOL_GENERATOR_VERSION = 'tool.generator.version';
// General
exports.SERVICE = 'service';
const parseNumericTag = (numericTag) => {
    if (numericTag) {
        const number = parseFloat(numericTag);
        return isFinite(number) ? number : undefined;
    }
};
/**
 * Receives an array of the form ['key:value', 'key2:value2']
 * and returns an object of the form {key: 'value', key2: 'value2'}
 */
const parseTags = (tags) => {
    try {
        return tags.reduce((acc, keyValuePair) => {
            if (!keyValuePair.includes(':')) {
                return acc;
            }
            const firstColon = keyValuePair.indexOf(':');
            const key = keyValuePair.substring(0, firstColon);
            const value = keyValuePair.substring(firstColon + 1);
            return Object.assign(Object.assign({}, acc), { [key]: value });
        }, {});
    }
    catch (e) {
        return {};
    }
};
exports.parseTags = parseTags;
/**
 * Similar to `parseTags` but it's assumed that numbers are received
 * Receives an array of the form ['key:123', 'key2:321']
 * and returns an object of the form {key: 123, key2: 321}
 */
const parseMetrics = (tags) => {
    try {
        return tags.reduce((acc, keyValuePair) => {
            if (!keyValuePair.includes(':')) {
                return acc;
            }
            const firstColon = keyValuePair.indexOf(':');
            const key = keyValuePair.substring(0, firstColon);
            const value = keyValuePair.substring(firstColon + 1);
            const number = parseNumericTag(value);
            if (number !== undefined) {
                return Object.assign(Object.assign({}, acc), { [key]: number });
            }
            return acc;
        }, {});
    }
    catch (e) {
        return {};
    }
};
exports.parseMetrics = parseMetrics;
/**
 * Receives a filepath to a JSON file that contains tags in the form of:
 * {
 *  "key": "value",
 *  "key2": "value2"
 * }
 * and returns a record of the form {key: 'value', key2: 'value2'}
 * Numbers are converted to strings and nested objects are ignored.
 * @param context - the context of the CLI, used to write to stdout and stderr
 * @param tagsFile - the path to the JSON file
 */
const parseTagsFile = (context, tagsFile) => {
    if (!tagsFile || tagsFile === '') {
        return [{}, true];
    }
    const fileContent = readJsonFile(context, tagsFile);
    if (fileContent === '') {
        return [{}, false];
    }
    let tags;
    try {
        tags = JSON.parse(fileContent);
    }
    catch (error) {
        context.stderr.write(`${chalk_1.default.red.bold('[ERROR]')} could not parse JSON file '${tagsFile}': ${error}\n`);
        return [{}, false];
    }
    // We want to ensure that all tags are strings
    for (const key in tags) {
        if (typeof tags[key] === 'object') {
            context.stdout.write(`${chalk_1.default.yellow.bold('[WARN]')} tag '${key}' had nested fields which will be ignored\n`);
            delete tags[key];
        }
        else if (typeof tags[key] !== 'string') {
            context.stdout.write(`${chalk_1.default.yellow.bold('[WARN]')} tag '${key}' was not a string, converting to string\n`);
            tags[key] = String(tags[key]);
        }
    }
    return [tags, true];
};
exports.parseTagsFile = parseTagsFile;
/**
 * Similar to `parseTagsFile` but it's assumed that numbers are received
 * If a field is not a number, it will be ignored
 * @param context - the context of the CLI, used to write to stdout and stderr
 * @param measuresFile - the path to the JSON file
 */
const parseMeasuresFile = (context, measuresFile) => {
    if (!measuresFile || measuresFile === '') {
        return [{}, true];
    }
    const fileContent = readJsonFile(context, measuresFile);
    if (fileContent === '') {
        return [{}, false];
    }
    let measures;
    try {
        measures = JSON.parse(fileContent);
    }
    catch (error) {
        context.stderr.write(`${chalk_1.default.red.bold('[ERROR]')} could not parse JSON file '${measuresFile}': ${error}\n`);
        return [{}, false];
    }
    // We want to ensure that all tags are strings
    for (const key in measures) {
        if (typeof measures[key] !== 'number') {
            context.stdout.write(`${chalk_1.default.yellow.bold('[WARN]')} ignoring field '${key}' because it was not a number\n`);
            delete measures[key];
        }
    }
    return [measures, true];
};
exports.parseMeasuresFile = parseMeasuresFile;
/**
 * These are required git tags for the following commands: sarif and sbom.
 */
exports.REQUIRED_GIT_TAGS = [
    exports.GIT_REPOSITORY_URL,
    exports.GIT_BRANCH,
    exports.GIT_SHA,
    exports.GIT_COMMIT_AUTHOR_EMAIL,
    exports.GIT_COMMIT_AUTHOR_NAME,
    exports.GIT_COMMIT_COMMITTER_EMAIL,
    exports.GIT_COMMIT_COMMITTER_NAME,
];
/**
 * A utility to determine which required git tags are missing.
 * @param tags - the tags to check
 * @returns an array of the missing required git tags (ex. ['git.repository_url', 'git.branch'])
 */
const getMissingRequiredGitTags = (tags) => {
    const missingTags = exports.REQUIRED_GIT_TAGS.reduce((acc, tag) => {
        if (!tags[tag] || tags[tag].trim() === '') {
            acc.push(tag);
        }
        return acc;
    }, []);
    return missingTags;
};
exports.getMissingRequiredGitTags = getMissingRequiredGitTags;
/**
 * Get the tags to upload results in CI for the following commands: sarif and sbom.
 * @param config - the configuration of the CLI
 * @param additionalTags - additional tags passed, generally from the command line.
 * @param includeCiTags - include CI tags or not
 */
const getSpanTags = (config, additionalTags, includeCiTags, gitPath) => __awaiter(void 0, void 0, void 0, function* () {
    const ciSpanTags = includeCiTags ? (0, ci_1.getCISpanTags)() : [];
    const gitSpanTags = yield (0, format_git_span_data_1.getGitMetadata)(gitPath);
    const userGitSpanTags = (0, user_provided_git_1.getUserGitSpanTags)();
    const envVarTags = config.envVarTags ? (0, exports.parseTags)(config.envVarTags.split(',')) : {};
    const cliTags = additionalTags ? (0, exports.parseTags)(additionalTags) : {};
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (gitPath ? Object.assign(Object.assign({}, ciSpanTags), gitSpanTags) : Object.assign(Object.assign({}, gitSpanTags), ciSpanTags))), userGitSpanTags), cliTags), envVarTags), (config.env ? { env: config.env } : {}));
});
exports.getSpanTags = getSpanTags;
const readJsonFile = (context, filename) => {
    filename = upath_1.default.normalize(filename); // resolve relative paths
    if (!fs_1.default.existsSync(filename)) {
        context.stderr.write(`${chalk_1.default.red.bold('[ERROR]')} file '${filename}' does not exist\n`);
        return '';
    }
    if (!(0, utils_1.isFile)(filename)) {
        context.stderr.write(`${chalk_1.default.red.bold('[ERROR]')} path '${filename}' did not point to a file\n`);
        return '';
    }
    if (upath_1.default.extname(filename) !== '.json') {
        context.stderr.write(`${chalk_1.default.red.bold('[ERROR]')} file '${filename}' is not a JSON file\n`);
        return '';
    }
    return String(fs_1.default.readFileSync(filename));
};
//# sourceMappingURL=tags.js.map