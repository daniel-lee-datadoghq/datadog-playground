"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findFiles = exports.partitionFiles = void 0;
const fs = __importStar(require("fs"));
const fs_1 = require("fs");
const glob_1 = require("./glob");
const utils_1 = require("./utils");
const DEFAULT_IGNORED_FOLDERS = [
    '.circleci',
    '.egg-info*',
    '.env',
    '.envs',
    '.git',
    '.github',
    '.gitlab',
    '.go',
    '.gradle',
    '.hg',
    '.idea',
    '.map',
    '.marker',
    '.npm',
    '.nyc_output',
    '.tox',
    '.venv',
    '.venvs',
    '.virtualenv',
    '.virtualenvs',
    '.vscode',
    '.yarn',
    '.yarn-cache',
    '__pycache__',
    'bower_components',
    'conftest_*.c.gcov',
    'htmlcov',
    'jspm_packages',
    'node_modules',
    'virtualenv',
    'virtualenvs',
];
const partitionFiles = (basePaths, ignoredPaths, 
// strict is set to true when the path is a file that was specified explicitly:
// for such files stricter validation is applied
partition) => {
    const results = {};
    for (const basePath of basePaths) {
        if ((0, glob_1.hasMagic)(basePath)) {
            // glob pattern
            const globMatches = (0, glob_1.globSync)(basePath, { dotRelative: true });
            for (const globMatch of globMatches) {
                partitionFilesRecursive(globMatch, ignoredPaths, partition, results, false);
            }
        }
        else {
            partitionFilesRecursive(basePath, ignoredPaths, partition, results, true);
        }
    }
    // deduplicate
    for (const key in results) {
        if (results.hasOwnProperty(key)) {
            results[key] = [...new Set(results[key])];
        }
    }
    return results;
};
exports.partitionFiles = partitionFiles;
const partitionFilesRecursive = (path, ignoredPaths, partition, results, strict) => {
    if (!fs.existsSync(path)) {
        return;
    }
    let stats;
    try {
        stats = (0, fs_1.statSync)(path);
    }
    catch (_a) {
        return;
    }
    if (stats.isFile()) {
        // regular file
        const pathPartition = partition(path, strict);
        if (pathPartition) {
            results[pathPartition] = results[pathPartition] || [];
            results[pathPartition].push(path);
        }
        return;
    }
    if (stats.isDirectory()) {
        const entries = fs.readdirSync(path, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = (0, utils_1.buildPath)(path, entry.name);
            if (ignore(fullPath, ignoredPaths) || DEFAULT_IGNORED_FOLDERS.includes(entry.name)) {
                continue;
            }
            partitionFilesRecursive(fullPath, ignoredPaths, partition, results, false);
        }
    }
};
const ignore = (path, ignoredPaths) => {
    for (const ignoredPath of ignoredPaths) {
        if (path.includes(ignoredPath)) {
            return true;
        }
    }
    return false;
};
/**
 * Finds and validates files based on the provided base paths.
 *
 * This function processes three types of inputs:
 * 1. Regular files - Direct file paths that exist
 * 2. Directories - Recursively searches for matching files in the directory
 * 3. Glob patterns - Uses the pattern to find matching files
 *
 * @param basePaths - Array of paths to search for files. Can include file paths, directory paths, or glob patterns.
 * @param searchRecursively - Whether to do recursive search in the nested folders (also applies to glob pattern matches).
 * @param ignoredPaths - List of paths to ignore
 * @param filterFile - Function to filter matching files. Should return true if a file matches. Is not applied to files specified explicitly.
 * @param validateFile - Function to validate files that matched. Should return undefined if valid, or an error message string if invalid.
 * @param renderInvalidFile - Function called for each invalid file to handle error reporting.
 * @returns Array of unique file paths that passed validation.
 */
const findFiles = (basePaths, searchRecursively, ignoredPaths, filterFile, validateFile, renderInvalidFile) => {
    const files = basePaths.flatMap((basePath) => {
        if ((0, utils_1.isFile)(basePath)) {
            // regular file
            return fs.existsSync(basePath) ? [basePath] : [];
        }
        else if ((0, glob_1.hasMagic)(basePath)) {
            // glob pattern
            const globMatches = (0, glob_1.globSync)(basePath, { dotRelative: true });
            if (searchRecursively) {
                return (0, exports.findFiles)(globMatches, searchRecursively, ignoredPaths, filterFile, validateFile, renderInvalidFile);
            }
            else {
                return globMatches.filter(filterFile).filter(utils_1.isFile);
            }
        }
        else {
            // folder
            const results = [];
            if (fs.existsSync(basePath)) {
                traverseDirectory(basePath, searchRecursively, ignoredPaths, filterFile, results);
            }
            return results;
        }
    });
    const uniqueFiles = [...new Set(files)];
    return uniqueFiles.filter((filePath) => {
        const validationErrorMessage = validateFile(filePath);
        if (validationErrorMessage) {
            renderInvalidFile(filePath, validationErrorMessage);
            return false;
        }
        else {
            return true;
        }
    });
};
exports.findFiles = findFiles;
const traverseDirectory = (dir, searchRecursively, ignoredPaths, filterFile, results) => {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
        const fullPath = (0, utils_1.buildPath)(dir, entry.name);
        if (ignoredPaths.includes(fullPath)) {
            continue;
        }
        if (entry.isDirectory()) {
            if (DEFAULT_IGNORED_FOLDERS.includes(entry.name)) {
                continue;
            }
            if (searchRecursively) {
                traverseDirectory(fullPath, searchRecursively, ignoredPaths, filterFile, results);
            }
        }
        else if (entry.isFile() && filterFile(fullPath)) {
            results.push(fullPath);
        }
    }
};
//# sourceMappingURL=file-finder.js.map