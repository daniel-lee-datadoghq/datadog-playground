"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isFile = exports.getGitHubEventPayload = exports.execute = exports.maskString = exports.formatBytes = exports.timedExecAsync = exports.filterAndFormatGithubRemote = exports.filterSensitiveInfoFromRepository = exports.performSubCommand = exports.pluralize = exports.normalizeRef = exports.recursivelyRemoveUndefinedValues = exports.removeUndefinedValues = exports.removeEmptyValues = exports.buildPath = exports.getApiHostForSite = exports.getProxyAgent = exports.getRequestBuilder = exports.getProxyUrl = exports.resolveConfigFromFile = exports.resolveConfigFromFileAndEnvironment = exports.getConfig = exports.pick = exports.makeTerminalLink = exports.DEFAULT_CONFIG_PATHS = void 0;
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const util_1 = require("util");
const axios_1 = require("axios");
const clipanion_1 = require("clipanion");
const deep_extend_1 = __importDefault(require("deep-extend"));
const proxy_agent_1 = require("proxy-agent");
const terminal_link_1 = __importDefault(require("terminal-link"));
exports.DEFAULT_CONFIG_PATHS = ['datadog-ci.json'];
const makeTerminalLink = (url) => {
    return ((strings) => (0, terminal_link_1.default)(strings[0], url));
};
exports.makeTerminalLink = makeTerminalLink;
const pick = (base, keys) => {
    const definedKeys = keys.filter((key) => !!base[key]);
    const pickedObject = {};
    for (const key of definedKeys) {
        pickedObject[key] = base[key];
    }
    return pickedObject;
};
exports.pick = pick;
const getConfig = (configPath) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const configFile = yield (0, util_1.promisify)(fs_1.readFile)(configPath, 'utf-8');
        return JSON.parse(configFile);
    }
    catch (error) {
        if (error instanceof SyntaxError) {
            throw new Error('Config file is not correct JSON');
        }
    }
});
exports.getConfig = getConfig;
const resolveConfigPath = ({ configPath, defaultConfigPaths, }) => {
    if (configPath) {
        if ((0, fs_1.existsSync)(configPath)) {
            return configPath;
        }
        throw new Error('Config file not found');
    }
    if (defaultConfigPaths) {
        for (const path of defaultConfigPaths) {
            if ((0, fs_1.existsSync)(path)) {
                return path;
            }
        }
    }
    return undefined;
};
/**
 * Applies configurations in this order of priority:
 * environment > config file > base config
 */
const resolveConfigFromFileAndEnvironment = (baseConfig, environment, params) => __awaiter(void 0, void 0, void 0, function* () {
    const configFromFile = yield (0, exports.resolveConfigFromFile)(baseConfig, params);
    if (params.configFromFileCallback) {
        params.configFromFileCallback(configFromFile);
    }
    return (0, deep_extend_1.default)(configFromFile, (0, exports.removeUndefinedValues)(environment));
});
exports.resolveConfigFromFileAndEnvironment = resolveConfigFromFileAndEnvironment;
const resolveConfigFromFile = (baseConfig, params) => __awaiter(void 0, void 0, void 0, function* () {
    const resolvedConfigPath = resolveConfigPath(params);
    if (!resolvedConfigPath) {
        return baseConfig;
    }
    const parsedConfig = yield (0, exports.getConfig)(resolvedConfigPath);
    return (0, deep_extend_1.default)(baseConfig, parsedConfig);
});
exports.resolveConfigFromFile = resolveConfigFromFile;
const getProxyUrl = (options) => {
    if (!options) {
        return '';
    }
    const { auth, host, port, protocol } = options;
    if (!host || !port) {
        return '';
    }
    const authFragment = auth ? `${auth.username}:${auth.password}@` : '';
    return `${protocol}://${authFragment}${host}:${port}`;
};
exports.getProxyUrl = getProxyUrl;
const getRequestBuilder = (options) => {
    const { apiKey, appKey, baseUrl, overrideUrl, proxyOpts } = options;
    const overrideArgs = (args) => {
        const newArguments = Object.assign(Object.assign({}, args), { headers: Object.assign(Object.assign({ 'DD-API-KEY': apiKey }, (appKey ? { 'DD-APPLICATION-KEY': appKey } : {})), args.headers) });
        if (overrideUrl !== undefined) {
            newArguments.url = overrideUrl;
        }
        const proxyAgent = (0, exports.getProxyAgent)(proxyOpts);
        if (proxyAgent) {
            newArguments.httpAgent = proxyAgent;
            newArguments.httpsAgent = proxyAgent;
        }
        if (options.headers !== undefined) {
            options.headers.forEach((value, key) => {
                newArguments.headers[key] = value;
            });
        }
        return newArguments;
    };
    const baseConfiguration = {
        baseURL: baseUrl,
        // Disabling proxy in Axios config as it's not working properly
        // the passed httpAgent/httpsAgent are handling the proxy instead.
        proxy: false,
    };
    return (args) => (0, axios_1.create)(baseConfiguration)(overrideArgs(args));
};
exports.getRequestBuilder = getRequestBuilder;
const proxyAgentCache = new Map();
const getProxyAgent = (proxyOpts) => {
    const proxyUrlFromConfiguration = (0, exports.getProxyUrl)(proxyOpts);
    let proxyAgent = proxyAgentCache.get(proxyUrlFromConfiguration);
    if (!proxyAgent) {
        proxyAgent = createProxyAgentForUrl(proxyUrlFromConfiguration);
        proxyAgentCache.set(proxyUrlFromConfiguration, proxyAgent);
    }
    return proxyAgent;
};
exports.getProxyAgent = getProxyAgent;
const createProxyAgentForUrl = (proxyUrl) => {
    if (!proxyUrl) {
        // Let the default proxy agent discover environment variables.
        return new proxy_agent_1.ProxyAgent();
    }
    return new proxy_agent_1.ProxyAgent({
        getProxyForUrl: (url) => {
            // Do not proxy the WebSocket connections.
            if (url === null || url === void 0 ? void 0 : url.match(/^wss?:/)) {
                return '';
            }
            return proxyUrl;
        },
    });
};
const getApiHostForSite = (site) => {
    switch (site) {
        case 'datad0g.com':
            return `app.${site}`;
        case 'datadoghq.com':
        case 'datadoghq.eu':
        default:
            return `api.${site}`;
    }
};
exports.getApiHostForSite = getApiHostForSite;
// The buildPath function is used to concatenate several paths. The goal is to have a function working for both unix
// paths and URL whereas standard path.join does not work with both.
const buildPath = (...args) => args
    .map((part, i) => {
    if (i === 0) {
        // For the first part, drop all / at the end of the path
        return part.trim().replace(/[\/]*$/g, '');
    }
    else {
        // For the following parts, remove all / at the beginning and at the end
        return part.trim().replace(/(^[\/]*|[\/]*$)/g, '');
    }
})
    // Filter out empty parts
    .filter((x) => x.length)
    // Join all these parts with /
    .join('/');
exports.buildPath = buildPath;
const removeEmptyValues = (tags) => Object.keys(tags).reduce((filteredTags, tag) => {
    if (!tags[tag]) {
        return filteredTags;
    }
    return Object.assign(Object.assign({}, filteredTags), { [tag]: tags[tag] });
}, {});
exports.removeEmptyValues = removeEmptyValues;
const removeUndefinedValues = (object) => {
    const newObject = Object.assign({}, object);
    for (const [key, value] of Object.entries(newObject)) {
        if (value === undefined) {
            delete newObject[key];
        }
    }
    return newObject;
};
exports.removeUndefinedValues = removeUndefinedValues;
const recursivelyRemoveUndefinedValues = (object) => {
    const newObject = {};
    for (const [key, value] of Object.entries(object)) {
        if (typeof value === 'object' && !Array.isArray(value)) {
            newObject[key] = (0, exports.recursivelyRemoveUndefinedValues)(value);
        }
        else if (value !== undefined) {
            newObject[key] = value;
        }
    }
    return newObject;
};
exports.recursivelyRemoveUndefinedValues = recursivelyRemoveUndefinedValues;
const normalizeRef = (ref) => {
    if (!ref) {
        return ref;
    }
    return ref.replace(/origin\/|refs\/heads\/|tags\//gm, '');
};
exports.normalizeRef = normalizeRef;
const pluralize = (nb, singular, plural) => {
    if (nb >= 2) {
        return `${nb} ${plural}`;
    }
    return `${nb} ${singular}`;
};
exports.pluralize = pluralize;
const performSubCommand = (command, commandArgs, context) => {
    const cli = new clipanion_1.Cli();
    cli.register(command);
    return cli.run(commandArgs, context);
};
exports.performSubCommand = performSubCommand;
const filterSensitiveInfoFromRepository = (repositoryUrl) => {
    try {
        if (!repositoryUrl) {
            return repositoryUrl;
        }
        if (repositoryUrl.startsWith('git@')) {
            return repositoryUrl;
        }
        // Remove the username from ssh URLs
        if (repositoryUrl.startsWith('ssh://')) {
            const sshRegex = /^(ssh:\/\/)[^@/]*@/;
            return repositoryUrl.replace(sshRegex, '$1');
        }
        const { protocol, host, pathname } = new URL(repositoryUrl);
        if (!protocol || !host) {
            return repositoryUrl;
        }
        return `${protocol}//${host}${pathname === '/' ? '' : pathname}`;
    }
    catch (e) {
        return repositoryUrl;
    }
};
exports.filterSensitiveInfoFromRepository = filterSensitiveInfoFromRepository;
// Removes sensitive info from the given git remote url and normalizes the url prefix.
// "git@github.com:" and "https://github.com/" prefixes will be normalized into "github.com/"
const filterAndFormatGithubRemote = (rawRemote) => {
    rawRemote = (0, exports.filterSensitiveInfoFromRepository)(rawRemote);
    if (!rawRemote) {
        return rawRemote;
    }
    rawRemote = rawRemote.replace(/git@github\.com:|https:\/\/github\.com\//, 'github.com/');
    return rawRemote;
};
exports.filterAndFormatGithubRemote = filterAndFormatGithubRemote;
const timedExecAsync = (f, input) => __awaiter(void 0, void 0, void 0, function* () {
    const initialTime = Date.now();
    yield f(input);
    return (Date.now() - initialTime) / 1000;
});
exports.timedExecAsync = timedExecAsync;
/**
 * Convert bytes to a formatted string in KB, MB, GB, etc.
 * Note: Lambda documentation uses MB (instead of Mib) to refer to 1024 KB, so we follow that style here
 * @param bytes
 * @param decimals
 */
const formatBytes = (bytes, decimals = 2) => {
    if (!bytes) {
        return '0 Bytes';
    }
    if (bytes < 0) {
        throw Error("'bytes' can't be negative.");
    }
    const bytesPerKB = 1024;
    const numDecimals = decimals < 0 ? 0 : decimals;
    const units = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(bytesPerKB));
    const formattedBytes = parseFloat((bytes / Math.pow(bytesPerKB, i)).toFixed(numDecimals));
    return `${formattedBytes} ${units[i]}`;
};
exports.formatBytes = formatBytes;
// Mask a string to hide sensitive values
const maskString = (value) => {
    if (value === undefined) {
        return '<unset>';
    }
    else if (value.length === 0) {
        return '<empty>';
    }
    // Don't mask booleans
    if (value.toLowerCase() === 'true' || value.toLowerCase() === 'false') {
        return value;
    }
    // Dont mask numbers
    if (!isNaN(Number(value))) {
        return value;
    }
    // Mask entire string if it's short
    if (value.length < 12) {
        return '*'.repeat(16);
    }
    // Keep first two and last four characters if it's long
    return value.slice(0, 2) + '*'.repeat(10) + value.slice(-4);
};
exports.maskString = maskString;
const execProc = (0, util_1.promisify)(child_process_1.exec);
const execute = (cmd, cwd) => execProc(cmd, {
    cwd,
    maxBuffer: 5 * 1024 * 5000,
});
exports.execute = execute;
const getGitHubEventPayload = () => {
    if (!process.env.GITHUB_EVENT_PATH) {
        return;
    }
    return JSON.parse((0, fs_1.readFileSync)(process.env.GITHUB_EVENT_PATH, 'utf8'));
};
exports.getGitHubEventPayload = getGitHubEventPayload;
const isFile = (path) => {
    try {
        return (0, fs_1.lstatSync)(path).isFile();
    }
    catch (e) {
        return false;
    }
};
exports.isFile = isFile;
//# sourceMappingURL=utils.js.map