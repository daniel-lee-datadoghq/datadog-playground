"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInteractive = exports.getCIProvider = exports.getCIEnv = exports.getCIMetadata = exports.getCISpanTags = exports.PROVIDER_TO_DISPLAY_NAME = exports.CI_ENGINES = void 0;
const tags_1 = require("./tags");
const user_provided_git_1 = require("./user-provided-git");
const utils_1 = require("./utils");
exports.CI_ENGINES = {
    APPVEYOR: 'appveyor',
    AWSCODEPIPELINE: 'awscodepipeline',
    AZURE: 'azurepipelines',
    BITBUCKET: 'bitbucket',
    BITRISE: 'bitrise',
    BUDDY: 'buddy',
    BUILDKITE: 'buildkite',
    CIRCLECI: 'circleci',
    CODEFRESH: 'codefresh',
    GITHUB: 'github',
    GITLAB: 'gitlab',
    JENKINS: 'jenkins',
    TRAVIS: 'travisci',
    TEAMCITY: 'teamcity',
};
exports.PROVIDER_TO_DISPLAY_NAME = {
    github: 'GitHub Actions',
};
// DD_GITHUB_JOB_NAME is an override that is required for adding custom tags and metrics
// to GHA jobs if the 'name' property is used. It's ok for it to be missing in case the name property is not used.
const envAllowedToBeMissing = ['DD_GITHUB_JOB_NAME'];
// Receives a string with the form 'John Doe <john.doe@gmail.com>'
// and returns { name: 'John Doe', email: 'john.doe@gmail.com' }
const parseEmailAndName = (emailAndName) => {
    if (!emailAndName) {
        return { name: '', email: '' };
    }
    let name = '';
    let email = '';
    const matchNameAndEmail = emailAndName.match(/(?:"?([^"]*)"?\s)?(?:<?(.+@[^>]+)>?)/);
    if (matchNameAndEmail) {
        name = matchNameAndEmail[1];
        email = matchNameAndEmail[2];
    }
    return { name, email };
};
const resolveTilde = (filePath) => {
    var _a;
    if (!filePath || typeof filePath !== 'string') {
        return '';
    }
    // '~/folder/path' or '~'
    if (filePath[0] === '~' && (filePath[1] === '/' || filePath.length === 1)) {
        return filePath.replace('~', (_a = process.env.HOME) !== null && _a !== void 0 ? _a : '');
    }
    return filePath;
};
const getCISpanTags = () => {
    var _a, _b, _c, _d, _e, _f, _g;
    const env = process.env;
    let tags = {};
    if (env.DRONE) {
        const { DRONE_BUILD_NUMBER, DRONE_BUILD_LINK, DRONE_STEP_NAME, DRONE_STAGE_NAME, DRONE_WORKSPACE, DRONE_GIT_HTTP_URL, DRONE_COMMIT_SHA, DRONE_BRANCH, DRONE_TAG, DRONE_COMMIT_AUTHOR_NAME, DRONE_COMMIT_AUTHOR_EMAIL, DRONE_COMMIT_MESSAGE, DRONE_PULL_REQUEST, DRONE_TARGET_BRANCH, } = env;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: 'drone',
            [tags_1.CI_PIPELINE_NUMBER]: DRONE_BUILD_NUMBER,
            [tags_1.CI_PIPELINE_URL]: DRONE_BUILD_LINK,
            [tags_1.CI_JOB_NAME]: DRONE_STEP_NAME,
            [tags_1.CI_STAGE_NAME]: DRONE_STAGE_NAME,
            [tags_1.CI_WORKSPACE_PATH]: DRONE_WORKSPACE,
            [tags_1.GIT_REPOSITORY_URL]: DRONE_GIT_HTTP_URL,
            [tags_1.GIT_SHA]: DRONE_COMMIT_SHA,
            [tags_1.GIT_BRANCH]: DRONE_BRANCH,
            [tags_1.GIT_TAG]: DRONE_TAG,
            [tags_1.GIT_COMMIT_AUTHOR_NAME]: DRONE_COMMIT_AUTHOR_NAME,
            [tags_1.GIT_COMMIT_AUTHOR_EMAIL]: DRONE_COMMIT_AUTHOR_EMAIL,
            [tags_1.GIT_COMMIT_MESSAGE]: DRONE_COMMIT_MESSAGE,
        };
        if (DRONE_PULL_REQUEST) {
            tags[tags_1.PR_NUMBER] = DRONE_PULL_REQUEST;
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = DRONE_TARGET_BRANCH;
        }
    }
    if (env.CIRCLECI) {
        const { CIRCLE_BUILD_NUM, CIRCLE_WORKFLOW_ID, CIRCLE_PROJECT_REPONAME, CIRCLE_BUILD_URL, CIRCLE_WORKING_DIRECTORY, CIRCLE_BRANCH, CIRCLE_TAG, CIRCLE_SHA1, CIRCLE_REPOSITORY_URL, CIRCLE_JOB, CIRCLE_PR_NUMBER, CIRCLE_PULL_REQUEST, } = env;
        const pipelineUrl = `https://app.circleci.com/pipelines/workflows/${CIRCLE_WORKFLOW_ID}`;
        tags = {
            [tags_1.CI_JOB_URL]: CIRCLE_BUILD_URL,
            [tags_1.CI_PIPELINE_ID]: CIRCLE_WORKFLOW_ID,
            [tags_1.CI_PIPELINE_NAME]: CIRCLE_PROJECT_REPONAME,
            [tags_1.CI_PIPELINE_URL]: pipelineUrl,
            [tags_1.CI_JOB_NAME]: CIRCLE_JOB,
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.CIRCLECI,
            [tags_1.CI_WORKSPACE_PATH]: CIRCLE_WORKING_DIRECTORY,
            [tags_1.GIT_SHA]: CIRCLE_SHA1,
            [tags_1.GIT_REPOSITORY_URL]: CIRCLE_REPOSITORY_URL,
            [tags_1.GIT_TAG]: CIRCLE_TAG,
            [tags_1.GIT_BRANCH]: CIRCLE_BRANCH,
            [tags_1.CI_ENV_VARS]: JSON.stringify({
                CIRCLE_WORKFLOW_ID,
                // Snapshots are generated automatically and are sort sensitive
                CIRCLE_BUILD_NUM,
            }),
        };
        if (CIRCLE_PR_NUMBER || CIRCLE_PULL_REQUEST) {
            tags[tags_1.PR_NUMBER] = CIRCLE_PR_NUMBER || (CIRCLE_PULL_REQUEST === null || CIRCLE_PULL_REQUEST === void 0 ? void 0 : CIRCLE_PULL_REQUEST.split('/').pop());
        }
    }
    if (env.TRAVIS) {
        const { TRAVIS_PULL_REQUEST_BRANCH, TRAVIS_BRANCH, TRAVIS_COMMIT, TRAVIS_REPO_SLUG, TRAVIS_TAG, TRAVIS_JOB_WEB_URL, TRAVIS_BUILD_ID, TRAVIS_BUILD_NUMBER, TRAVIS_BUILD_WEB_URL, TRAVIS_BUILD_DIR, TRAVIS_COMMIT_MESSAGE, TRAVIS_EVENT_TYPE, TRAVIS_PULL_REQUEST, TRAVIS_PULL_REQUEST_SHA, } = env;
        tags = {
            [tags_1.CI_JOB_URL]: TRAVIS_JOB_WEB_URL,
            [tags_1.CI_PIPELINE_ID]: TRAVIS_BUILD_ID,
            [tags_1.CI_PIPELINE_NAME]: TRAVIS_REPO_SLUG,
            [tags_1.CI_PIPELINE_NUMBER]: TRAVIS_BUILD_NUMBER,
            [tags_1.CI_PIPELINE_URL]: TRAVIS_BUILD_WEB_URL,
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.TRAVIS,
            [tags_1.CI_WORKSPACE_PATH]: TRAVIS_BUILD_DIR,
            [tags_1.GIT_SHA]: TRAVIS_COMMIT,
            [tags_1.GIT_TAG]: TRAVIS_TAG,
            [tags_1.GIT_BRANCH]: TRAVIS_PULL_REQUEST_BRANCH || TRAVIS_BRANCH,
            [tags_1.GIT_REPOSITORY_URL]: `https://github.com/${TRAVIS_REPO_SLUG}.git`,
            [tags_1.GIT_COMMIT_MESSAGE]: TRAVIS_COMMIT_MESSAGE,
        };
        if (TRAVIS_EVENT_TYPE === 'pull_request') {
            tags[tags_1.PR_NUMBER] = TRAVIS_PULL_REQUEST;
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = (0, utils_1.normalizeRef)(TRAVIS_BRANCH);
            tags[tags_1.GIT_HEAD_SHA] = TRAVIS_PULL_REQUEST_SHA;
        }
    }
    if (env.GITLAB_CI) {
        const { CI_PIPELINE_ID: GITLAB_CI_PIPELINE_ID, CI_PROJECT_PATH, CI_PIPELINE_IID, CI_PIPELINE_URL: GITLAB_CI_PIPELINE_URL, CI_PROJECT_DIR, CI_COMMIT_REF_NAME, CI_COMMIT_TAG, CI_COMMIT_SHA, CI_REPOSITORY_URL, CI_JOB_URL: GITLAB_CI_JOB_URL, CI_JOB_STAGE, CI_JOB_NAME: GITLAB_CI_JOB_NAME, CI_COMMIT_MESSAGE, CI_COMMIT_TIMESTAMP, CI_COMMIT_AUTHOR, CI_JOB_ID: GITLAB_CI_JOB_ID, CI_PROJECT_URL: GITLAB_CI_PROJECT_URL, CI_RUNNER_ID, CI_RUNNER_TAGS, CI_MERGE_REQUEST_IID, CI_MERGE_REQUEST_TARGET_BRANCH_NAME, CI_MERGE_REQUEST_SOURCE_BRANCH_SHA, } = env;
        const { name, email } = parseEmailAndName(CI_COMMIT_AUTHOR);
        tags = {
            [tags_1.CI_JOB_NAME]: GITLAB_CI_JOB_NAME,
            [tags_1.CI_JOB_URL]: GITLAB_CI_JOB_URL,
            [tags_1.CI_PIPELINE_ID]: GITLAB_CI_PIPELINE_ID,
            [tags_1.CI_PIPELINE_NAME]: CI_PROJECT_PATH,
            [tags_1.CI_PIPELINE_NUMBER]: CI_PIPELINE_IID,
            [tags_1.CI_PIPELINE_URL]: GITLAB_CI_PIPELINE_URL,
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.GITLAB,
            [tags_1.CI_WORKSPACE_PATH]: CI_PROJECT_DIR,
            [tags_1.CI_STAGE_NAME]: CI_JOB_STAGE,
            [tags_1.GIT_BRANCH]: CI_COMMIT_REF_NAME,
            [tags_1.GIT_SHA]: CI_COMMIT_SHA,
            [tags_1.GIT_REPOSITORY_URL]: CI_REPOSITORY_URL,
            [tags_1.GIT_TAG]: CI_COMMIT_TAG,
            [tags_1.GIT_COMMIT_MESSAGE]: CI_COMMIT_MESSAGE,
            [tags_1.GIT_COMMIT_AUTHOR_NAME]: name,
            [tags_1.GIT_COMMIT_AUTHOR_EMAIL]: email,
            [tags_1.GIT_COMMIT_AUTHOR_DATE]: CI_COMMIT_TIMESTAMP,
            [tags_1.CI_ENV_VARS]: JSON.stringify({
                CI_PROJECT_URL: GITLAB_CI_PROJECT_URL,
                // Snapshots are generated automatically and are sort sensitive
                CI_PIPELINE_ID: GITLAB_CI_PIPELINE_ID,
                CI_JOB_ID: GITLAB_CI_JOB_ID,
            }),
            [tags_1.CI_NODE_LABELS]: CI_RUNNER_TAGS,
            [tags_1.CI_NODE_NAME]: CI_RUNNER_ID,
        };
        if (CI_MERGE_REQUEST_IID) {
            tags[tags_1.PR_NUMBER] = CI_MERGE_REQUEST_IID;
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = CI_MERGE_REQUEST_TARGET_BRANCH_NAME;
            tags[tags_1.GIT_HEAD_SHA] = CI_MERGE_REQUEST_SOURCE_BRANCH_SHA;
        }
    }
    if (env.GITHUB_ACTIONS || env.GITHUB_ACTION) {
        const { GITHUB_RUN_ID, GITHUB_WORKFLOW, GITHUB_RUN_NUMBER, GITHUB_WORKSPACE, GITHUB_HEAD_REF, GITHUB_JOB, GITHUB_REF, GITHUB_SHA, GITHUB_REPOSITORY, GITHUB_SERVER_URL, GITHUB_RUN_ATTEMPT, DD_GITHUB_JOB_NAME, GITHUB_BASE_REF, } = env;
        const repositoryUrl = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git`;
        let pipelineURL = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}`;
        // Some older versions of enterprise might not have this yet.
        if (GITHUB_RUN_ATTEMPT) {
            pipelineURL += `/attempts/${GITHUB_RUN_ATTEMPT}`;
        }
        tags = {
            [tags_1.CI_JOB_NAME]: GITHUB_JOB,
            [tags_1.CI_JOB_URL]: (0, utils_1.filterSensitiveInfoFromRepository)(`${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA}/checks`),
            [tags_1.CI_PIPELINE_ID]: GITHUB_RUN_ID,
            [tags_1.CI_PIPELINE_NAME]: GITHUB_WORKFLOW,
            [tags_1.CI_PIPELINE_NUMBER]: GITHUB_RUN_NUMBER,
            [tags_1.CI_PIPELINE_URL]: (0, utils_1.filterSensitiveInfoFromRepository)(pipelineURL),
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.GITHUB,
            [tags_1.CI_WORKSPACE_PATH]: GITHUB_WORKSPACE,
            [tags_1.GIT_SHA]: GITHUB_SHA,
            [tags_1.GIT_REPOSITORY_URL]: repositoryUrl,
            [tags_1.GIT_BRANCH]: GITHUB_HEAD_REF || GITHUB_REF || '',
            [tags_1.CI_ENV_VARS]: JSON.stringify({
                GITHUB_SERVER_URL: (0, utils_1.filterSensitiveInfoFromRepository)(GITHUB_SERVER_URL),
                // Snapshots are generated automatically and are sort sensitive
                GITHUB_REPOSITORY,
                GITHUB_RUN_ID,
                GITHUB_RUN_ATTEMPT,
                DD_GITHUB_JOB_NAME,
            }),
        };
        if (GITHUB_BASE_REF) {
            // GITHUB_BASE_REF is defined if it's a pull_request or pull_request_target trigger
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = GITHUB_BASE_REF;
            try {
                const eventPayload = (0, utils_1.getGitHubEventPayload)();
                tags[tags_1.GIT_HEAD_SHA] = (_b = (_a = eventPayload === null || eventPayload === void 0 ? void 0 : eventPayload.pull_request) === null || _a === void 0 ? void 0 : _a.head) === null || _b === void 0 ? void 0 : _b.sha;
                tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA] = (_d = (_c = eventPayload === null || eventPayload === void 0 ? void 0 : eventPayload.pull_request) === null || _c === void 0 ? void 0 : _c.base) === null || _d === void 0 ? void 0 : _d.sha;
                tags[tags_1.PR_NUMBER] = (_f = (_e = eventPayload === null || eventPayload === void 0 ? void 0 : eventPayload.pull_request) === null || _e === void 0 ? void 0 : _e.number) === null || _f === void 0 ? void 0 : _f.toString();
            }
            catch (e) {
                // ignore malformed event content
            }
        }
    }
    if (env.JENKINS_URL) {
        const { WORKSPACE, BUILD_TAG, JOB_NAME, BUILD_NUMBER, BUILD_URL, GIT_BRANCH: JENKINS_GIT_BRANCH, GIT_COMMIT, GIT_URL, GIT_URL_1, DD_CUSTOM_TRACE_ID, DD_CUSTOM_PARENT_ID, NODE_NAME, NODE_LABELS, CHANGE_ID, CHANGE_TARGET, } = env;
        tags = {
            [tags_1.CI_PIPELINE_ID]: BUILD_TAG,
            [tags_1.CI_PIPELINE_NUMBER]: BUILD_NUMBER,
            [tags_1.CI_PIPELINE_URL]: BUILD_URL,
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.JENKINS,
            [tags_1.CI_WORKSPACE_PATH]: WORKSPACE,
            [tags_1.GIT_SHA]: GIT_COMMIT,
            [tags_1.GIT_REPOSITORY_URL]: GIT_URL || GIT_URL_1,
            [tags_1.GIT_BRANCH]: JENKINS_GIT_BRANCH,
            [tags_1.CI_NODE_NAME]: NODE_NAME,
            [tags_1.CI_ENV_VARS]: JSON.stringify({
                DD_CUSTOM_TRACE_ID,
                DD_CUSTOM_PARENT_ID,
            }),
        };
        if (NODE_LABELS) {
            let nodeLabels;
            try {
                nodeLabels = JSON.stringify(NODE_LABELS.split(' '));
                tags[tags_1.CI_NODE_LABELS] = nodeLabels;
            }
            catch (e) {
                // ignore errors
            }
        }
        let finalPipelineName = '';
        if (JOB_NAME) {
            // Job names can contain parameters, e.g. jobName/KEY1=VALUE1,KEY2=VALUE2/branchName
            const jobNameAndParams = JOB_NAME.split('/');
            if (jobNameAndParams.length > 1 && jobNameAndParams[1].includes('=')) {
                finalPipelineName = jobNameAndParams[0];
            }
            else {
                const normalizedBranch = (0, utils_1.normalizeRef)(JENKINS_GIT_BRANCH);
                finalPipelineName = JOB_NAME.replace(`/${normalizedBranch}`, '');
            }
            tags[tags_1.CI_PIPELINE_NAME] = finalPipelineName;
        }
        if (CHANGE_ID) {
            tags[tags_1.PR_NUMBER] = CHANGE_ID;
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = CHANGE_TARGET;
        }
    }
    if (env.BUILDKITE) {
        const { BUILDKITE_AGENT_ID, BUILDKITE_BRANCH, BUILDKITE_COMMIT, BUILDKITE_REPO, BUILDKITE_TAG, BUILDKITE_BUILD_ID, BUILDKITE_PIPELINE_SLUG, BUILDKITE_BUILD_NUMBER, BUILDKITE_BUILD_URL, BUILDKITE_JOB_ID, BUILDKITE_BUILD_CHECKOUT_PATH, BUILDKITE_BUILD_AUTHOR, BUILDKITE_BUILD_AUTHOR_EMAIL, BUILDKITE_MESSAGE, BUILDKITE_PULL_REQUEST, BUILDKITE_PULL_REQUEST_BASE_BRANCH, } = env;
        const extraTags = Object.keys(env)
            .filter((envVar) => envVar.startsWith('BUILDKITE_AGENT_META_DATA_'))
            .map((metadataKey) => {
            const key = metadataKey.replace('BUILDKITE_AGENT_META_DATA_', '').toLowerCase();
            return `${key}:${env[metadataKey]}`;
        });
        tags = {
            [tags_1.CI_NODE_NAME]: BUILDKITE_AGENT_ID,
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.BUILDKITE,
            [tags_1.CI_PIPELINE_ID]: BUILDKITE_BUILD_ID,
            [tags_1.CI_PIPELINE_NAME]: BUILDKITE_PIPELINE_SLUG,
            [tags_1.CI_PIPELINE_NUMBER]: BUILDKITE_BUILD_NUMBER,
            [tags_1.CI_PIPELINE_URL]: BUILDKITE_BUILD_URL,
            [tags_1.CI_JOB_URL]: `${BUILDKITE_BUILD_URL}#${BUILDKITE_JOB_ID}`,
            [tags_1.GIT_SHA]: BUILDKITE_COMMIT,
            [tags_1.CI_WORKSPACE_PATH]: BUILDKITE_BUILD_CHECKOUT_PATH,
            [tags_1.GIT_REPOSITORY_URL]: BUILDKITE_REPO,
            [tags_1.GIT_TAG]: BUILDKITE_TAG,
            [tags_1.GIT_BRANCH]: BUILDKITE_BRANCH,
            [tags_1.GIT_COMMIT_AUTHOR_NAME]: BUILDKITE_BUILD_AUTHOR,
            [tags_1.GIT_COMMIT_AUTHOR_EMAIL]: BUILDKITE_BUILD_AUTHOR_EMAIL,
            [tags_1.GIT_COMMIT_MESSAGE]: BUILDKITE_MESSAGE,
            [tags_1.CI_ENV_VARS]: JSON.stringify({
                BUILDKITE_BUILD_ID,
                BUILDKITE_JOB_ID,
            }),
        };
        if (extraTags.length) {
            tags[tags_1.CI_NODE_LABELS] = JSON.stringify(extraTags);
        }
        if (BUILDKITE_PULL_REQUEST && BUILDKITE_PULL_REQUEST !== 'false') {
            tags[tags_1.PR_NUMBER] = BUILDKITE_PULL_REQUEST;
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = BUILDKITE_PULL_REQUEST_BASE_BRANCH;
        }
    }
    if (env.BITRISE_BUILD_SLUG) {
        const { BITRISE_GIT_COMMIT, GIT_CLONE_COMMIT_HASH, BITRISEIO_GIT_BRANCH_DEST, BITRISE_GIT_BRANCH, BITRISE_BUILD_SLUG, BITRISE_TRIGGERED_WORKFLOW_ID, BITRISE_BUILD_NUMBER, BITRISE_BUILD_URL, BITRISE_SOURCE_DIR, GIT_REPOSITORY_URL: BITRISE_GIT_REPOSITORY_URL, BITRISE_GIT_TAG, BITRISE_GIT_MESSAGE, BITRISE_PULL_REQUEST, } = env;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.BITRISE,
            [tags_1.CI_PIPELINE_ID]: BITRISE_BUILD_SLUG,
            [tags_1.CI_PIPELINE_NAME]: BITRISE_TRIGGERED_WORKFLOW_ID,
            [tags_1.CI_PIPELINE_NUMBER]: BITRISE_BUILD_NUMBER,
            [tags_1.CI_PIPELINE_URL]: BITRISE_BUILD_URL,
            [tags_1.GIT_SHA]: BITRISE_GIT_COMMIT || GIT_CLONE_COMMIT_HASH,
            [tags_1.GIT_REPOSITORY_URL]: BITRISE_GIT_REPOSITORY_URL,
            [tags_1.CI_WORKSPACE_PATH]: BITRISE_SOURCE_DIR,
            [tags_1.GIT_TAG]: BITRISE_GIT_TAG,
            [tags_1.GIT_BRANCH]: BITRISE_GIT_BRANCH,
            [tags_1.GIT_COMMIT_MESSAGE]: BITRISE_GIT_MESSAGE,
        };
        if (BITRISE_PULL_REQUEST) {
            tags[tags_1.PR_NUMBER] = BITRISE_PULL_REQUEST;
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = BITRISEIO_GIT_BRANCH_DEST;
        }
    }
    if (env.BITBUCKET_COMMIT) {
        const { BITBUCKET_REPO_FULL_NAME, BITBUCKET_BUILD_NUMBER, BITBUCKET_BRANCH, BITBUCKET_COMMIT, BITBUCKET_GIT_SSH_ORIGIN, BITBUCKET_GIT_HTTP_ORIGIN, BITBUCKET_TAG, BITBUCKET_PIPELINE_UUID, BITBUCKET_PR_ID, BITBUCKET_PR_DESTINATION_BRANCH, BITBUCKET_CLONE_DIR, } = env;
        const url = `https://bitbucket.org/${BITBUCKET_REPO_FULL_NAME}/addon/pipelines/home#!/results/${BITBUCKET_BUILD_NUMBER}`;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.BITBUCKET,
            [tags_1.GIT_SHA]: BITBUCKET_COMMIT,
            [tags_1.CI_PIPELINE_NUMBER]: BITBUCKET_BUILD_NUMBER,
            [tags_1.CI_PIPELINE_NAME]: BITBUCKET_REPO_FULL_NAME,
            [tags_1.CI_JOB_URL]: url,
            [tags_1.CI_PIPELINE_URL]: url,
            [tags_1.GIT_BRANCH]: BITBUCKET_BRANCH,
            [tags_1.GIT_TAG]: BITBUCKET_TAG,
            [tags_1.GIT_REPOSITORY_URL]: BITBUCKET_GIT_SSH_ORIGIN || BITBUCKET_GIT_HTTP_ORIGIN,
            [tags_1.CI_WORKSPACE_PATH]: BITBUCKET_CLONE_DIR,
            [tags_1.CI_PIPELINE_ID]: BITBUCKET_PIPELINE_UUID && BITBUCKET_PIPELINE_UUID.replace(/{|}/gm, ''),
        };
        if (BITBUCKET_PR_ID) {
            tags[tags_1.PR_NUMBER] = BITBUCKET_PR_ID;
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = BITBUCKET_PR_DESTINATION_BRANCH;
        }
    }
    if (env.CF_BUILD_ID) {
        const { CF_BUILD_ID, CF_PIPELINE_NAME, CF_BUILD_URL, CF_STEP_NAME, CF_BRANCH, CF_PULL_REQUEST_ID, CF_PULL_REQUEST_NUMBER, CF_PULL_REQUEST_TARGET, } = env;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.CODEFRESH,
            [tags_1.CI_PIPELINE_ID]: CF_BUILD_ID,
            [tags_1.CI_PIPELINE_URL]: CF_BUILD_URL,
            [tags_1.CI_PIPELINE_NAME]: CF_PIPELINE_NAME,
            [tags_1.CI_JOB_NAME]: CF_STEP_NAME,
            [tags_1.GIT_BRANCH]: CF_BRANCH,
            [tags_1.CI_ENV_VARS]: JSON.stringify({ CF_BUILD_ID }),
        };
        const isTag = CF_BRANCH && CF_BRANCH.includes('tags/');
        const refKey = isTag ? tags_1.GIT_TAG : tags_1.GIT_BRANCH;
        const ref = (0, utils_1.normalizeRef)(CF_BRANCH);
        tags[refKey] = ref;
        if (CF_PULL_REQUEST_NUMBER || CF_PULL_REQUEST_ID) {
            tags[tags_1.PR_NUMBER] = CF_PULL_REQUEST_NUMBER || CF_PULL_REQUEST_ID;
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = CF_PULL_REQUEST_TARGET;
        }
    }
    if (env.TEAMCITY_VERSION) {
        const { BUILD_URL, TEAMCITY_BUILDCONF_NAME, TEAMCITY_PULLREQUEST_NUMBER, TEAMCITY_PULLREQUEST_TARGET_BRANCH } = env;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.TEAMCITY,
            [tags_1.CI_JOB_URL]: BUILD_URL,
            [tags_1.CI_JOB_NAME]: TEAMCITY_BUILDCONF_NAME,
        };
        if (TEAMCITY_PULLREQUEST_NUMBER) {
            tags[tags_1.PR_NUMBER] = TEAMCITY_PULLREQUEST_NUMBER;
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = TEAMCITY_PULLREQUEST_TARGET_BRANCH;
        }
    }
    if (env.TF_BUILD) {
        const { BUILD_SOURCESDIRECTORY, BUILD_BUILDID, BUILD_DEFINITIONNAME, SYSTEM_TEAMFOUNDATIONSERVERURI, SYSTEM_TEAMPROJECTID, SYSTEM_JOBID, SYSTEM_TASKINSTANCEID, SYSTEM_PULLREQUEST_SOURCEBRANCH, BUILD_SOURCEBRANCH, BUILD_SOURCEBRANCHNAME, SYSTEM_PULLREQUEST_PULLREQUESTNUMBER, SYSTEM_PULLREQUEST_SOURCECOMMITID, SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI, SYSTEM_PULLREQUEST_TARGETBRANCH, BUILD_REPOSITORY_URI, BUILD_SOURCEVERSION, BUILD_REQUESTEDFORID, BUILD_REQUESTEDFOREMAIL, BUILD_SOURCEVERSIONMESSAGE, SYSTEM_STAGEDISPLAYNAME, SYSTEM_JOBDISPLAYNAME, } = env;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.AZURE,
            [tags_1.CI_PIPELINE_ID]: BUILD_BUILDID,
            [tags_1.CI_PIPELINE_NAME]: BUILD_DEFINITIONNAME,
            [tags_1.CI_PIPELINE_NUMBER]: BUILD_BUILDID,
            [tags_1.GIT_SHA]: SYSTEM_PULLREQUEST_SOURCECOMMITID || BUILD_SOURCEVERSION,
            [tags_1.CI_WORKSPACE_PATH]: BUILD_SOURCESDIRECTORY,
            [tags_1.GIT_REPOSITORY_URL]: SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI || BUILD_REPOSITORY_URI,
            [tags_1.GIT_BRANCH]: SYSTEM_PULLREQUEST_SOURCEBRANCH || BUILD_SOURCEBRANCH || BUILD_SOURCEBRANCHNAME,
            [tags_1.GIT_COMMIT_AUTHOR_NAME]: BUILD_REQUESTEDFORID,
            [tags_1.GIT_COMMIT_AUTHOR_EMAIL]: BUILD_REQUESTEDFOREMAIL,
            [tags_1.GIT_COMMIT_MESSAGE]: BUILD_SOURCEVERSIONMESSAGE,
            [tags_1.CI_STAGE_NAME]: SYSTEM_STAGEDISPLAYNAME,
            [tags_1.CI_JOB_NAME]: SYSTEM_JOBDISPLAYNAME,
            [tags_1.CI_ENV_VARS]: JSON.stringify({
                SYSTEM_TEAMPROJECTID,
                BUILD_BUILDID,
                SYSTEM_JOBID,
            }),
        };
        if (SYSTEM_TEAMFOUNDATIONSERVERURI && SYSTEM_TEAMPROJECTID && BUILD_BUILDID) {
            const baseUrl = `${SYSTEM_TEAMFOUNDATIONSERVERURI}${SYSTEM_TEAMPROJECTID}/_build/results?buildId=${BUILD_BUILDID}`;
            const pipelineUrl = baseUrl;
            const jobUrl = `${baseUrl}&view=logs&j=${SYSTEM_JOBID}&t=${SYSTEM_TASKINSTANCEID}`;
            tags = Object.assign(Object.assign({}, tags), { [tags_1.CI_PIPELINE_URL]: pipelineUrl, [tags_1.CI_JOB_URL]: jobUrl });
        }
        if (SYSTEM_PULLREQUEST_PULLREQUESTNUMBER) {
            tags[tags_1.PR_NUMBER] = SYSTEM_PULLREQUEST_PULLREQUESTNUMBER;
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = SYSTEM_PULLREQUEST_TARGETBRANCH === null || SYSTEM_PULLREQUEST_TARGETBRANCH === void 0 ? void 0 : SYSTEM_PULLREQUEST_TARGETBRANCH.replace('refs/heads/', '');
            tags[tags_1.GIT_HEAD_SHA] = SYSTEM_PULLREQUEST_SOURCECOMMITID;
        }
    }
    if (env.APPVEYOR) {
        const { APPVEYOR_REPO_NAME, APPVEYOR_REPO_PROVIDER, APPVEYOR_BUILD_FOLDER, APPVEYOR_BUILD_ID, APPVEYOR_BUILD_NUMBER, APPVEYOR_REPO_COMMIT, APPVEYOR_PULL_REQUEST_HEAD_COMMIT, APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH, APPVEYOR_PULL_REQUEST_NUMBER, APPVEYOR_REPO_BRANCH, APPVEYOR_REPO_TAG_NAME, APPVEYOR_REPO_COMMIT_AUTHOR, APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL, APPVEYOR_REPO_COMMIT_MESSAGE, APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED, } = env;
        const pipelineUrl = `https://ci.appveyor.com/project/${APPVEYOR_REPO_NAME}/builds/${APPVEYOR_BUILD_ID}`;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.APPVEYOR,
            [tags_1.CI_PIPELINE_URL]: pipelineUrl,
            [tags_1.CI_PIPELINE_ID]: APPVEYOR_BUILD_ID,
            [tags_1.CI_PIPELINE_NAME]: APPVEYOR_REPO_NAME,
            [tags_1.CI_PIPELINE_NUMBER]: APPVEYOR_BUILD_NUMBER,
            [tags_1.CI_JOB_URL]: pipelineUrl,
            [tags_1.CI_WORKSPACE_PATH]: APPVEYOR_BUILD_FOLDER,
            [tags_1.GIT_COMMIT_AUTHOR_NAME]: APPVEYOR_REPO_COMMIT_AUTHOR,
            [tags_1.GIT_COMMIT_AUTHOR_EMAIL]: APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL,
            [tags_1.GIT_COMMIT_MESSAGE]: `${APPVEYOR_REPO_COMMIT_MESSAGE || ''}\n${APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED || ''}`,
        };
        if (APPVEYOR_REPO_PROVIDER === 'github') {
            tags = Object.assign(Object.assign({}, tags), { [tags_1.GIT_REPOSITORY_URL]: `https://github.com/${APPVEYOR_REPO_NAME}.git`, [tags_1.GIT_SHA]: APPVEYOR_REPO_COMMIT, [tags_1.GIT_TAG]: APPVEYOR_REPO_TAG_NAME, [tags_1.GIT_BRANCH]: APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH || APPVEYOR_REPO_BRANCH });
        }
        if (APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH) {
            tags[tags_1.PR_NUMBER] = APPVEYOR_PULL_REQUEST_NUMBER;
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = (0, utils_1.normalizeRef)(APPVEYOR_REPO_BRANCH);
            tags[tags_1.GIT_HEAD_SHA] = APPVEYOR_PULL_REQUEST_HEAD_COMMIT;
        }
    }
    if (env.BUDDY) {
        const { BUDDY_PIPELINE_NAME, BUDDY_PIPELINE_ID, BUDDY_EXECUTION_ID, BUDDY_SCM_URL, BUDDY_EXECUTION_BRANCH, BUDDY_EXECUTION_TAG, BUDDY_EXECUTION_REVISION, BUDDY_EXECUTION_URL, BUDDY_EXECUTION_REVISION_MESSAGE, BUDDY_EXECUTION_REVISION_COMMITTER_NAME, BUDDY_EXECUTION_REVISION_COMMITTER_EMAIL, BUDDY_RUN_PR_NO, BUDDY_RUN_PR_BASE_BRANCH, } = env;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.BUDDY,
            [tags_1.CI_PIPELINE_ID]: `${BUDDY_PIPELINE_ID || ''}/${BUDDY_EXECUTION_ID || ''}`,
            [tags_1.CI_PIPELINE_NAME]: BUDDY_PIPELINE_NAME,
            [tags_1.CI_PIPELINE_NUMBER]: `${BUDDY_EXECUTION_ID || ''}`,
            [tags_1.CI_PIPELINE_URL]: BUDDY_EXECUTION_URL,
            [tags_1.GIT_SHA]: BUDDY_EXECUTION_REVISION,
            [tags_1.GIT_BRANCH]: BUDDY_EXECUTION_BRANCH,
            [tags_1.GIT_TAG]: BUDDY_EXECUTION_TAG,
            [tags_1.GIT_REPOSITORY_URL]: BUDDY_SCM_URL,
            [tags_1.GIT_COMMIT_MESSAGE]: BUDDY_EXECUTION_REVISION_MESSAGE,
            [tags_1.GIT_COMMIT_COMMITTER_EMAIL]: BUDDY_EXECUTION_REVISION_COMMITTER_EMAIL,
            [tags_1.GIT_COMMIT_COMMITTER_NAME]: BUDDY_EXECUTION_REVISION_COMMITTER_NAME,
        };
        if (BUDDY_RUN_PR_NO) {
            tags[tags_1.PR_NUMBER] = BUDDY_RUN_PR_NO;
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = BUDDY_RUN_PR_BASE_BRANCH;
        }
    }
    if ((_g = env.CODEBUILD_INITIATOR) === null || _g === void 0 ? void 0 : _g.startsWith('codepipeline')) {
        const { CODEBUILD_BUILD_ARN, DD_ACTION_EXECUTION_ID, DD_PIPELINE_EXECUTION_ID, CODEBUILD_SOURCE_VERSION, CODEBUILD_RESOLVED_SOURCE_VERSION, CODEBUILD_WEBHOOK_BASE_REF, } = env;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.AWSCODEPIPELINE,
            [tags_1.CI_PIPELINE_ID]: DD_PIPELINE_EXECUTION_ID,
            [tags_1.CI_ENV_VARS]: JSON.stringify({ CODEBUILD_BUILD_ARN, DD_PIPELINE_EXECUTION_ID, DD_ACTION_EXECUTION_ID }),
        };
        const prMatch = (CODEBUILD_SOURCE_VERSION !== null && CODEBUILD_SOURCE_VERSION !== void 0 ? CODEBUILD_SOURCE_VERSION : '').match(/^pr\/(\d+)$/);
        if (prMatch) {
            tags[tags_1.PR_NUMBER] = prMatch === null || prMatch === void 0 ? void 0 : prMatch[1];
            tags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH] = CODEBUILD_WEBHOOK_BASE_REF;
            tags[tags_1.GIT_HEAD_SHA] = CODEBUILD_RESOLVED_SOURCE_VERSION;
        }
    }
    if (tags[tags_1.CI_WORKSPACE_PATH]) {
        tags[tags_1.CI_WORKSPACE_PATH] = resolveTilde(tags[tags_1.CI_WORKSPACE_PATH]);
    }
    if (tags[tags_1.GIT_REPOSITORY_URL]) {
        tags[tags_1.GIT_REPOSITORY_URL] = (0, utils_1.filterSensitiveInfoFromRepository)(tags[tags_1.GIT_REPOSITORY_URL]);
    }
    if (tags[tags_1.GIT_TAG]) {
        tags[tags_1.GIT_TAG] = (0, utils_1.normalizeRef)(tags[tags_1.GIT_TAG]);
    }
    if (tags[tags_1.GIT_BRANCH]) {
        // Here we handle the case where GIT_BRANCH actually contains a tag
        const branch = tags[tags_1.GIT_BRANCH] || '';
        if (branch.startsWith('tags/') || branch.includes('/tags/')) {
            if (!tags[tags_1.GIT_TAG]) {
                tags[tags_1.GIT_TAG] = (0, utils_1.normalizeRef)(branch);
            }
            tags[tags_1.GIT_BRANCH] = '';
        }
        else {
            tags[tags_1.GIT_BRANCH] = (0, utils_1.normalizeRef)(branch);
        }
    }
    return (0, utils_1.removeEmptyValues)(tags);
};
exports.getCISpanTags = getCISpanTags;
const getCIMetadata = (tagSizeLimits) => {
    const tags = Object.assign(Object.assign(Object.assign({}, (0, exports.getCISpanTags)()), (0, user_provided_git_1.getUserCISpanTags)()), (0, user_provided_git_1.getUserGitSpanTags)());
    if (!tags || !Object.keys(tags).length) {
        return;
    }
    if (tagSizeLimits) {
        for (const key of Object.keys(tagSizeLimits)) {
            const tagToLimit = key;
            const originalTag = tags[tagToLimit];
            if (!!originalTag) {
                tags[tagToLimit] = originalTag.substring(0, tagSizeLimits[tagToLimit]);
            }
        }
    }
    const metadata = {
        ci: (0, utils_1.removeUndefinedValues)({
            job: (0, utils_1.removeUndefinedValues)({
                name: tags[tags_1.CI_JOB_NAME],
                url: tags[tags_1.CI_JOB_URL],
            }),
            pipeline: (0, utils_1.removeUndefinedValues)({
                id: tags[tags_1.CI_PIPELINE_ID],
                name: tags[tags_1.CI_PIPELINE_NAME],
                number: parseNumber(tags[tags_1.CI_PIPELINE_NUMBER]),
                url: tags[tags_1.CI_PIPELINE_URL],
            }),
            provider: (0, utils_1.removeUndefinedValues)({
                name: tags[tags_1.CI_PROVIDER_NAME],
            }),
            stage: (0, utils_1.removeUndefinedValues)({
                name: tags[tags_1.CI_STAGE_NAME],
            }),
            workspace_path: tags[tags_1.CI_WORKSPACE_PATH],
        }),
        git: (0, utils_1.removeUndefinedValues)({
            branch: tags[tags_1.GIT_BRANCH],
            commit: (0, utils_1.removeUndefinedValues)({
                author: (0, utils_1.removeUndefinedValues)({
                    date: tags[tags_1.GIT_COMMIT_AUTHOR_DATE],
                    email: tags[tags_1.GIT_COMMIT_AUTHOR_EMAIL],
                    name: tags[tags_1.GIT_COMMIT_AUTHOR_NAME],
                }),
                committer: (0, utils_1.removeUndefinedValues)({
                    date: tags[tags_1.GIT_COMMIT_COMMITTER_DATE],
                    email: tags[tags_1.GIT_COMMIT_COMMITTER_EMAIL],
                    name: tags[tags_1.GIT_COMMIT_COMMITTER_NAME],
                }),
                message: tags[tags_1.GIT_COMMIT_MESSAGE],
                sha: tags[tags_1.GIT_SHA],
            }),
            repository_url: tags[tags_1.GIT_REPOSITORY_URL],
            tag: tags[tags_1.GIT_TAG],
        }),
    };
    return metadata;
};
exports.getCIMetadata = getCIMetadata;
const parseNumber = (numberStr) => {
    if (numberStr) {
        const number = parseInt(numberStr, 10);
        return isFinite(number) ? number : undefined;
    }
};
const getCIEnv = () => {
    if (process.env.CIRCLECI) {
        return {
            ciEnv: filterEnv(['CIRCLE_WORKFLOW_ID', 'CIRCLE_BUILD_NUM']),
            provider: 'circleci',
        };
    }
    if (process.env.GITLAB_CI) {
        return {
            ciEnv: filterEnv(['CI_PROJECT_URL', 'CI_PIPELINE_ID', 'CI_JOB_ID']),
            provider: 'gitlab',
        };
    }
    if (process.env.GITHUB_ACTIONS || process.env.GITHUB_ACTION) {
        return {
            ciEnv: filterEnv([
                'GITHUB_SERVER_URL',
                'GITHUB_REPOSITORY',
                'GITHUB_RUN_ID',
                'GITHUB_RUN_ATTEMPT',
                'GITHUB_JOB',
                'DD_GITHUB_JOB_NAME',
            ]),
            provider: 'github',
        };
    }
    if (process.env.BUILDKITE) {
        return {
            ciEnv: filterEnv(['BUILDKITE_BUILD_ID', 'BUILDKITE_JOB_ID']),
            provider: 'buildkite',
        };
    }
    if (process.env.TEAMCITY_VERSION) {
        return {
            ciEnv: filterEnv(['DATADOG_BUILD_ID']),
            provider: 'teamcity',
        };
    }
    if (process.env.JENKINS_URL) {
        return {
            ciEnv: filterEnv(['DD_CUSTOM_PARENT_ID', 'DD_CUSTOM_TRACE_ID']),
            provider: 'jenkins',
        };
    }
    if (process.env.TF_BUILD) {
        return {
            ciEnv: filterEnv(['SYSTEM_TEAMPROJECTID', 'BUILD_BUILDID', 'SYSTEM_JOBID']),
            provider: 'azurepipelines',
        };
    }
    throw new Error('Only providers [GitHub, GitLab, CircleCI, Buildkite, Jenkins, TeamCity, AzurePipelines] are supported');
};
exports.getCIEnv = getCIEnv;
const getCIProvider = () => {
    var _a;
    if (process.env.CIRCLECI) {
        return exports.CI_ENGINES.CIRCLECI;
    }
    if (process.env.GITLAB_CI) {
        return exports.CI_ENGINES.GITLAB;
    }
    if (process.env.GITHUB_ACTIONS || process.env.GITHUB_ACTION) {
        return exports.CI_ENGINES.GITHUB;
    }
    if (process.env.BUILDKITE) {
        return exports.CI_ENGINES.BUILDKITE;
    }
    if (process.env.BUDDY) {
        return exports.CI_ENGINES.BUDDY;
    }
    if (process.env.TEAMCITY_VERSION) {
        return exports.CI_ENGINES.TEAMCITY;
    }
    if (process.env.JENKINS_URL) {
        return exports.CI_ENGINES.JENKINS;
    }
    if (process.env.TF_BUILD) {
        return exports.CI_ENGINES.AZURE;
    }
    if (process.env.CF_BUILD_ID) {
        return exports.CI_ENGINES.CODEFRESH;
    }
    if (process.env.APPVEYOR) {
        return exports.CI_ENGINES.APPVEYOR;
    }
    if (process.env.BITBUCKET_COMMIT) {
        return exports.CI_ENGINES.BITBUCKET;
    }
    if (process.env.BITRISE_BUILD_SLUG) {
        return exports.CI_ENGINES.BITRISE;
    }
    if ((_a = process.env.CODEBUILD_INITIATOR) === null || _a === void 0 ? void 0 : _a.startsWith('codepipeline')) {
        return exports.CI_ENGINES.AWSCODEPIPELINE;
    }
    return 'unknown';
};
exports.getCIProvider = getCIProvider;
const filterEnv = (values) => {
    const ciEnvs = {};
    const requiredMissing = [];
    values.forEach((envKey) => {
        const envValue = process.env[envKey];
        if (envValue) {
            ciEnvs[envKey] = envValue;
        }
        else if (!envAllowedToBeMissing.includes(envKey)) {
            requiredMissing.push(envKey);
        }
    });
    if (requiredMissing.length > 0) {
        // Get the missing values for better error
        throw new Error(`Missing environment variables [${requiredMissing.toString()}]`);
    }
    return ciEnvs;
};
const isInteractive = ({ stream = process.stdout } = {}) => {
    return Boolean(!('CI' in process.env) && process.env.TERM !== 'dumb' && stream && stream.isTTY);
};
exports.isInteractive = isInteractive;
//# sourceMappingURL=ci.js.map