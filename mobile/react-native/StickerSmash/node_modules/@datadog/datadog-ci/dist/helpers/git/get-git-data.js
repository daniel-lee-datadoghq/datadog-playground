"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.gitLocalCommitShas = exports.gitRepositoryURL = exports.gitAuthorAndCommitter = exports.gitMessage = exports.gitCurrentBranch = exports.gitBranch = exports.gitTrackedFiles = exports.gitHash = exports.stripCredentials = exports.getDefaultRemoteName = exports.gitRemote = void 0;
const url_1 = require("url");
// Returns the remote of the current repository.
const gitRemote = (git) => __awaiter(void 0, void 0, void 0, function* () {
    const remotes = yield git.getRemotes(true);
    if (remotes.length === 0) {
        throw new Error('No git remotes available');
    }
    const defaultRemote = yield (0, exports.getDefaultRemoteName)(git);
    for (const remote of remotes) {
        if (remote.name === defaultRemote) {
            return (0, exports.stripCredentials)(remote.refs.push);
        }
    }
    // Falling back to picking the first remote in the list if the default remote is not found.
    return (0, exports.stripCredentials)(remotes[0].refs.push);
});
exports.gitRemote = gitRemote;
const getDefaultRemoteName = (git) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    try {
        return (_b = (_a = (yield git.getConfig('clone.defaultRemoteName'))) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 'origin';
    }
    catch (e) {
        return 'origin';
    }
});
exports.getDefaultRemoteName = getDefaultRemoteName;
// StripCredentials removes credentials from a remote HTTP url.
const stripCredentials = (remote) => {
    try {
        const url = new url_1.URL(remote);
        url.username = '';
        url.password = '';
        return url.toString();
    }
    catch (_a) {
        return remote;
    }
};
exports.stripCredentials = stripCredentials;
// Returns the hash of the current repository.
const gitHash = (git) => __awaiter(void 0, void 0, void 0, function* () { return git.revparse('HEAD'); });
exports.gitHash = gitHash;
// Returns the tracked files of the current repository.
const gitTrackedFiles = (git) => __awaiter(void 0, void 0, void 0, function* () {
    const files = yield git.raw('ls-files');
    return files.split(/\r\n|\r|\n/);
});
exports.gitTrackedFiles = gitTrackedFiles;
const gitBranch = (git) => __awaiter(void 0, void 0, void 0, function* () { return git.branch(); });
exports.gitBranch = gitBranch;
const gitCurrentBranch = (git) => __awaiter(void 0, void 0, void 0, function* () {
    const branch = yield git.raw(['branch', '--show-current']);
    return branch.trim();
});
exports.gitCurrentBranch = gitCurrentBranch;
const gitMessage = (git) => __awaiter(void 0, void 0, void 0, function* () { return git.show(['-s', '--format=%s']); });
exports.gitMessage = gitMessage;
// Returns the author and committer information of the current commit in JSON format to avoid parsing issues with values that contain commas.
const gitAuthorAndCommitter = (git) => __awaiter(void 0, void 0, void 0, function* () {
    return git.show([
        '-s',
        '--format={"authorName":"%an","authorEmail":"%ae","authorDate":"%aI","committerName":"%cn","committerEmail":"%ce","committerDate":"%cI"}',
    ]);
});
exports.gitAuthorAndCommitter = gitAuthorAndCommitter;
const gitRepositoryURL = (git) => __awaiter(void 0, void 0, void 0, function* () { return git.listRemote(['--get-url']).then((url) => url.trim()); });
exports.gitRepositoryURL = gitRepositoryURL;
const gitLocalCommitShas = (git, branchName) => __awaiter(void 0, void 0, void 0, function* () {
    const gitShas = yield git.raw(['log', branchName, '--not', '--remotes', '--format=%H', '-n', '10']);
    return gitShas.split(/\r\n|\r|\n/).filter(Boolean); // split by new line and discarding empty lines
});
exports.gitLocalCommitShas = gitLocalCommitShas;
//# sourceMappingURL=get-git-data.js.map