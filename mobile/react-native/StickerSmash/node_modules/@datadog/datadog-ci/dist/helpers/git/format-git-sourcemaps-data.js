"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrackedFilesMatcher = exports.getRepositoryData = exports.newSimpleGit = void 0;
const fs_1 = __importDefault(require("fs"));
const simpleGit = __importStar(require("simple-git"));
const get_git_data_1 = require("./get-git-data");
// Returns a configured SimpleGit.
const newSimpleGit = () => __awaiter(void 0, void 0, void 0, function* () {
    const options = {
        baseDir: process.cwd(),
        binary: 'git',
        // We are invoking at most 3 git commands at the same time.
        maxConcurrentProcesses: 3,
    };
    try {
        // Attempt to set the baseDir to the root of the repository so the 'git ls-files' command
        // returns the tracked files paths relative to the root of the repository.
        const git = simpleGit.simpleGit(options);
        const root = yield git.revparse('--show-toplevel');
        options.baseDir = root;
    }
    catch (_a) {
        // Ignore exception as it will fail if we are not inside a git repository.
    }
    return simpleGit.simpleGit(options);
});
exports.newSimpleGit = newSimpleGit;
// Returns the current hash and remote as well as a TrackedFilesMatcher.
//
// To obtain the list of tracked files paths tied to a specific sourcemap, invoke the 'matchSourcemap' method.
const getRepositoryData = (git, repositoryURL) => __awaiter(void 0, void 0, void 0, function* () {
    // Invoke git commands to retrieve the remote, hash and tracked files.
    // We're using Promise.all instead of Promise.allSettled since we want to fail early if
    // any of the promises fails.
    let remote;
    let hash;
    let trackedFiles;
    try {
        if (repositoryURL) {
            ;
            [hash, trackedFiles] = yield Promise.all([(0, get_git_data_1.gitHash)(git), (0, get_git_data_1.gitTrackedFiles)(git)]);
            remote = repositoryURL;
        }
        else {
            ;
            [remote, hash, trackedFiles] = yield Promise.all([(0, get_git_data_1.gitRemote)(git), (0, get_git_data_1.gitHash)(git), (0, get_git_data_1.gitTrackedFiles)(git)]);
        }
    }
    catch (e) {
        throw e;
    }
    const data = {
        hash,
        remote,
        trackedFilesMatcher: new TrackedFilesMatcher(trackedFiles),
    };
    return data;
});
exports.getRepositoryData = getRepositoryData;
// TrackedFilesMatcher can compute the list of tracked files related to a particular sourcemap.
// The current implementation simply returns all tracked files whose filename is found inside
// the sourcemap 'sources' field.
// It is used so that we don't send every tracked files to the backend since most won't be of any use
// for a particular sourcemap.
class TrackedFilesMatcher {
    constructor(trackedFiles) {
        this.trackedFilenames = new Map();
        for (const f of trackedFiles) {
            const filename = this.getFilename(f);
            const list = this.trackedFilenames.get(filename);
            if (list) {
                list.push(f);
            }
            else {
                this.trackedFilenames.set(filename, new Array(f));
            }
        }
    }
    // Looks up the sources declared in the sourcemap and return a list of related tracked files.
    matchSourcemap(srcmapPath, onSourcesNotFound) {
        const buff = fs_1.default.readFileSync(srcmapPath, 'utf8');
        const srcmapObj = JSON.parse(buff);
        if (!srcmapObj.sources) {
            return undefined;
        }
        const sources = srcmapObj.sources;
        if (!sources || sources.length === 0) {
            return undefined;
        }
        const filtered = this.matchSources(sources);
        if (filtered.length === 0) {
            onSourcesNotFound();
            return undefined;
        }
        return filtered;
    }
    matchSources(sources) {
        let filtered = [];
        const filenameAlreadyMatched = new Set();
        for (const source of sources) {
            const filename = this.getFilename(source);
            if (filenameAlreadyMatched.has(filename)) {
                continue;
            }
            filenameAlreadyMatched.add(filename);
            const trackedFiles = this.trackedFilenames.get(filename);
            if (trackedFiles) {
                filtered = filtered.concat(trackedFiles);
            }
        }
        return filtered;
    }
    // Return a list of all tracked files
    rawTrackedFilesList() {
        let rawList = [];
        this.trackedFilenames.forEach((value) => {
            rawList = rawList.concat(value);
        });
        return rawList;
    }
    // Extract the filename from a path.
    //
    // We are removing any suffix that is after the character '?'. The only reason this is done
    // is because we noticed that a non-negligible (~5%) amount of source paths from our customers
    // source maps contained query parameters.
    // We are assuming that the files may not actually be named with the interrogation mark but that
    // it is only an artifact of the build process. The query parameters look random. It looks
    // like it may be used as a trick to force a web browser to reload the file content.
    // The only side effect of doing that operation is that more tracked files paths may be sent
    // alongside the sourcemap which is not a problem.
    // Example: webpack:///./src/folder/ui/select.vue?821e
    getFilename(s) {
        let start = s.lastIndexOf('/');
        if (start === -1) {
            start = 0;
        }
        else {
            start++;
        }
        let end = s.lastIndexOf('?');
        if (end === -1 || end <= start) {
            end = s.length;
        }
        return s.substring(start, end);
    }
}
exports.TrackedFilesMatcher = TrackedFilesMatcher;
//# sourceMappingURL=format-git-sourcemaps-data.js.map