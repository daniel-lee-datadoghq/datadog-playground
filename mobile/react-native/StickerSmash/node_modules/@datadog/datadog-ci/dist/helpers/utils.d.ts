import type { SpanTags } from './interfaces';
import type { AxiosRequestConfig } from 'axios';
import { BaseContext, CommandClass } from 'clipanion';
import { ProxyAgent } from 'proxy-agent';
export declare const DEFAULT_CONFIG_PATHS: string[];
type TerminalLink<URL extends string> = (strings: TemplateStringsArray) => string & {
    targetUrl: URL;
};
export declare const makeTerminalLink: <URL_1 extends string>(url: URL_1) => TerminalLink<URL_1>;
export declare const pick: <T extends Record<any, any>, K extends keyof T>(base: T, keys: K[]) => Partial<T>;
export declare const getConfig: (configPath: string) => Promise<Record<string, unknown> | undefined>;
/**
 * Applies configurations in this order of priority:
 * environment > config file > base config
 */
export declare const resolveConfigFromFileAndEnvironment: <T extends Record<string, unknown>, U extends Record<string, unknown>>(baseConfig: T, environment: U, params: {
    configPath?: string | undefined;
    defaultConfigPaths?: string[] | undefined;
    configFromFileCallback?: ((configFromFile: any) => void) | undefined;
}) => Promise<T & U>;
export declare const resolveConfigFromFile: <T>(baseConfig: T, params: {
    configPath?: string;
    defaultConfigPaths?: string[];
}) => Promise<T>;
type ProxyType = 'http' | 'https' | 'socks' | 'socks4' | 'socks4a' | 'socks5' | 'socks5h' | 'pac+data' | 'pac+file' | 'pac+ftp' | 'pac+http' | 'pac+https';
export interface ProxyConfiguration {
    auth?: {
        password: string;
        username: string;
    };
    host?: string;
    port?: number;
    protocol: ProxyType;
}
export declare const getProxyUrl: (options?: ProxyConfiguration) => string;
export interface RequestOptions {
    apiKey: string;
    appKey?: string;
    baseUrl: string;
    headers?: Map<string, string>;
    overrideUrl?: string;
    proxyOpts?: ProxyConfiguration;
}
export declare const getRequestBuilder: (options: RequestOptions) => (args: AxiosRequestConfig) => Promise<import("axios").AxiosResponse<any, any>>;
export declare const getProxyAgent: (proxyOpts?: ProxyConfiguration) => ProxyAgent;
export declare const getApiHostForSite: (site: string) => string;
export declare const buildPath: (...args: string[]) => string;
export declare const removeEmptyValues: (tags: SpanTags) => {};
export declare const removeUndefinedValues: <T extends {
    [key: string]: unknown;
}>(object: T) => T;
export declare const recursivelyRemoveUndefinedValues: <T extends Record<string, unknown>>(object: T) => Partial<T>;
export declare const normalizeRef: (ref: string | undefined) => string | undefined;
export declare const pluralize: (nb: number, singular: string, plural: string) => string;
export declare const performSubCommand: (command: CommandClass<BaseContext>, commandArgs: string[], context: BaseContext) => Promise<number>;
export declare const filterSensitiveInfoFromRepository: (repositoryUrl: string | undefined) => string | undefined;
export declare const filterAndFormatGithubRemote: (rawRemote: string | undefined) => string | undefined;
export declare const timedExecAsync: <I, O>(f: (input: I) => Promise<O>, input: I) => Promise<number>;
/**
 * Convert bytes to a formatted string in KB, MB, GB, etc.
 * Note: Lambda documentation uses MB (instead of Mib) to refer to 1024 KB, so we follow that style here
 * @param bytes
 * @param decimals
 */
export declare const formatBytes: (bytes: number, decimals?: number) => string;
export declare const maskString: (value?: string) => string;
export declare const execute: (cmd: string, cwd?: string) => Promise<{
    stderr: string;
    stdout: string;
}>;
type GitHubWebhookPayload = {
    pull_request?: {
        head?: {
            sha: string;
        };
        base?: {
            sha: string;
        };
        number?: number;
    };
};
export declare const getGitHubEventPayload: () => GitHubWebhookPayload | undefined;
export declare const isFile: (path: string) => boolean;
export {};
