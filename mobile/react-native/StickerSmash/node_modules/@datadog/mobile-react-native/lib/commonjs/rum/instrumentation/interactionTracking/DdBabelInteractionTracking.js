"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DdBabelInteractionTracking = void 0;
var _InternalLog = require("../../../InternalLog");
var _SdkVerbosity = require("../../../SdkVerbosity");
var _NativeDdRum = _interopRequireDefault(require("../../../specs/NativeDdRum"));
var _NativeDdSdk = _interopRequireDefault(require("../../../specs/NativeDdSdk"));
var _telemetry = require("../../../utils/telemetry");
var _DefaultTimeProvider = require("../../../utils/time-provider/DefaultTimeProvider");
var _constants = require("../../constants");
var _types = require("../../types");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2016-Present Datadog, Inc.
 */

const StateErrors = {
  ALREADY_INITIALIZED: 'Interaction Tracking singleton already initialized, please use `getInstance`.'
};
class DdBabelInteractionTracking {
  static instance = null;
  static config = {
    trackInteractions: false,
    useAccessibilityLabel: true
  };
  timeProvider = new _DefaultTimeProvider.DefaultTimeProvider();
  telemetrySent = false;
  isInitialized = false;
  constructor() {
    if (DdBabelInteractionTracking.instance) {
      throw new Error(StateErrors.ALREADY_INITIALIZED);
    }
    DdBabelInteractionTracking.instance = this;
  }
  static getInstance() {
    if (!DdBabelInteractionTracking.instance) {
      DdBabelInteractionTracking.instance = new DdBabelInteractionTracking();
    }
    return DdBabelInteractionTracking.instance;
  }
  getTargetName(targetObject) {
    const {
      componentName,
      'dd-action-name': actionName,
      accessibilityLabel,
      ...attrs
    } = targetObject;
    const {
      useAccessibilityLabel
    } = DdBabelInteractionTracking.config;
    if (actionName) {
      return actionName;
    }
    const keys = Object.keys(attrs);
    if (keys.length) {
      return attrs[keys[0]];
    }
    if (useAccessibilityLabel && accessibilityLabel) {
      return accessibilityLabel;
    }
    return componentName;
  }
  wrapRumAction(func, action, targetObject) {
    return (...args) => {
      const result = func(...args);
      if (!this.telemetrySent) {
        _NativeDdSdk.default?.sendTelemetryLog(_constants.BABEL_PLUGIN_TELEMETRY, (0, _telemetry.getBabelTelemetryConfig)(), {
          onlyOnce: true
        });
        this.telemetrySent = true;
      }
      const targetName = this.getTargetName(targetObject);
      const {
        trackInteractions
      } = DdBabelInteractionTracking.config;
      if (trackInteractions) {
        _InternalLog.InternalLog.log(`Adding RUM Action “${targetName}” (${action}, auto)`, _SdkVerbosity.SdkVerbosity.DEBUG);
        _NativeDdRum.default?.addAction(action, targetName, {
          '__dd.action_source': _types.ActionSource.BABEL
        }, this.timeProvider.now());
      }
      return result;
    };
  }
}
exports.DdBabelInteractionTracking = DdBabelInteractionTracking;
//# sourceMappingURL=DdBabelInteractionTracking.js.map