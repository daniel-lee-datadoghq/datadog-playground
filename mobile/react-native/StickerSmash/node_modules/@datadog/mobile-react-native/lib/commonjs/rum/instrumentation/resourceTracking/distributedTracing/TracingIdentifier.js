"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TracingIdentifier = exports.TracingIdType = exports.TracingIdFormat = void 0;
var _bigInteger = _interopRequireDefault(require("big-integer"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2016-Present Datadog, Inc.
 */
/**
 * Available formats for representing the {@link TracingIdentifier} as a string.
 */
let TracingIdFormat = exports.TracingIdFormat = /*#__PURE__*/function (TracingIdFormat) {
  /**
   * Decimal string representation of the full tracing id.
   */
  TracingIdFormat[TracingIdFormat["decimal"] = 0] = "decimal";
  /**
   * The low bits of the tracing id as a decimal.
   */
  TracingIdFormat[TracingIdFormat["lowDecimal"] = 1] = "lowDecimal";
  /**
   * The high bits of the tracing id as a decimal.
   */
  TracingIdFormat[TracingIdFormat["highDecimal"] = 2] = "highDecimal";
  /**
   * Hexadecimal string representation of the full tracing id.
   */
  TracingIdFormat[TracingIdFormat["hex"] = 3] = "hex";
  /**
   * Hexadecimal string representation of the low bits of the tracing id.
   */
  TracingIdFormat[TracingIdFormat["lowHex"] = 4] = "lowHex";
  /**
   * Hexadecimal string representation of the high bits of the tracing id.
   */
  TracingIdFormat[TracingIdFormat["highHex"] = 5] = "highHex";
  /**
   * Padded hexadecimal string representation of the full tracing id.
   */
  TracingIdFormat[TracingIdFormat["paddedHex"] = 6] = "paddedHex";
  /**
   * Padded hexadecimal string representation of the low bits of the tracing id.
   */
  TracingIdFormat[TracingIdFormat["paddedLowHex"] = 7] = "paddedLowHex";
  /**
   * Padded hexadecimal string representation of the high bits of the tracing id.
   */
  TracingIdFormat[TracingIdFormat["paddedHighHex"] = 8] = "paddedHighHex";
  return TracingIdFormat;
}({});
/**
 * A {@link TracingIdentifier} used for Traces (128 bit).
 */
/**
 * A {@link TracingIdentifier} used for Spans (64 bit).
 */
/**
 * The tracing identifier type.
 */
let TracingIdType = exports.TracingIdType = /*#__PURE__*/function (TracingIdType) {
  /**
   * 128-bit UUID.
   */
  TracingIdType[TracingIdType["trace"] = 0] = "trace";
  /**
   * 64-bit UUID.
   */
  TracingIdType[TracingIdType["span"] = 1] = "span";
  return TracingIdType;
}({});
/**
 * Value used to mask the low 64 bits of the trace identifier.
 */
const LOW_64BIT_MASK = (0, _bigInteger.default)('ffffffff', 16).shiftLeft(32).add((0, _bigInteger.default)('ffffffff', 16));

/**
 * Value used to mask the low 32 bits of the trace identifier.
 */
const LOW_32BIT_MASK = (0, _bigInteger.default)('ffff', 16).shiftLeft(16).add((0, _bigInteger.default)('ffff', 16));

/**
 * A {@link TracingIdentifier} is a unique UUID that can be 64bit or 128bit, and provides
 * convenient methods to represent it as a HEX or DECIMAL string, and it allows the masking
 * of its low or high bits.
 *
 * Create a new identifier by calling {@link TracingIdentifier.createTraceId()} or
 * {@link TracingIdentifier.createSpanId()}.
 */
class TracingIdentifier {
  /**
   * Read-only generated ID as a {@link BigInteger}.
   */

  /**
   * Read-only type to determine whether the identifier is a {@link TraceId} or a {@link SpanId}.
   */

  /**
   * Creates a new unique Trace ID.
   * @returns the generated {@link TraceId}.
   */
  static createTraceId() {
    return new TracingIdentifier(TracingIdType.trace);
  }

  /**
   * Creates a new unique Span ID.
   * @returns the generated {@link SpanId}.
   */
  static createSpanId() {
    return new TracingIdentifier(TracingIdType.span);
  }

  /**
   * Private constructor to initialize the {@link TracingIdentifier} based on the given
   * {@link TracingIdType}.
   */
  constructor(type) {
    this.id = this.generateUUID(type);
    this.type = type;
  }

  /**
   * Generates a unique ID with the given format.
   * @param format - the desired format (64bit or 128bit).
   * @returns the generated UUID as a {@link BigInteger}.
   */
  generateUUID(type) {
    // Get the current Unix timestamp in seconds
    const unixSeconds = Math.floor(Date.now() / 1000);

    // Ensure the Unix timestamp is 32 bits
    const unixSeconds32 = unixSeconds & 0xffffffff;

    // 32 bits of zero
    const zeros32 = 0;

    // Generate 64 random bits using Math.random()
    const random32Bit1 = Math.floor(Math.random() * 0xffffffff);
    const random32Bit2 = Math.floor(Math.random() * 0xffffffff);
    const random64Hex = random32Bit1.toString(16).padStart(8, '0') + random32Bit2.toString(16).padStart(8, '0');

    // If type is 'span' we return the generated 64 bit ID
    if (type === TracingIdType.span) {
      return (0, _bigInteger.default)(random64Hex, 16);
    }

    // Convert parts to hexadecimal strings
    const unixSecondsHex = unixSeconds32.toString(16).padStart(8, '0');
    const zerosHex = zeros32.toString(16).padStart(8, '0');

    // Combine parts to form the 128-bit ID
    const hex128BitID = unixSecondsHex + zerosHex + random64Hex;
    return (0, _bigInteger.default)(hex128BitID, 16);
  }

  /**
   * Returns a string representation of the Tracing ID.
   * @param format - The type of representation to use.
   * @returns The ID as a string in the specified representation type.
   */
  toString(format) {
    const lowTraceMask = this.type === TracingIdType.trace ? LOW_64BIT_MASK : LOW_32BIT_MASK;
    const highTraceMask = this.type === TracingIdType.trace ? (0, _bigInteger.default)(64) : (0, _bigInteger.default)(32);
    const padding = this.type === TracingIdType.trace ? 32 : 16;
    switch (format) {
      case TracingIdFormat.decimal:
        return this.id.toString(10);
      case TracingIdFormat.lowDecimal:
        return this.id.and(lowTraceMask).toString(10);
      case TracingIdFormat.highDecimal:
        return this.id.shiftRight(highTraceMask).toString(10);
      case TracingIdFormat.hex:
        return this.id.toString(16);
      case TracingIdFormat.lowHex:
        return this.id.and(lowTraceMask).toString(16);
      case TracingIdFormat.highHex:
        return this.id.shiftRight(highTraceMask).toString(16);
      case TracingIdFormat.paddedHex:
        return this.toString(TracingIdFormat.hex).padStart(padding, '0');
      case TracingIdFormat.paddedLowHex:
        return this.toString(TracingIdFormat.lowHex).padStart(padding / 2, '0');
      case TracingIdFormat.paddedHighHex:
        return this.toString(TracingIdFormat.highHex).padStart(padding / 2, '0');
    }
  }
}
exports.TracingIdentifier = TracingIdentifier;
//# sourceMappingURL=TracingIdentifier.js.map