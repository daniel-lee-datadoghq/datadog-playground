"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getErrorStackTrace = exports.getErrorName = exports.getErrorMessage = exports.getErrorContext = exports.EMPTY_STACK_TRACE = exports.EMPTY_MESSAGE = exports.DEFAULT_ERROR_NAME = void 0;
var _debugIdResolver = require("../metro/debugIdResolver");
/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2016-Present Datadog, Inc.
 */

const EMPTY_MESSAGE = exports.EMPTY_MESSAGE = 'Unknown Error';
const EMPTY_STACK_TRACE = exports.EMPTY_STACK_TRACE = '';
const DEFAULT_ERROR_NAME = exports.DEFAULT_ERROR_NAME = 'Error';
const getErrorMessage = error => {
  let message = EMPTY_MESSAGE;
  if (error === undefined || error === null) {
    message = EMPTY_MESSAGE;
  } else if (typeof error === 'object' && 'message' in error) {
    message = String(error.message);
  } else {
    message = String(error);
  }
  return message;
};

/**
 * Will extract the stack from the error, taking the first key found among:
 * `stacktrace`, `stack`, `componentStack` (component tree for component errors,
 * which contains only native components names in production).
 *
 * In last resort and if `sourceURL`, `line` and `column` are present, it will
 * generate a stack from this information.
 */
exports.getErrorMessage = getErrorMessage;
const getErrorStackTrace = error => {
  let stack = EMPTY_STACK_TRACE;
  try {
    if (error === undefined || error === null) {
      stack = EMPTY_STACK_TRACE;
    } else if (typeof error === 'string') {
      stack = EMPTY_STACK_TRACE;
    } else if (typeof error === 'object') {
      if ('stacktrace' in error) {
        stack = String(error.stacktrace);
      } else if ('stack' in error) {
        stack = String(error.stack);
      } else if ('componentStack' in error) {
        stack = String(error.componentStack);
      } else if ('sourceURL' in error && 'line' in error && 'column' in error) {
        stack = `at ${error.sourceURL}:${error.line}:${error.column}`;
      }
    }
  } catch (e) {
    // Do nothing
  }
  return stack;
};
exports.getErrorStackTrace = getErrorStackTrace;
const getErrorName = error => {
  try {
    if (typeof error !== 'object' || error === null) {
      return DEFAULT_ERROR_NAME;
    }
    if (typeof error.name === 'string') {
      return error.name;
    }
  } catch (e) {
    // Do nothing
  }
  return DEFAULT_ERROR_NAME;
};
exports.getErrorName = getErrorName;
const getErrorContext = originalContext => {
  const _debugId = _debugIdResolver.debugId;
  if (!_debugId) {
    return originalContext;
  }
  return {
    ...originalContext,
    '_dd.debug_id': _debugId
  };
};
exports.getErrorContext = getErrorContext;
//# sourceMappingURL=errorUtils.js.map