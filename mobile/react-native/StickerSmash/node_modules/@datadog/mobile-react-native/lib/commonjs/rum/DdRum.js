"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DdRum = void 0;
var _InternalLog = require("../InternalLog");
var _SdkVerbosity = require("../SdkVerbosity");
var _bufferNativeCall = require("../sdk/DatadogProvider/Buffer/bufferNativeCall");
var _DdSdk = require("../sdk/DdSdk");
var _GlobalState = require("../sdk/GlobalState/GlobalState");
var _argsUtils = require("../utils/argsUtils");
var _errorUtils = require("../utils/errorUtils");
var _DefaultTimeProvider = require("../utils/time-provider/DefaultTimeProvider");
var _DdAttributes = require("./DdAttributes");
var _actionEventMapper = require("./eventMappers/actionEventMapper");
var _errorEventMapper = require("./eventMappers/errorEventMapper");
var _resourceEventMapper = require("./eventMappers/resourceEventMapper");
var _DatadogTracingIdentifier = require("./instrumentation/resourceTracking/distributedTracing/DatadogTracingIdentifier");
var _TracingIdentifier = require("./instrumentation/resourceTracking/distributedTracing/TracingIdentifier");
var _distributedTracingHeaders = require("./instrumentation/resourceTracking/distributedTracing/distributedTracingHeaders");
var _sessionIdHelper = require("./sessionId/sessionIdHelper");
/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2016-Present Datadog, Inc.
 */

const generateEmptyPromise = () => new Promise(resolve => resolve());
class DdRumWrapper {
  // eslint-disable-next-line global-require, @typescript-eslint/no-var-requires
  nativeRum = require('../specs/NativeDdRum').default;
  errorEventMapper = (0, _errorEventMapper.generateErrorEventMapper)(undefined);
  resourceEventMapper = (0, _resourceEventMapper.generateResourceEventMapper)(undefined);
  actionEventMapper = (0, _actionEventMapper.generateActionEventMapper)(undefined);
  timeProvider = new _DefaultTimeProvider.DefaultTimeProvider();
  startView = (key, name, context = {}, timestampMs = this.timeProvider.now()) => {
    _InternalLog.InternalLog.log(`Starting RUM View “${name}” #${key}`, _SdkVerbosity.SdkVerbosity.DEBUG);
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.startView(key, name, (0, _argsUtils.validateContext)(context), timestampMs));
  };
  stopView = (key, context = {}, timestampMs = this.timeProvider.now()) => {
    _InternalLog.InternalLog.log(`Stopping RUM View #${key}`, _SdkVerbosity.SdkVerbosity.DEBUG);
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.stopView(key, (0, _argsUtils.validateContext)(context), timestampMs));
  };
  startAction = (type, name, context = {}, timestampMs = this.timeProvider.now()) => {
    _InternalLog.InternalLog.log(`Starting RUM Action “${name}” (${type})`, _SdkVerbosity.SdkVerbosity.DEBUG);
    this.lastActionData = {
      type,
      name
    };
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.startAction(type, name, (0, _argsUtils.validateContext)(context), timestampMs));
  };
  stopAction = (...args) => {
    _InternalLog.InternalLog.log('Stopping current RUM Action', _SdkVerbosity.SdkVerbosity.DEBUG);
    const nativeCallArgs = this.getStopActionNativeCallArgs(args);
    this.lastActionData = undefined;
    if (!nativeCallArgs) {
      return generateEmptyPromise();
    }
    return this.callNativeStopAction(...nativeCallArgs);
  };
  setTimeProvider = timeProvider => {
    this.timeProvider = timeProvider;
  };
  addAction = (type, name, context = {}, timestampMs = this.timeProvider.now(), actionContext) => {
    const mappedEvent = this.actionEventMapper.applyEventMapper({
      type,
      name,
      context: (0, _argsUtils.validateContext)(context),
      timestampMs,
      actionContext
    });
    if (!mappedEvent) {
      return generateEmptyPromise();
    }
    _InternalLog.InternalLog.log(`Adding RUM Action “${name}” (${type})`, _SdkVerbosity.SdkVerbosity.DEBUG);
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.addAction(mappedEvent.type, mappedEvent.name, mappedEvent.context, mappedEvent.timestampMs));
  };
  startResource = (key, method, url, context = {}, timestampMs = this.timeProvider.now()) => {
    _InternalLog.InternalLog.log(`Starting RUM Resource #${key} ${method}: ${url}`, _SdkVerbosity.SdkVerbosity.DEBUG);
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.startResource(key, method, url, (0, _argsUtils.validateContext)(context), timestampMs));
  };
  stopResource = (key, statusCode, kind, size = -1, context = {}, timestampMs = this.timeProvider.now(), resourceContext) => {
    const mappedEvent = this.resourceEventMapper.applyEventMapper({
      key,
      statusCode,
      kind,
      size,
      context: (0, _argsUtils.validateContext)(context),
      timestampMs,
      resourceContext
    });
    if (!mappedEvent) {
      /**
       * To drop the resource we call `stopResource` and pass the `_dd.drop_resource` attribute in the context.
       * It will be picked up by the resource mappers we implement on the native side that will drop the resource.
       * This ensures we don't have any "started" resource left in memory on the native side.
       */
      return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.stopResource(key, statusCode, kind, size, {
        '_dd.resource.drop_resource': true
      }, timestampMs));
    }
    _InternalLog.InternalLog.log(`Stopping RUM Resource #${key} status:${statusCode}`, _SdkVerbosity.SdkVerbosity.DEBUG);
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.stopResource(mappedEvent.key, mappedEvent.statusCode, mappedEvent.kind, mappedEvent.size, mappedEvent.context, mappedEvent.timestampMs));
  };
  addError = (message, source, stacktrace, context = {}, timestampMs = this.timeProvider.now(), fingerprint) => {
    const mappedEvent = this.errorEventMapper.applyEventMapper({
      message,
      source,
      stacktrace,
      context: (0, _errorUtils.getErrorContext)((0, _argsUtils.validateContext)(context)),
      timestampMs,
      fingerprint: fingerprint ?? ''
    });
    if (!mappedEvent) {
      return generateEmptyPromise();
    }
    _InternalLog.InternalLog.log(`Adding RUM Error “${message}”`, _SdkVerbosity.SdkVerbosity.DEBUG);
    const updatedContext = mappedEvent.context;
    updatedContext[_DdAttributes.DdAttributes.errorSourceType] = 'react-native';
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.addError(mappedEvent.message, mappedEvent.source, mappedEvent.stacktrace, updatedContext, mappedEvent.timestampMs, mappedEvent.fingerprint));
  };
  addTiming = name => {
    _InternalLog.InternalLog.log(`Adding timing “${name}” to RUM View`, _SdkVerbosity.SdkVerbosity.DEBUG);
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.addTiming(name));
  };
  addViewLoadingTime = overwrite => {
    _InternalLog.InternalLog.log(overwrite ? 'Adding and overwriting view loading to RUM View' : 'Adding view loading to RUM View', _SdkVerbosity.SdkVerbosity.DEBUG);
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.addViewLoadingTime(overwrite));
  };
  stopSession = () => {
    _InternalLog.InternalLog.log('Stopping RUM Session', _SdkVerbosity.SdkVerbosity.DEBUG);
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.stopSession());
  };
  addFeatureFlagEvaluation = (name, value) => {
    _InternalLog.InternalLog.log(`Adding feature flag evaluation for name: ${name} with value: ${JSON.stringify(value)}`, _SdkVerbosity.SdkVerbosity.DEBUG);
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.addFeatureFlagEvaluation(name, {
      value
    }));
  };
  async getCurrentSessionId() {
    if (!_GlobalState.GlobalState.instance.isInitialized) {
      return undefined;
    }
    const sessionId = await this.nativeRum.getCurrentSessionId();
    if (sessionId) {
      (0, _sessionIdHelper.setCachedSessionId)(sessionId);
    }
    return sessionId;
  }
  getTracingContext = (url, tracingSamplingRate, firstPartyHosts) => {
    return (0, _distributedTracingHeaders.getTracingContext)(url, tracingSamplingRate, firstPartyHosts, (0, _sessionIdHelper.getCachedSessionId)());
  };
  getTracingContextForPropagators = (propagators, tracingSamplingRate) => {
    return (0, _distributedTracingHeaders.getTracingContextForPropagators)(propagators, tracingSamplingRate, (0, _sessionIdHelper.getCachedSessionId)());
  };
  generateTraceId() {
    return new _DatadogTracingIdentifier.DatadogTracingIdentifier(_TracingIdentifier.TracingIdentifier.createTraceId());
  }
  generateSpanId() {
    return new _DatadogTracingIdentifier.DatadogTracingIdentifier(_TracingIdentifier.TracingIdentifier.createSpanId());
  }
  registerErrorEventMapper(errorEventMapper) {
    this.errorEventMapper = (0, _errorEventMapper.generateErrorEventMapper)(errorEventMapper);
  }
  unregisterErrorEventMapper() {
    this.errorEventMapper = (0, _errorEventMapper.generateErrorEventMapper)(undefined);
  }
  registerResourceEventMapper(resourceEventMapper) {
    this.resourceEventMapper = (0, _resourceEventMapper.generateResourceEventMapper)(resourceEventMapper);
  }
  unregisterResourceEventMapper() {
    this.resourceEventMapper = (0, _resourceEventMapper.generateResourceEventMapper)(undefined);
  }
  registerActionEventMapper(actionEventMapper) {
    this.actionEventMapper = (0, _actionEventMapper.generateActionEventMapper)(actionEventMapper);
  }
  unregisterActionEventMapper() {
    this.actionEventMapper = (0, _actionEventMapper.generateActionEventMapper)(undefined);
  }
  callNativeStopAction = (type, name, context, timestampMs) => {
    const mappedEvent = this.actionEventMapper.applyEventMapper({
      type,
      name,
      context: (0, _argsUtils.validateContext)(context),
      timestampMs
    });
    if (!mappedEvent) {
      return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.stopAction(type, name, {
        '_dd.action.drop_action': true
      }, timestampMs));
    }
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.stopAction(mappedEvent.type, mappedEvent.name, mappedEvent.context, mappedEvent.timestampMs));
  };
  getStopActionNativeCallArgs = args => {
    if (isNewStopActionAPI(args)) {
      return [args[0], args[1], (0, _argsUtils.validateContext)(args[2]), args[3] || this.timeProvider.now()];
    }
    if (isOldStopActionAPI(args)) {
      if (this.lastActionData) {
        _DdSdk.DdSdk.telemetryDebug('DDdRum.stopAction called with the old signature');
        const {
          type,
          name
        } = this.lastActionData;
        return [type, name, (0, _argsUtils.validateContext)(args[0]), args[1] || this.timeProvider.now()];
      }
      _InternalLog.InternalLog.log('DdRum.startAction needs to be called before DdRum.stopAction', _SdkVerbosity.SdkVerbosity.WARN);
    } else {
      _InternalLog.InternalLog.log('DdRum.stopAction was called with wrong arguments', _SdkVerbosity.SdkVerbosity.WARN);
    }
    return null;
  };
}
const isNewStopActionAPI = args => {
  return typeof args[0] === 'string';
};
const isOldStopActionAPI = args => {
  return typeof args[0] === 'object' || typeof args[0] === 'undefined';
};
const DdRum = exports.DdRum = new DdRumWrapper();
//# sourceMappingURL=DdRum.js.map