"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResourceReporter = void 0;
var _DdRum = require("../../../../../DdRum");
var _TracingIdentifier = require("../../../distributedTracing/TracingIdentifier");
var _resourceTiming = require("./resourceTiming");
/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2016-Present Datadog, Inc.
 */

class ResourceReporter {
  constructor(resourceMappers) {
    this.mappers = resourceMappers;
  }
  reportResource = resource => {
    let modifiedResource = resource;
    for (const mapper of this.mappers) {
      modifiedResource = mapper(resource);
      if (modifiedResource === null) {
        return;
      }
    }
    reportResource(modifiedResource);
  };
}
exports.ResourceReporter = ResourceReporter;
const formatResourceStartContext = tracingAttributes => {
  const attributes = {};
  if (tracingAttributes.samplingPriorityHeader !== '0') {
    attributes['_dd.span_id'] = tracingAttributes.spanId.toString(_TracingIdentifier.TracingIdFormat.decimal);
    attributes['_dd.trace_id'] = tracingAttributes.traceId.toString(_TracingIdentifier.TracingIdFormat.paddedHex);
    attributes['_dd.rule_psr'] = tracingAttributes.rulePsr;
  }
  return attributes;
};
const formatResourceStopContext = (timings, graphqlAttributes) => {
  const attributes = {};
  if (timings.responseStartTime !== undefined) {
    attributes['_dd.resource_timings'] = (0, _resourceTiming.createTimings)(timings.startTime, timings.responseStartTime, timings.stopTime);
  }
  if (graphqlAttributes?.operationType) {
    attributes['_dd.graphql.operation_type'] = graphqlAttributes.operationType;
    if (graphqlAttributes.operationName) {
      attributes['_dd.graphql.operation_name'] = graphqlAttributes.operationName;
    }
    if (graphqlAttributes.variables) {
      attributes['_dd.graphql.variables'] = graphqlAttributes.variables;
    }
  }
  return attributes;
};
const reportResource = async resource => {
  await _DdRum.DdRum.startResource(resource.key, resource.request.method, resource.request.url, formatResourceStartContext(resource.tracingAttributes), resource.timings.startTime);
  _DdRum.DdRum.stopResource(resource.key, resource.response.statusCode, resource.request.kind, resource.response.size, formatResourceStopContext(resource.timings, resource.graphqlAttributes), resource.timings.stopTime, resource.resourceContext);
};
//# sourceMappingURL=ResourceReporter.js.map