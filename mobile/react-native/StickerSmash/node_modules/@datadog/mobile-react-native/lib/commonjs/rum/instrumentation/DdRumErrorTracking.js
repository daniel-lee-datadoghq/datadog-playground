"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DdRumErrorTracking = void 0;
var _InternalLog = require("../../InternalLog");
var _SdkVerbosity = require("../../SdkVerbosity");
var _DdLogs = require("../../logs/DdLogs");
var _errorUtils = require("../../utils/errorUtils");
var _jsUtils = require("../../utils/jsUtils");
var _DdRum = require("../DdRum");
var _types = require("../types");
/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2016-Present Datadog, Inc.
 */

/**
 * Provides RUM auto-instrumentation feature to track errors as RUM events.
 */
class DdRumErrorTracking {
  static isTracking = false;
  static isInDefaultErrorHandler = false;

  // eslint-disable-next-line
  static defaultErrorHandler = (_error, _isFatal) => {};

  // eslint-disable-next-line
  static defaultConsoleError = (..._params) => {};

  /**
   * Starts tracking errors and sends a RUM Error event every time an error is detected.
   */
  static startTracking() {
    // extra safety to avoid wrapping the Error handler twice
    if (DdRumErrorTracking.isTracking) {
      _InternalLog.InternalLog.log('Datadog SDK is already tracking errors', _SdkVerbosity.SdkVerbosity.WARN);
      return;
    }
    if (ErrorUtils) {
      DdRumErrorTracking.defaultErrorHandler = ErrorUtils.getGlobalHandler();
      DdRumErrorTracking.defaultConsoleError = console.error;
      ErrorUtils.setGlobalHandler(DdRumErrorTracking.onGlobalError);
      console.error = DdRumErrorTracking.onConsoleError;
      DdRumErrorTracking.isTracking = true;
      _InternalLog.InternalLog.log('Datadog SDK is tracking errors', _SdkVerbosity.SdkVerbosity.INFO);
    } else {
      _InternalLog.InternalLog.log('Datadog SDK cannot track errors, ErrorUtils is not defined', _SdkVerbosity.SdkVerbosity.ERROR);
    }
  }
  static onGlobalError = (error, isFatal) => {
    const message = (0, _errorUtils.getErrorMessage)(error);
    const stacktrace = (0, _errorUtils.getErrorStackTrace)(error);
    const errorName = (0, _errorUtils.getErrorName)(error);
    this.reportError(message, _types.ErrorSource.SOURCE, stacktrace, errorName, {
      '_dd.error.is_crash': isFatal,
      '_dd.error.raw': error
    }).then(async () => {
      DdRumErrorTracking.isInDefaultErrorHandler = true;
      try {
        // On real iOS devices, the crash context is not updated soon
        // enough for the view update to contain the crash.
        // Waiting for 50ms has low impact and ensures the crash context
        // is updated before actually crashing the app.
        await (0, _jsUtils.executeWithDelay)(() => DdRumErrorTracking.defaultErrorHandler(error, isFatal), 50);
      } finally {
        DdRumErrorTracking.isInDefaultErrorHandler = false;
      }
    });
  };
  static onConsoleError = (...params) => {
    if (DdRumErrorTracking.isInDefaultErrorHandler) {
      return;
    }
    let stack = _errorUtils.EMPTY_STACK_TRACE;
    let errorName = _errorUtils.DEFAULT_ERROR_NAME;
    for (let i = 0; i < params.length; i += 1) {
      const param = params[i];
      const paramStack = (0, _errorUtils.getErrorStackTrace)(param);
      if (paramStack !== _errorUtils.EMPTY_STACK_TRACE) {
        stack = paramStack;
      }
      const paramErrorName = (0, _errorUtils.getErrorName)(param);
      if (paramErrorName !== _errorUtils.DEFAULT_ERROR_NAME) {
        errorName = paramErrorName;
      }
      if (errorName !== _errorUtils.DEFAULT_ERROR_NAME && stack !== _errorUtils.EMPTY_STACK_TRACE) {
        break;
      }
    }
    const message = params.map(param => {
      if (typeof param === 'string') {
        return param;
      } else {
        return (0, _errorUtils.getErrorMessage)(param);
      }
    }).join(' ');
    this.reportError(message, _types.ErrorSource.CONSOLE, stack, errorName).then(() => {
      DdRumErrorTracking.defaultConsoleError.apply(console, params);
    });
  };
  static reportError = (message, source, stacktrace, errorName, context = {}) => {
    return Promise.all([_DdRum.DdRum.addError(message, source, stacktrace, (0, _errorUtils.getErrorContext)(context)), _DdLogs.DdLogs.error(message, errorName, message, stacktrace, {
      ...context,
      '_dd.error_log.is_crash': true
    }, undefined, source)]);
  };
}
exports.DdRumErrorTracking = DdRumErrorTracking;
//# sourceMappingURL=DdRumErrorTracking.js.map