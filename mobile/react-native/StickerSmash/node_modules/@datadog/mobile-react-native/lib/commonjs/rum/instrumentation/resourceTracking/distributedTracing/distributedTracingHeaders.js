"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTracingHeadersFromAttributes = exports.getTracingContextForPropagators = exports.getTracingContext = exports.TRACE_ID_HEADER_KEY = exports.TRACESTATE_HEADER_KEY = exports.TRACECONTEXT_HEADER_KEY = exports.TAGS_HEADER_KEY = exports.SAMPLING_PRIORITY_HEADER_KEY = exports.PARENT_ID_HEADER_KEY = exports.ORIGIN_RUM = exports.ORIGIN_HEADER_KEY = exports.DD_TRACE_ID_TAG = exports.DD_RUM_SESSION_ID_TAG = exports.BAGGAGE_HEADER_KEY = exports.B3_MULTI_TRACE_ID_HEADER_KEY = exports.B3_MULTI_SPAN_ID_HEADER_KEY = exports.B3_MULTI_SAMPLED_HEADER_KEY = exports.B3_HEADER_KEY = void 0;
var _types = require("../../../types");
var _URLHostParser = require("../requestProxy/XHRProxy/URLHostParser");
var _DatadogTracingContext = require("./DatadogTracingContext");
var _TracingIdentifier = require("./TracingIdentifier");
var _distributedTracing = require("./distributedTracing");
var _firstPartyHosts = require("./firstPartyHosts");
/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2016-Present Datadog, Inc.
 */

const SAMPLING_PRIORITY_HEADER_KEY = exports.SAMPLING_PRIORITY_HEADER_KEY = 'x-datadog-sampling-priority';
/**
 * Datadog headers
 */
const ORIGIN_HEADER_KEY = exports.ORIGIN_HEADER_KEY = 'x-datadog-origin';
const ORIGIN_RUM = exports.ORIGIN_RUM = 'rum';
const TRACE_ID_HEADER_KEY = exports.TRACE_ID_HEADER_KEY = 'x-datadog-trace-id';
const PARENT_ID_HEADER_KEY = exports.PARENT_ID_HEADER_KEY = 'x-datadog-parent-id';
const TAGS_HEADER_KEY = exports.TAGS_HEADER_KEY = 'x-datadog-tags';
const DD_TRACE_ID_TAG = exports.DD_TRACE_ID_TAG = '_dd.p.tid';
const DD_RUM_SESSION_ID_TAG = exports.DD_RUM_SESSION_ID_TAG = 'session.id';

/**
 * OTel headers
 */
const TRACECONTEXT_HEADER_KEY = exports.TRACECONTEXT_HEADER_KEY = 'traceparent';
const TRACESTATE_HEADER_KEY = exports.TRACESTATE_HEADER_KEY = 'tracestate';
const BAGGAGE_HEADER_KEY = exports.BAGGAGE_HEADER_KEY = 'baggage';
const B3_HEADER_KEY = exports.B3_HEADER_KEY = 'b3';
const B3_MULTI_TRACE_ID_HEADER_KEY = exports.B3_MULTI_TRACE_ID_HEADER_KEY = 'X-B3-TraceId';
const B3_MULTI_SPAN_ID_HEADER_KEY = exports.B3_MULTI_SPAN_ID_HEADER_KEY = 'X-B3-SpanId';
const B3_MULTI_SAMPLED_HEADER_KEY = exports.B3_MULTI_SAMPLED_HEADER_KEY = 'X-B3-Sampled';
const getTracingHeadersFromAttributes = tracingAttributes => {
  const headers = [];
  if (tracingAttributes.tracingStrategy === 'DISCARD') {
    return headers;
  }
  tracingAttributes.propagatorTypes.forEach(propagator => {
    switch (propagator) {
      case _types.PropagatorType.DATADOG:
        {
          headers.push({
            header: ORIGIN_HEADER_KEY,
            value: ORIGIN_RUM
          }, {
            header: SAMPLING_PRIORITY_HEADER_KEY,
            value: tracingAttributes.samplingPriorityHeader
          }, {
            header: TRACE_ID_HEADER_KEY,
            value: tracingAttributes.traceId.toString(_TracingIdentifier.TracingIdFormat.lowDecimal)
          }, {
            header: PARENT_ID_HEADER_KEY,
            value: tracingAttributes.spanId.toString(_TracingIdentifier.TracingIdFormat.decimal)
          });
          headers.push({
            header: TAGS_HEADER_KEY,
            value: `${DD_TRACE_ID_TAG}=${tracingAttributes.traceId.toString(_TracingIdentifier.TracingIdFormat.paddedHighHex)}`
          });
          break;
        }
      case _types.PropagatorType.TRACECONTEXT:
        {
          const isSampled = tracingAttributes.samplingPriorityHeader === '1';
          headers.push({
            header: TRACECONTEXT_HEADER_KEY,
            value: generateTraceContextHeader({
              version: '00',
              traceId: tracingAttributes.traceId,
              parentId: tracingAttributes.spanId,
              isSampled
            })
          }, {
            header: TRACESTATE_HEADER_KEY,
            value: generateTraceStateHeader({
              parentId: tracingAttributes.spanId,
              isSampled
            })
          });
          break;
        }
      case _types.PropagatorType.B3:
        {
          headers.push({
            header: B3_HEADER_KEY,
            value: generateB3Header({
              traceId: tracingAttributes.traceId,
              spanId: tracingAttributes.spanId,
              isSampled: tracingAttributes.samplingPriorityHeader === '1'
            })
          });
          break;
        }
      case _types.PropagatorType.B3MULTI:
        {
          headers.push({
            header: B3_MULTI_TRACE_ID_HEADER_KEY,
            value: tracingAttributes.traceId.toString(_TracingIdentifier.TracingIdFormat.paddedHex)
          }, {
            header: B3_MULTI_SPAN_ID_HEADER_KEY,
            value: tracingAttributes.spanId.toString(_TracingIdentifier.TracingIdFormat.paddedHex)
          }, {
            header: B3_MULTI_SAMPLED_HEADER_KEY,
            value: tracingAttributes.samplingPriorityHeader
          });
        }
    }
    if (tracingAttributes.rumSessionId) {
      headers.push({
        header: BAGGAGE_HEADER_KEY,
        value: `${DD_RUM_SESSION_ID_TAG}=${tracingAttributes.rumSessionId}`
      });
    }
  });
  return headers;
};
exports.getTracingHeadersFromAttributes = getTracingHeadersFromAttributes;
const getTracingContext = (url, tracingSamplingRate, firstPartyHosts, rumSessionId) => {
  const hostname = (0, _URLHostParser.URLHostParser)(url);
  const firstPartyHostsRegexMap = (0, _firstPartyHosts.firstPartyHostsRegexMapBuilder)(firstPartyHosts);
  const tracingAttributes = (0, _distributedTracing.getTracingAttributes)({
    hostname,
    firstPartyHostsRegexMap,
    tracingSamplingRate,
    rumSessionId
  });
  return getTracingContextForAttributes(tracingAttributes, tracingSamplingRate);
};
exports.getTracingContext = getTracingContext;
const getTracingContextForPropagators = (propagators, tracingSamplingRate, rumSessionId) => {
  return getTracingContextForAttributes((0, _distributedTracing.generateTracingAttributesWithSampling)(tracingSamplingRate, propagators, rumSessionId), tracingSamplingRate);
};
exports.getTracingContextForPropagators = getTracingContextForPropagators;
const getTracingContextForAttributes = (tracingAttributes, tracingSamplingRate) => {
  const requestHeaders = getTracingHeadersFromAttributes(tracingAttributes);
  const resourceContext = {};
  const spanId = tracingAttributes.spanId;
  if (spanId) {
    resourceContext['_dd.span_id'] = spanId.toString(_TracingIdentifier.TracingIdFormat.decimal);
  }
  const traceId = tracingAttributes.traceId;
  if (traceId) {
    resourceContext['_dd.trace_id'] = traceId.toString(_TracingIdentifier.TracingIdFormat.paddedHex);
  }
  resourceContext['_dd.rule_psr'] = tracingSamplingRate / 100;
  return new _DatadogTracingContext.DatadogTracingContext(requestHeaders, resourceContext, tracingAttributes.traceId, tracingAttributes.spanId);
};
const generateTraceContextHeader = ({
  version,
  traceId,
  parentId,
  isSampled
}) => {
  const flags = isSampled ? '01' : '00';
  return `${version}-${traceId.toString(_TracingIdentifier.TracingIdFormat.paddedHex)}-${parentId.toString(_TracingIdentifier.TracingIdFormat.paddedHex)}-${flags}`;
};
const generateTraceStateHeader = ({
  parentId,
  isSampled
}) => {
  const sampled = `s:${isSampled ? '1' : '0'}`;
  const origin = 'o:rum';
  const parent = `p:${parentId.toString(_TracingIdentifier.TracingIdFormat.paddedHex)}`;
  return `dd=${sampled};${origin};${parent}`;
};
const generateB3Header = ({
  traceId,
  spanId,
  isSampled
}) => {
  return [traceId.toString(_TracingIdentifier.TracingIdFormat.paddedHex), spanId.toString(_TracingIdentifier.TracingIdFormat.paddedHex), isSampled ? '1' : '0'].join('-');
};
//# sourceMappingURL=distributedTracingHeaders.js.map