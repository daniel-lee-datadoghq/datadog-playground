/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2016-Present Datadog, Inc.
 */

import { DefaultTimeProvider } from './time-provider/DefaultTimeProvider';
const START_LABEL = '__start';
const STOP_LABEL = '__stop';

/**
 * Simple timer which records time ticks. Shouldn't be re-used once stopped.
 * All timestamps/durations returned are in milliseconds.
 */
export class Timer {
  times = {};
  constructor(timeProvider = new DefaultTimeProvider()) {
    this.timeProvider = timeProvider;
  }
  get startTime() {
    return this.times[START_LABEL].unix;
  }
  get stopTime() {
    return this.startTime + this.durationBetween(START_LABEL, STOP_LABEL);
  }
  start() {
    this.recordTick(START_LABEL);
  }
  stop() {
    this.recordTick(STOP_LABEL);
  }
  recordTick(label) {
    this.times[label] = this.timeProvider.getTimestamp();
  }
  hasTickFor(label) {
    return label in this.times;
  }
  durationBetween(startLabel, endLabel) {
    this.checkLabelExists(startLabel);
    this.checkLabelExists(endLabel);
    const startTick = this.times[startLabel];
    const endTick = this.times[endLabel];
    return this.durationBetweenTicks(startTick, endTick);
  }
  timeAt(label) {
    this.checkLabelExists(label);
    return this.startTime + this.durationBetween(START_LABEL, label);
  }
  reset() {
    this.times = {};
  }
  durationBetweenTicks(start, end) {
    if (start.reactNative != null && end.reactNative != null) {
      return end.reactNative - start.reactNative;
    }
    return end.unix - start.unix;
  }
  checkLabelExists(label) {
    if (!this.hasTickFor(label)) {
      throw new Error(`Label ${label} is not registered`);
    }
  }
}
//# sourceMappingURL=Timer.js.map