import type { Bundle, MixedOutput, Module, MetroBundleWithMap, DatadogDebugIdModule } from './types/metroTypes';
/**
 * Path name for the Debug ID Metro Virtual Module.
 */
export declare const DEBUG_ID_MODULE_PATH = "__datadog_debugid__";
/**
 * The initial placeholder for the injected Debug ID in the virtual module, replaced
 * later by the actual Debug ID.
 */
export declare const DEBUG_ID_PLACEHOLDER = "__datadog_debug_id_placeholder__";
/**
 * A comment that can be found at the end of the JS bundle, to specify the URL of the sourcemap.
 * Ref: https://tc39.es/ecma426/#sec-linking-inline
 */
export declare const SOURCE_MAP_COMMENT = "//# sourceMappingURL=";
/**
 * The comment that will be appended at the end of the JS bundle, to specify the Debug ID.
 * Ref: https://github.com/tc39/ecma426/blob/main/proposals/debug-id.md
 */
export declare const DEBUG_ID_COMMENT = "//# debugId=";
/**
 * Creates a virtual module to embed a debug ID into the bundle.
 * @param debugId - the debug ID to inject into the bundle, or a placeholder.
 * @returns The Debug ID virtual module.
 */
export declare const createDebugIdModule: (debugId: string) => DatadogDebugIdModule;
/**
 * Injects the debug ID module into the list of pre-modules,
 * ensuring that the prelude module (if present) stays at the top
 * to correctly measure bundle startup time.
 */
export declare const addDebugIdModule: (preModules: readonly Module<MixedOutput>[], debugIdModule: DatadogDebugIdModule) => Module<MixedOutput>[];
/**
 * Creates a minified JavaScript snippet that exposes the provided Debug ID
 * on the global scope at runtime.
 *
 * @param debugId - The Debug ID to be injected into the global scope.
 * @returns A minified JavaScript string that performs the injection.
 */
export declare const createDebugIdSnippet: (debugId: string) => string;
/**
 * Extracts the Debug ID from a bundle source string by locating the pattern
 * "{@link DEBUG_ID_METADATA_PREFIX}`[DEBUG-ID]`"
 *
 * @param code - The source code of the bundle to search within.
 * @returns The extracted Debug ID, or `undefined` if not found.
 */
export declare const getDebugIdFromBundleSource: (code: string) => string | undefined;
/**
 * Creates a unique Debug ID from the given bundle, by using the content of its modules.
 * @param bundle The bundle to create the Debug ID from.
 * @returns The computed Debug ID.
 */
export declare const createDebugIdFromBundle: (bundle: Bundle) => string;
/**
 * Creates a unique Debug ID from the given string.
 * Ref: https://github.com/expo/expo/blob/94a124894a355ad6e24f4bac5144986380686157/packages/%40expo/metro-config/src/serializer/debugId.ts#L15
 * @param str The string to create the Debug ID from.
 * @returns The computed Debug ID.
 */
export declare const createDebugIdFromString: (str: string) => string;
/**
 * Injects the given debug ID in the given code, and returns the modified code.
 *
 * It looks for a specific placeholder defined in {@link DEBUG_ID_PLACEHOLDER}, and replaces
 * all its occurences with the given Debug ID.
 * @param code The code to inject the Debug ID into.
 * @param debugId The Debug ID to inject.
 * @returns The modified code with the injected Debug ID.
 */
export declare const injectDebugIdInCode: (code: string, debugId: string) => string;
/**
 * Injects the given Debug ID in the given code (as a comment at the end of the file), and in the
 * given sourcemap (as a top-level JSON property).
 * @param debugId The Debug ID to inject.
 * @param code The code to inject the Debug ID in.
 * @param sourcemap The sourcemap to inject the Debug ID in.
 * @returns The modified {@link MetroBundleWithMap} with the Debug ID
 */
export declare const injectDebugIdInCodeAndSourceMap: (debugId: string, code: string, sourcemap: string) => MetroBundleWithMap;
/**
 * [INTERNAL] Checks if the debug ID is in the bundle, and prints a warning if it does not match the given one.
 */
export declare const _isDebugIdInBundle: (debugId: string, bundleCode: string) => boolean;
/**
 * Checks if the virtual Debug ID module exists in the given modules.
 * @param modules - The list of modules in which to look for the Debug ID.
 * @returns `true` if the Debug ID module exists, `false` otherwise.
 */
export declare const checkIfDebugIdModuleExists: (modules: readonly Module[]) => boolean;
/**
 * [INTERNAL] Replaces the existing Debug ID comment in the bundle with a new one, containing the given Debug ID.
 */
export declare const _replaceDebugIdInBundle: (debugId: string, bundleCode: string) => string;
/**
 * [INTERNAL] Inserts the Debug ID comment in the bundle in the correct position.
 */
export declare const _insertDebugIdCommentInBundle: (debugId: string, bundleCode: string) => string;
//# sourceMappingURL=debugIdHelper.d.ts.map