"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var index_exports = {};
__export(index_exports, {
  default: () => index_default
});
module.exports = __toCommonJS(index_exports);
var isObject = /* @__PURE__ */ __name((v) => v !== null && typeof v === "object", "isObject");
var join = /* @__PURE__ */ __name((segs, joinChar, options) => {
  if (typeof options.join === "function") {
    return options.join(segs);
  }
  return segs[0] + joinChar + segs[1];
}, "join");
var split = /* @__PURE__ */ __name((path, splitChar, options) => {
  if (typeof options.split === "function") {
    return options.split(path);
  }
  return path.split(splitChar);
}, "split");
var isValid = /* @__PURE__ */ __name((key, target = {}, options) => {
  if (typeof options?.isValid === "function") {
    return options.isValid(key, target);
  }
  return true;
}, "isValid");
var isValidObject = /* @__PURE__ */ __name((v) => {
  return isObject(v) || typeof v === "function";
}, "isValidObject");
var getValue = /* @__PURE__ */ __name((target, path, options = {}) => {
  if (!isObject(options)) {
    options = { default: options };
  }
  if (!isValidObject(target)) {
    return typeof options.default !== "undefined" ? options.default : target;
  }
  if (typeof path === "number") {
    path = String(path);
  }
  const pathIsArray = Array.isArray(path);
  const pathIsString = typeof path === "string";
  const splitChar = options.separator || ".";
  const joinChar = options.joinChar || (typeof splitChar === "string" ? splitChar : ".");
  if (!pathIsString && !pathIsArray) {
    return target;
  }
  if (target[path] !== void 0) {
    return isValid(path, target, options) ? target[path] : options.default;
  }
  const segs = pathIsArray ? path : split(path, splitChar, options);
  const len = segs.length;
  let idx = 0;
  do {
    let prop = segs[idx];
    if (typeof prop !== "string") {
      prop = String(prop);
    }
    while (prop && prop.slice(-1) === "\\") {
      prop = join([prop.slice(0, -1), segs[++idx] || ""], joinChar, options);
    }
    if (target[prop] !== void 0) {
      if (!isValid(prop, target, options)) {
        return options.default;
      }
      target = target[prop];
    } else {
      let hasProp = false;
      let n = idx + 1;
      while (n < len) {
        prop = join([prop, segs[n++]], joinChar, options);
        if (hasProp = target[prop] !== void 0) {
          if (!isValid(prop, target, options)) {
            return options.default;
          }
          target = target[prop];
          idx = n - 1;
          break;
        }
      }
      if (!hasProp) {
        return options.default;
      }
    }
  } while (++idx < len && isValidObject(target));
  if (idx === len) {
    return target;
  }
  return options.default;
}, "getValue");
var index_default = getValue;
/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
//# sourceMappingURL=index.js.map