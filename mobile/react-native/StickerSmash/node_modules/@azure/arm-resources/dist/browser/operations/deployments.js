/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from "tslib";
import { setContinuationToken } from "../pagingHelper.js";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers.js";
import * as Parameters from "../models/parameters.js";
import { createHttpPoller, } from "@azure/core-lro";
import { createLroSpec } from "../lroImpl.js";
/// <reference lib="esnext.asynciterable" />
/** Class containing Deployments operations. */
export class DeploymentsImpl {
    /**
     * Initialize a new instance of the class Deployments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all the deployments at the given scope.
     * @param scope The resource scope.
     * @param options The options parameters.
     */
    listAtScope(scope, options) {
        const iter = this.listAtScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAtScopePagingPage(scope, options, settings);
            },
        };
    }
    listAtScopePagingPage(scope, options, settings) {
        return __asyncGenerator(this, arguments, function* listAtScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listAtScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listAtScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listAtScopePagingAll(scope, options) {
        return __asyncGenerator(this, arguments, function* listAtScopePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listAtScopePagingPage(scope, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all the deployments at the tenant scope.
     * @param options The options parameters.
     */
    listAtTenantScope(options) {
        const iter = this.listAtTenantScopePagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAtTenantScopePagingPage(options, settings);
            },
        };
    }
    listAtTenantScopePagingPage(options, settings) {
        return __asyncGenerator(this, arguments, function* listAtTenantScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listAtTenantScope(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listAtTenantScopeNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listAtTenantScopePagingAll(options) {
        return __asyncGenerator(this, arguments, function* listAtTenantScopePagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listAtTenantScopePagingPage(options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get all the deployments for a management group.
     * @param groupId The management group ID.
     * @param options The options parameters.
     */
    listAtManagementGroupScope(groupId, options) {
        const iter = this.listAtManagementGroupScopePagingAll(groupId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAtManagementGroupScopePagingPage(groupId, options, settings);
            },
        };
    }
    listAtManagementGroupScopePagingPage(groupId, options, settings) {
        return __asyncGenerator(this, arguments, function* listAtManagementGroupScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listAtManagementGroupScope(groupId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listAtManagementGroupScopeNext(groupId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listAtManagementGroupScopePagingAll(groupId, options) {
        return __asyncGenerator(this, arguments, function* listAtManagementGroupScopePagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listAtManagementGroupScopePagingPage(groupId, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Get all the deployments for a subscription.
     * @param options The options parameters.
     */
    listAtSubscriptionScope(options) {
        const iter = this.listAtSubscriptionScopePagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAtSubscriptionScopePagingPage(options, settings);
            },
        };
    }
    listAtSubscriptionScopePagingPage(options, settings) {
        return __asyncGenerator(this, arguments, function* listAtSubscriptionScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listAtSubscriptionScope(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listAtSubscriptionScopeNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listAtSubscriptionScopePagingAll(options) {
        return __asyncGenerator(this, arguments, function* listAtSubscriptionScopePagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listAtSubscriptionScopePagingPage(options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Get all the deployments for a resource group.
     * @param resourceGroupName The name of the resource group with the deployments to get. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return __asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return __asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    async beginDeleteAtScope(scope, deploymentName, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { scope, deploymentName, options },
            spec: deleteAtScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    async beginDeleteAtScopeAndWait(scope, deploymentName, options) {
        const poller = await this.beginDeleteAtScope(scope, deploymentName, options);
        return poller.pollUntilDone();
    }
    /**
     * Checks whether the deployment exists.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistenceAtScope(scope, deploymentName, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, options }, checkExistenceAtScopeOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    async beginCreateOrUpdateAtScope(scope, deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { scope, deploymentName, parameters, options },
            spec: createOrUpdateAtScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    async beginCreateOrUpdateAtScopeAndWait(scope, deploymentName, parameters, options) {
        const poller = await this.beginCreateOrUpdateAtScope(scope, deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Gets a deployment.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    getAtScope(scope, deploymentName, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, options }, getAtScopeOperationSpec);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resources partially deployed.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancelAtScope(scope, deploymentName, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, options }, cancelAtScopeOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginValidateAtScope(scope, deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { scope, deploymentName, parameters, options },
            spec: validateAtScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginValidateAtScopeAndWait(scope, deploymentName, parameters, options) {
        const poller = await this.beginValidateAtScope(scope, deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Exports the template used for specified deployment.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplateAtScope(scope, deploymentName, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, options }, exportTemplateAtScopeOperationSpec);
    }
    /**
     * Get all the deployments at the given scope.
     * @param scope The resource scope.
     * @param options The options parameters.
     */
    _listAtScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listAtScopeOperationSpec);
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    async beginDeleteAtTenantScope(deploymentName, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { deploymentName, options },
            spec: deleteAtTenantScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    async beginDeleteAtTenantScopeAndWait(deploymentName, options) {
        const poller = await this.beginDeleteAtTenantScope(deploymentName, options);
        return poller.pollUntilDone();
    }
    /**
     * Checks whether the deployment exists.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistenceAtTenantScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, checkExistenceAtTenantScopeOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    async beginCreateOrUpdateAtTenantScope(deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { deploymentName, parameters, options },
            spec: createOrUpdateAtTenantScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    async beginCreateOrUpdateAtTenantScopeAndWait(deploymentName, parameters, options) {
        const poller = await this.beginCreateOrUpdateAtTenantScope(deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Gets a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    getAtTenantScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, getAtTenantScopeOperationSpec);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resources partially deployed.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancelAtTenantScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, cancelAtTenantScopeOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginValidateAtTenantScope(deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { deploymentName, parameters, options },
            spec: validateAtTenantScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginValidateAtTenantScopeAndWait(deploymentName, parameters, options) {
        const poller = await this.beginValidateAtTenantScope(deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the tenant group.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginWhatIfAtTenantScope(deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { deploymentName, parameters, options },
            spec: whatIfAtTenantScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the tenant group.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginWhatIfAtTenantScopeAndWait(deploymentName, parameters, options) {
        const poller = await this.beginWhatIfAtTenantScope(deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Exports the template used for specified deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplateAtTenantScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, exportTemplateAtTenantScopeOperationSpec);
    }
    /**
     * Get all the deployments at the tenant scope.
     * @param options The options parameters.
     */
    _listAtTenantScope(options) {
        return this.client.sendOperationRequest({ options }, listAtTenantScopeOperationSpec);
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    async beginDeleteAtManagementGroupScope(groupId, deploymentName, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { groupId, deploymentName, options },
            spec: deleteAtManagementGroupScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    async beginDeleteAtManagementGroupScopeAndWait(groupId, deploymentName, options) {
        const poller = await this.beginDeleteAtManagementGroupScope(groupId, deploymentName, options);
        return poller.pollUntilDone();
    }
    /**
     * Checks whether the deployment exists.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistenceAtManagementGroupScope(groupId, deploymentName, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, options }, checkExistenceAtManagementGroupScopeOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    async beginCreateOrUpdateAtManagementGroupScope(groupId, deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { groupId, deploymentName, parameters, options },
            spec: createOrUpdateAtManagementGroupScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    async beginCreateOrUpdateAtManagementGroupScopeAndWait(groupId, deploymentName, parameters, options) {
        const poller = await this.beginCreateOrUpdateAtManagementGroupScope(groupId, deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Gets a deployment.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    getAtManagementGroupScope(groupId, deploymentName, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, options }, getAtManagementGroupScopeOperationSpec);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resources partially deployed.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancelAtManagementGroupScope(groupId, deploymentName, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, options }, cancelAtManagementGroupScopeOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginValidateAtManagementGroupScope(groupId, deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { groupId, deploymentName, parameters, options },
            spec: validateAtManagementGroupScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginValidateAtManagementGroupScopeAndWait(groupId, deploymentName, parameters, options) {
        const poller = await this.beginValidateAtManagementGroupScope(groupId, deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the management
     * group.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginWhatIfAtManagementGroupScope(groupId, deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { groupId, deploymentName, parameters, options },
            spec: whatIfAtManagementGroupScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the management
     * group.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginWhatIfAtManagementGroupScopeAndWait(groupId, deploymentName, parameters, options) {
        const poller = await this.beginWhatIfAtManagementGroupScope(groupId, deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Exports the template used for specified deployment.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplateAtManagementGroupScope(groupId, deploymentName, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, options }, exportTemplateAtManagementGroupScopeOperationSpec);
    }
    /**
     * Get all the deployments for a management group.
     * @param groupId The management group ID.
     * @param options The options parameters.
     */
    _listAtManagementGroupScope(groupId, options) {
        return this.client.sendOperationRequest({ groupId, options }, listAtManagementGroupScopeOperationSpec);
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    async beginDeleteAtSubscriptionScope(deploymentName, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { deploymentName, options },
            spec: deleteAtSubscriptionScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    async beginDeleteAtSubscriptionScopeAndWait(deploymentName, options) {
        const poller = await this.beginDeleteAtSubscriptionScope(deploymentName, options);
        return poller.pollUntilDone();
    }
    /**
     * Checks whether the deployment exists.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistenceAtSubscriptionScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, checkExistenceAtSubscriptionScopeOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    async beginCreateOrUpdateAtSubscriptionScope(deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { deploymentName, parameters, options },
            spec: createOrUpdateAtSubscriptionScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    async beginCreateOrUpdateAtSubscriptionScopeAndWait(deploymentName, parameters, options) {
        const poller = await this.beginCreateOrUpdateAtSubscriptionScope(deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Gets a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    getAtSubscriptionScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, getAtSubscriptionScopeOperationSpec);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resources partially deployed.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancelAtSubscriptionScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, cancelAtSubscriptionScopeOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginValidateAtSubscriptionScope(deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { deploymentName, parameters, options },
            spec: validateAtSubscriptionScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginValidateAtSubscriptionScopeAndWait(deploymentName, parameters, options) {
        const poller = await this.beginValidateAtSubscriptionScope(deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the subscription.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to What If.
     * @param options The options parameters.
     */
    async beginWhatIfAtSubscriptionScope(deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { deploymentName, parameters, options },
            spec: whatIfAtSubscriptionScopeOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the subscription.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to What If.
     * @param options The options parameters.
     */
    async beginWhatIfAtSubscriptionScopeAndWait(deploymentName, parameters, options) {
        const poller = await this.beginWhatIfAtSubscriptionScope(deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Exports the template used for specified deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplateAtSubscriptionScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, exportTemplateAtSubscriptionScopeOperationSpec);
    }
    /**
     * Get all the deployments for a subscription.
     * @param options The options parameters.
     */
    _listAtSubscriptionScope(options) {
        return this.client.sendOperationRequest({ options }, listAtSubscriptionScopeOperationSpec);
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. Deleting a template deployment does not affect the
     * state of the resource group. This is an asynchronous operation that returns a status of 202 until
     * the template deployment is successfully deleted. The Location response header contains the URI that
     * is used to obtain the status of the process. While the process is running, a call to the URI in the
     * Location header returns a status of 202. When the process finishes, the URI in the Location header
     * returns a status of 204 on success. If the asynchronous request failed, the URI in the Location
     * header returns an error-level status code.
     * @param resourceGroupName The name of the resource group with the deployment to delete. The name is
     *                          case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    async beginDelete(resourceGroupName, deploymentName, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { resourceGroupName, deploymentName, options },
            spec: deleteOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. Deleting a template deployment does not affect the
     * state of the resource group. This is an asynchronous operation that returns a status of 202 until
     * the template deployment is successfully deleted. The Location response header contains the URI that
     * is used to obtain the status of the process. While the process is running, a call to the URI in the
     * Location header returns a status of 202. When the process finishes, the URI in the Location header
     * returns a status of 204 on success. If the asynchronous request failed, the URI in the Location
     * header returns an error-level status code.
     * @param resourceGroupName The name of the resource group with the deployment to delete. The name is
     *                          case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    async beginDeleteAndWait(resourceGroupName, deploymentName, options) {
        const poller = await this.beginDelete(resourceGroupName, deploymentName, options);
        return poller.pollUntilDone();
    }
    /**
     * Checks whether the deployment exists.
     * @param resourceGroupName The name of the resource group with the deployment to check. The name is
     *                          case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistence(resourceGroupName, deploymentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, options }, checkExistenceOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param resourceGroupName The name of the resource group to deploy the resources to. The name is case
     *                          insensitive. The resource group must already exist.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    async beginCreateOrUpdate(resourceGroupName, deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { resourceGroupName, deploymentName, parameters, options },
            spec: createOrUpdateOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param resourceGroupName The name of the resource group to deploy the resources to. The name is case
     *                          insensitive. The resource group must already exist.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    async beginCreateOrUpdateAndWait(resourceGroupName, deploymentName, parameters, options) {
        const poller = await this.beginCreateOrUpdate(resourceGroupName, deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Gets a deployment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    get(resourceGroupName, deploymentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, options }, getOperationSpec);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resource group partially deployed.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancel(resourceGroupName, deploymentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, options }, cancelOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param resourceGroupName The name of the resource group the template will be deployed to. The name
     *                          is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginValidate(resourceGroupName, deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { resourceGroupName, deploymentName, parameters, options },
            spec: validateOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
        });
        await poller.poll();
        return poller;
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param resourceGroupName The name of the resource group the template will be deployed to. The name
     *                          is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginValidateAndWait(resourceGroupName, deploymentName, parameters, options) {
        const poller = await this.beginValidate(resourceGroupName, deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the resource group.
     * @param resourceGroupName The name of the resource group the template will be deployed to. The name
     *                          is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginWhatIf(resourceGroupName, deploymentName, parameters, options) {
        const directSendOperation = async (args, spec) => {
            return this.client.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { resourceGroupName, deploymentName, parameters, options },
            spec: whatIfOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the resource group.
     * @param resourceGroupName The name of the resource group the template will be deployed to. The name
     *                          is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    async beginWhatIfAndWait(resourceGroupName, deploymentName, parameters, options) {
        const poller = await this.beginWhatIf(resourceGroupName, deploymentName, parameters, options);
        return poller.pollUntilDone();
    }
    /**
     * Exports the template used for specified deployment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplate(resourceGroupName, deploymentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, options }, exportTemplateOperationSpec);
    }
    /**
     * Get all the deployments for a resource group.
     * @param resourceGroupName The name of the resource group with the deployments to get. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Calculate the hash of the given template.
     * @param template The template provided to calculate hash.
     * @param options The options parameters.
     */
    calculateTemplateHash(template, options) {
        return this.client.sendOperationRequest({ template, options }, calculateTemplateHashOperationSpec);
    }
    /**
     * ListAtScopeNext
     * @param scope The resource scope.
     * @param nextLink The nextLink from the previous successful call to the ListAtScope method.
     * @param options The options parameters.
     */
    _listAtScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listAtScopeNextOperationSpec);
    }
    /**
     * ListAtTenantScopeNext
     * @param nextLink The nextLink from the previous successful call to the ListAtTenantScope method.
     * @param options The options parameters.
     */
    _listAtTenantScopeNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAtTenantScopeNextOperationSpec);
    }
    /**
     * ListAtManagementGroupScopeNext
     * @param groupId The management group ID.
     * @param nextLink The nextLink from the previous successful call to the ListAtManagementGroupScope
     *                 method.
     * @param options The options parameters.
     */
    _listAtManagementGroupScopeNext(groupId, nextLink, options) {
        return this.client.sendOperationRequest({ groupId, nextLink, options }, listAtManagementGroupScopeNextOperationSpec);
    }
    /**
     * ListAtSubscriptionScopeNext
     * @param nextLink The nextLink from the previous successful call to the ListAtSubscriptionScope
     *                 method.
     * @param options The options parameters.
     */
    _listAtSubscriptionScopeNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAtSubscriptionScopeNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group with the deployments to get. The name is
     *                          case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const checkExistenceAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const createOrUpdateAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        201: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        202: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        204: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const cancelAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const validateAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        201: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        202: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        204: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const exportTemplateAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExportResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const listAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [Parameters.$host, Parameters.scope],
    headerParameters: [Parameters.accept],
    serializer,
};
const deleteAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept],
    serializer,
};
const checkExistenceAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept],
    serializer,
};
const createOrUpdateAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        201: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        202: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        204: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters1,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept],
    serializer,
};
const cancelAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept],
    serializer,
};
const validateAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        201: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        202: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        204: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters1,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const whatIfAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        201: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        202: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        204: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters2,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const exportTemplateAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExportResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept],
    serializer,
};
const listAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept],
    serializer,
};
const deleteAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const checkExistenceAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const createOrUpdateAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        201: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        202: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        204: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters1,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const cancelAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const validateAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        201: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        202: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        204: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters1,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const whatIfAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        201: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        202: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        204: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters2,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const exportTemplateAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExportResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const listAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [Parameters.$host, Parameters.groupId],
    headerParameters: [Parameters.accept],
    serializer,
};
const deleteAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const checkExistenceAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const createOrUpdateAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        201: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        202: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        204: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const cancelAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const validateAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        201: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        202: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        204: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const whatIfAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        201: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        202: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        204: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters3,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const exportTemplateAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExportResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const listAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [Parameters.$host, Parameters.subscriptionId],
    headerParameters: [Parameters.accept],
    serializer,
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const checkExistenceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        201: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        202: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        204: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const cancelOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const validateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        201: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        202: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        204: {
            bodyMapper: Mappers.DeploymentValidateResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const whatIfOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        201: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        202: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        204: {
            bodyMapper: Mappers.WhatIfOperationResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters3,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const exportTemplateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExportResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const calculateTemplateHashOperationSpec = {
    path: "/providers/Microsoft.Resources/calculateTemplateHash",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.TemplateHashResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.template,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const listAtScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.scope],
    headerParameters: [Parameters.accept],
    serializer,
};
const listAtTenantScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    urlParameters: [Parameters.$host, Parameters.nextLink],
    headerParameters: [Parameters.accept],
    serializer,
};
const listAtManagementGroupScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.groupId],
    headerParameters: [Parameters.accept],
    serializer,
};
const listAtSubscriptionScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
//# sourceMappingURL=deployments.js.map